# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

from . import _pysgpp_swig

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

M_E = _pysgpp_swig.M_E
M_LOG2E = _pysgpp_swig.M_LOG2E
M_LOG10E = _pysgpp_swig.M_LOG10E
M_LN2 = _pysgpp_swig.M_LN2
M_LN10 = _pysgpp_swig.M_LN10
M_PI = _pysgpp_swig.M_PI
M_PI_2 = _pysgpp_swig.M_PI_2
M_PI_4 = _pysgpp_swig.M_PI_4
M_1_PI = _pysgpp_swig.M_1_PI
M_2_PI = _pysgpp_swig.M_2_PI
M_2_SQRTPI = _pysgpp_swig.M_2_SQRTPI
M_SQRT2 = _pysgpp_swig.M_SQRT2
M_SQRT1_2 = _pysgpp_swig.M_SQRT1_2
M_1_SQRT2PI = _pysgpp_swig.M_1_SQRT2PI
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _pysgpp_swig.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _pysgpp_swig.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _pysgpp_swig.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _pysgpp_swig.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _pysgpp_swig.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _pysgpp_swig.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _pysgpp_swig.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _pysgpp_swig.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _pysgpp_swig.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _pysgpp_swig.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _pysgpp_swig.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _pysgpp_swig.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _pysgpp_swig.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _pysgpp_swig:
_pysgpp_swig.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _pysgpp_swig.SHARED_PTR_DISOWN
class unsignedIntArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _pysgpp_swig.unsignedIntArray_swiginit(self, _pysgpp_swig.new_unsignedIntArray(nelements))
    __swig_destroy__ = _pysgpp_swig.delete_unsignedIntArray

    def __getitem__(self, index: "size_t") -> "unsigned int":
        return _pysgpp_swig.unsignedIntArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "unsigned int") -> "void":
        return _pysgpp_swig.unsignedIntArray___setitem__(self, index, value)

    def cast(self) -> "unsigned int *":
        return _pysgpp_swig.unsignedIntArray_cast(self)

    @staticmethod
    def frompointer(t: "unsigned int *") -> "unsignedIntArray *":
        return _pysgpp_swig.unsignedIntArray_frompointer(t)

# Register unsignedIntArray in _pysgpp_swig:
_pysgpp_swig.unsignedIntArray_swigregister(unsignedIntArray)

def unsignedIntArray_frompointer(t: "unsigned int *") -> "unsignedIntArray *":
    return _pysgpp_swig.unsignedIntArray_frompointer(t)

class BoolArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _pysgpp_swig.BoolArray_swiginit(self, _pysgpp_swig.new_BoolArray(nelements))
    __swig_destroy__ = _pysgpp_swig.delete_BoolArray

    def __getitem__(self, index: "size_t") -> "bool":
        return _pysgpp_swig.BoolArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "bool") -> "void":
        return _pysgpp_swig.BoolArray___setitem__(self, index, value)

    def cast(self) -> "bool *":
        return _pysgpp_swig.BoolArray_cast(self)

    @staticmethod
    def frompointer(t: "bool *") -> "BoolArray *":
        return _pysgpp_swig.BoolArray_frompointer(t)

# Register BoolArray in _pysgpp_swig:
_pysgpp_swig.BoolArray_swigregister(BoolArray)

def BoolArray_frompointer(t: "bool *") -> "BoolArray *":
    return _pysgpp_swig.BoolArray_frompointer(t)

class IntArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _pysgpp_swig.IntArray_swiginit(self, _pysgpp_swig.new_IntArray(nelements))
    __swig_destroy__ = _pysgpp_swig.delete_IntArray

    def __getitem__(self, index: "size_t") -> "int":
        return _pysgpp_swig.IntArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "int") -> "void":
        return _pysgpp_swig.IntArray___setitem__(self, index, value)

    def cast(self) -> "int *":
        return _pysgpp_swig.IntArray_cast(self)

    @staticmethod
    def frompointer(t: "int *") -> "IntArray *":
        return _pysgpp_swig.IntArray_frompointer(t)

# Register IntArray in _pysgpp_swig:
_pysgpp_swig.IntArray_swigregister(IntArray)

def IntArray_frompointer(t: "int *") -> "IntArray *":
    return _pysgpp_swig.IntArray_frompointer(t)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _pysgpp_swig.IntVector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _pysgpp_swig.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.IntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _pysgpp_swig.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _pysgpp_swig.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _pysgpp_swig.IntVector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _pysgpp_swig.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _pysgpp_swig.IntVector_size(self)

    def swap(self, v: "IntVector") -> "void":
        return _pysgpp_swig.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _pysgpp_swig.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _pysgpp_swig.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _pysgpp_swig.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _pysgpp_swig.IntVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _pysgpp_swig.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _pysgpp_swig.IntVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.IntVector_swiginit(self, _pysgpp_swig.new_IntVector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _pysgpp_swig.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _pysgpp_swig.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _pysgpp_swig.IntVector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _pysgpp_swig.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.IntVector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _pysgpp_swig.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _pysgpp_swig.IntVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_IntVector

# Register IntVector in _pysgpp_swig:
_pysgpp_swig.IntVector_swigregister(IntVector)

class IntVectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.IntVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.IntVectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.IntVectorVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< int > >::size_type":
        return _pysgpp_swig.IntVectorVector___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< int > >::difference_type", j: "std::vector< std::vector< int > >::difference_type") -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *":
        return _pysgpp_swig.IntVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.IntVectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< int > >::difference_type", j: "std::vector< std::vector< int > >::difference_type") -> "void":
        return _pysgpp_swig.IntVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.IntVectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< int > >::value_type const &":
        return _pysgpp_swig.IntVectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.IntVectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< int > >::value_type":
        return _pysgpp_swig.IntVectorVector_pop(self)

    def append(self, x: "IntVector") -> "void":
        return _pysgpp_swig.IntVectorVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.IntVectorVector_empty(self)

    def size(self) -> "std::vector< std::vector< int > >::size_type":
        return _pysgpp_swig.IntVectorVector_size(self)

    def swap(self, v: "IntVectorVector") -> "void":
        return _pysgpp_swig.IntVectorVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< int > >::iterator":
        return _pysgpp_swig.IntVectorVector_begin(self)

    def end(self) -> "std::vector< std::vector< int > >::iterator":
        return _pysgpp_swig.IntVectorVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        return _pysgpp_swig.IntVectorVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        return _pysgpp_swig.IntVectorVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.IntVectorVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< int > >::allocator_type":
        return _pysgpp_swig.IntVectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.IntVectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< int > >::iterator":
        return _pysgpp_swig.IntVectorVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.IntVectorVector_swiginit(self, _pysgpp_swig.new_IntVectorVector(*args))

    def push_back(self, x: "IntVector") -> "void":
        return _pysgpp_swig.IntVectorVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< int > >::value_type const &":
        return _pysgpp_swig.IntVectorVector_front(self)

    def back(self) -> "std::vector< std::vector< int > >::value_type const &":
        return _pysgpp_swig.IntVectorVector_back(self)

    def assign(self, n: "std::vector< std::vector< int > >::size_type", x: "IntVector") -> "void":
        return _pysgpp_swig.IntVectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.IntVectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.IntVectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< int > >::size_type") -> "void":
        return _pysgpp_swig.IntVectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< int > >::size_type":
        return _pysgpp_swig.IntVectorVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_IntVectorVector

# Register IntVectorVector in _pysgpp_swig:
_pysgpp_swig.IntVectorVector_swigregister(IntVectorVector)

class BoolVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.BoolVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.BoolVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.BoolVector___bool__(self)

    def __len__(self) -> "std::vector< bool >::size_type":
        return _pysgpp_swig.BoolVector___len__(self)

    def __getslice__(self, i: "std::vector< bool >::difference_type", j: "std::vector< bool >::difference_type") -> "std::vector< bool,std::allocator< bool > > *":
        return _pysgpp_swig.BoolVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.BoolVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< bool >::difference_type", j: "std::vector< bool >::difference_type") -> "void":
        return _pysgpp_swig.BoolVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.BoolVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< bool >::value_type":
        return _pysgpp_swig.BoolVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.BoolVector___setitem__(self, *args)

    def pop(self) -> "std::vector< bool >::value_type":
        return _pysgpp_swig.BoolVector_pop(self)

    def append(self, x: "std::vector< bool >::value_type") -> "void":
        return _pysgpp_swig.BoolVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.BoolVector_empty(self)

    def size(self) -> "std::vector< bool >::size_type":
        return _pysgpp_swig.BoolVector_size(self)

    def swap(self, v: "BoolVector") -> "void":
        return _pysgpp_swig.BoolVector_swap(self, v)

    def begin(self) -> "std::vector< bool >::iterator":
        return _pysgpp_swig.BoolVector_begin(self)

    def end(self) -> "std::vector< bool >::iterator":
        return _pysgpp_swig.BoolVector_end(self)

    def rbegin(self) -> "std::vector< bool >::reverse_iterator":
        return _pysgpp_swig.BoolVector_rbegin(self)

    def rend(self) -> "std::vector< bool >::reverse_iterator":
        return _pysgpp_swig.BoolVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.BoolVector_clear(self)

    def get_allocator(self) -> "std::vector< bool >::allocator_type":
        return _pysgpp_swig.BoolVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.BoolVector_pop_back(self)

    def erase(self, *args) -> "std::vector< bool >::iterator":
        return _pysgpp_swig.BoolVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.BoolVector_swiginit(self, _pysgpp_swig.new_BoolVector(*args))

    def push_back(self, x: "std::vector< bool >::value_type") -> "void":
        return _pysgpp_swig.BoolVector_push_back(self, x)

    def front(self) -> "std::vector< bool >::value_type":
        return _pysgpp_swig.BoolVector_front(self)

    def back(self) -> "std::vector< bool >::value_type":
        return _pysgpp_swig.BoolVector_back(self)

    def assign(self, n: "std::vector< bool >::size_type", x: "std::vector< bool >::value_type") -> "void":
        return _pysgpp_swig.BoolVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.BoolVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.BoolVector_insert(self, *args)

    def reserve(self, n: "std::vector< bool >::size_type") -> "void":
        return _pysgpp_swig.BoolVector_reserve(self, n)

    def capacity(self) -> "std::vector< bool >::size_type":
        return _pysgpp_swig.BoolVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_BoolVector

# Register BoolVector in _pysgpp_swig:
_pysgpp_swig.BoolVector_swigregister(BoolVector)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _pysgpp_swig.DoubleVector___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _pysgpp_swig.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _pysgpp_swig.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _pysgpp_swig.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _pysgpp_swig.DoubleVector_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _pysgpp_swig.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _pysgpp_swig.DoubleVector_size(self)

    def swap(self, v: "DoubleVector") -> "void":
        return _pysgpp_swig.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _pysgpp_swig.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _pysgpp_swig.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _pysgpp_swig.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _pysgpp_swig.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _pysgpp_swig.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _pysgpp_swig.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.DoubleVector_swiginit(self, _pysgpp_swig.new_DoubleVector(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _pysgpp_swig.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _pysgpp_swig.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _pysgpp_swig.DoubleVector_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _pysgpp_swig.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.DoubleVector_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _pysgpp_swig.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _pysgpp_swig.DoubleVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_DoubleVector

# Register DoubleVector in _pysgpp_swig:
_pysgpp_swig.DoubleVector_swigregister(DoubleVector)

class FloatVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.FloatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.FloatVector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _pysgpp_swig.FloatVector___len__(self)

    def __getslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "std::vector< float,std::allocator< float > > *":
        return _pysgpp_swig.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.FloatVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "void":
        return _pysgpp_swig.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _pysgpp_swig.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.FloatVector___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _pysgpp_swig.FloatVector_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        return _pysgpp_swig.FloatVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.FloatVector_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _pysgpp_swig.FloatVector_size(self)

    def swap(self, v: "FloatVector") -> "void":
        return _pysgpp_swig.FloatVector_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _pysgpp_swig.FloatVector_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _pysgpp_swig.FloatVector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _pysgpp_swig.FloatVector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _pysgpp_swig.FloatVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.FloatVector_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _pysgpp_swig.FloatVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.FloatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _pysgpp_swig.FloatVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.FloatVector_swiginit(self, _pysgpp_swig.new_FloatVector(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        return _pysgpp_swig.FloatVector_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _pysgpp_swig.FloatVector_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _pysgpp_swig.FloatVector_back(self)

    def assign(self, n: "std::vector< float >::size_type", x: "std::vector< float >::value_type const &") -> "void":
        return _pysgpp_swig.FloatVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.FloatVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.FloatVector_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        return _pysgpp_swig.FloatVector_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _pysgpp_swig.FloatVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_FloatVector

# Register FloatVector in _pysgpp_swig:
_pysgpp_swig.FloatVector_swigregister(FloatVector)

class SizeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.SizeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.SizeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.SizeVector___bool__(self)

    def __len__(self) -> "std::vector< size_t >::size_type":
        return _pysgpp_swig.SizeVector___len__(self)

    def __getslice__(self, i: "std::vector< size_t >::difference_type", j: "std::vector< size_t >::difference_type") -> "std::vector< size_t,std::allocator< size_t > > *":
        return _pysgpp_swig.SizeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.SizeVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< size_t >::difference_type", j: "std::vector< size_t >::difference_type") -> "void":
        return _pysgpp_swig.SizeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.SizeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< size_t >::value_type const &":
        return _pysgpp_swig.SizeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.SizeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< size_t >::value_type":
        return _pysgpp_swig.SizeVector_pop(self)

    def append(self, x: "std::vector< size_t >::value_type const &") -> "void":
        return _pysgpp_swig.SizeVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.SizeVector_empty(self)

    def size(self) -> "std::vector< size_t >::size_type":
        return _pysgpp_swig.SizeVector_size(self)

    def swap(self, v: "SizeVector") -> "void":
        return _pysgpp_swig.SizeVector_swap(self, v)

    def begin(self) -> "std::vector< size_t >::iterator":
        return _pysgpp_swig.SizeVector_begin(self)

    def end(self) -> "std::vector< size_t >::iterator":
        return _pysgpp_swig.SizeVector_end(self)

    def rbegin(self) -> "std::vector< size_t >::reverse_iterator":
        return _pysgpp_swig.SizeVector_rbegin(self)

    def rend(self) -> "std::vector< size_t >::reverse_iterator":
        return _pysgpp_swig.SizeVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.SizeVector_clear(self)

    def get_allocator(self) -> "std::vector< size_t >::allocator_type":
        return _pysgpp_swig.SizeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.SizeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< size_t >::iterator":
        return _pysgpp_swig.SizeVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.SizeVector_swiginit(self, _pysgpp_swig.new_SizeVector(*args))

    def push_back(self, x: "std::vector< size_t >::value_type const &") -> "void":
        return _pysgpp_swig.SizeVector_push_back(self, x)

    def front(self) -> "std::vector< size_t >::value_type const &":
        return _pysgpp_swig.SizeVector_front(self)

    def back(self) -> "std::vector< size_t >::value_type const &":
        return _pysgpp_swig.SizeVector_back(self)

    def assign(self, n: "std::vector< size_t >::size_type", x: "std::vector< size_t >::value_type const &") -> "void":
        return _pysgpp_swig.SizeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.SizeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.SizeVector_insert(self, *args)

    def reserve(self, n: "std::vector< size_t >::size_type") -> "void":
        return _pysgpp_swig.SizeVector_reserve(self, n)

    def capacity(self) -> "std::vector< size_t >::size_type":
        return _pysgpp_swig.SizeVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_SizeVector

# Register SizeVector in _pysgpp_swig:
_pysgpp_swig.SizeVector_swigregister(SizeVector)

class SizeDoublePair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pysgpp_swig.SizeDoublePair_swiginit(self, _pysgpp_swig.new_SizeDoublePair(*args))
    first = property(_pysgpp_swig.SizeDoublePair_first_get, _pysgpp_swig.SizeDoublePair_first_set)
    second = property(_pysgpp_swig.SizeDoublePair_second_get, _pysgpp_swig.SizeDoublePair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pysgpp_swig.delete_SizeDoublePair

# Register SizeDoublePair in _pysgpp_swig:
_pysgpp_swig.SizeDoublePair_swigregister(SizeDoublePair)

class SizeDoublePairVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.SizeDoublePairVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.SizeDoublePairVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.SizeDoublePairVector___bool__(self)

    def __len__(self) -> "std::vector< std::pair< size_t,double > >::size_type":
        return _pysgpp_swig.SizeDoublePairVector___len__(self)

    def __getslice__(self, i: "std::vector< std::pair< size_t,double > >::difference_type", j: "std::vector< std::pair< size_t,double > >::difference_type") -> "std::vector< std::pair< size_t,double >,std::allocator< std::pair< size_t,double > > > *":
        return _pysgpp_swig.SizeDoublePairVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.SizeDoublePairVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::pair< size_t,double > >::difference_type", j: "std::vector< std::pair< size_t,double > >::difference_type") -> "void":
        return _pysgpp_swig.SizeDoublePairVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.SizeDoublePairVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::pair< size_t,double > >::value_type const &":
        return _pysgpp_swig.SizeDoublePairVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.SizeDoublePairVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::pair< size_t,double > >::value_type":
        return _pysgpp_swig.SizeDoublePairVector_pop(self)

    def append(self, x: "SizeDoublePair") -> "void":
        return _pysgpp_swig.SizeDoublePairVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.SizeDoublePairVector_empty(self)

    def size(self) -> "std::vector< std::pair< size_t,double > >::size_type":
        return _pysgpp_swig.SizeDoublePairVector_size(self)

    def swap(self, v: "SizeDoublePairVector") -> "void":
        return _pysgpp_swig.SizeDoublePairVector_swap(self, v)

    def begin(self) -> "std::vector< std::pair< size_t,double > >::iterator":
        return _pysgpp_swig.SizeDoublePairVector_begin(self)

    def end(self) -> "std::vector< std::pair< size_t,double > >::iterator":
        return _pysgpp_swig.SizeDoublePairVector_end(self)

    def rbegin(self) -> "std::vector< std::pair< size_t,double > >::reverse_iterator":
        return _pysgpp_swig.SizeDoublePairVector_rbegin(self)

    def rend(self) -> "std::vector< std::pair< size_t,double > >::reverse_iterator":
        return _pysgpp_swig.SizeDoublePairVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.SizeDoublePairVector_clear(self)

    def get_allocator(self) -> "std::vector< std::pair< size_t,double > >::allocator_type":
        return _pysgpp_swig.SizeDoublePairVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.SizeDoublePairVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::pair< size_t,double > >::iterator":
        return _pysgpp_swig.SizeDoublePairVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.SizeDoublePairVector_swiginit(self, _pysgpp_swig.new_SizeDoublePairVector(*args))

    def push_back(self, x: "SizeDoublePair") -> "void":
        return _pysgpp_swig.SizeDoublePairVector_push_back(self, x)

    def front(self) -> "std::vector< std::pair< size_t,double > >::value_type const &":
        return _pysgpp_swig.SizeDoublePairVector_front(self)

    def back(self) -> "std::vector< std::pair< size_t,double > >::value_type const &":
        return _pysgpp_swig.SizeDoublePairVector_back(self)

    def assign(self, n: "std::vector< std::pair< size_t,double > >::size_type", x: "SizeDoublePair") -> "void":
        return _pysgpp_swig.SizeDoublePairVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.SizeDoublePairVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.SizeDoublePairVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::pair< size_t,double > >::size_type") -> "void":
        return _pysgpp_swig.SizeDoublePairVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::pair< size_t,double > >::size_type":
        return _pysgpp_swig.SizeDoublePairVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_SizeDoublePairVector

# Register SizeDoublePairVector in _pysgpp_swig:
_pysgpp_swig.SizeDoublePairVector_swigregister(SizeDoublePairVector)

class SizeList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.SizeList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.SizeList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.SizeList___bool__(self)

    def __len__(self) -> "std::list< size_t >::size_type":
        return _pysgpp_swig.SizeList___len__(self)

    def __getslice__(self, i: "std::list< size_t >::difference_type", j: "std::list< size_t >::difference_type") -> "std::list< size_t,std::allocator< size_t > > *":
        return _pysgpp_swig.SizeList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.SizeList___setslice__(self, *args)

    def __delslice__(self, i: "std::list< size_t >::difference_type", j: "std::list< size_t >::difference_type") -> "void":
        return _pysgpp_swig.SizeList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.SizeList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< size_t >::value_type const &":
        return _pysgpp_swig.SizeList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.SizeList___setitem__(self, *args)

    def pop(self) -> "std::list< size_t >::value_type":
        return _pysgpp_swig.SizeList_pop(self)

    def append(self, x: "std::list< size_t >::value_type const &") -> "void":
        return _pysgpp_swig.SizeList_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.SizeList_empty(self)

    def size(self) -> "std::list< size_t >::size_type":
        return _pysgpp_swig.SizeList_size(self)

    def swap(self, v: "SizeList") -> "void":
        return _pysgpp_swig.SizeList_swap(self, v)

    def begin(self) -> "std::list< size_t >::iterator":
        return _pysgpp_swig.SizeList_begin(self)

    def end(self) -> "std::list< size_t >::iterator":
        return _pysgpp_swig.SizeList_end(self)

    def rbegin(self) -> "std::list< size_t >::reverse_iterator":
        return _pysgpp_swig.SizeList_rbegin(self)

    def rend(self) -> "std::list< size_t >::reverse_iterator":
        return _pysgpp_swig.SizeList_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.SizeList_clear(self)

    def get_allocator(self) -> "std::list< size_t >::allocator_type":
        return _pysgpp_swig.SizeList_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.SizeList_pop_back(self)

    def erase(self, *args) -> "std::list< size_t >::iterator":
        return _pysgpp_swig.SizeList_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.SizeList_swiginit(self, _pysgpp_swig.new_SizeList(*args))

    def push_back(self, x: "std::list< size_t >::value_type const &") -> "void":
        return _pysgpp_swig.SizeList_push_back(self, x)

    def front(self) -> "std::list< size_t >::value_type const &":
        return _pysgpp_swig.SizeList_front(self)

    def back(self) -> "std::list< size_t >::value_type const &":
        return _pysgpp_swig.SizeList_back(self)

    def assign(self, n: "std::list< size_t >::size_type", x: "std::list< size_t >::value_type const &") -> "void":
        return _pysgpp_swig.SizeList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.SizeList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.SizeList_insert(self, *args)

    def pop_front(self) -> "void":
        return _pysgpp_swig.SizeList_pop_front(self)

    def push_front(self, x: "std::list< size_t >::value_type const &") -> "void":
        return _pysgpp_swig.SizeList_push_front(self, x)

    def reverse(self) -> "void":
        return _pysgpp_swig.SizeList_reverse(self)
    __swig_destroy__ = _pysgpp_swig.delete_SizeList

# Register SizeList in _pysgpp_swig:
_pysgpp_swig.SizeList_swigregister(SizeList)

class refinement_key(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pysgpp_swig.refinement_key_swiginit(self, _pysgpp_swig.new_refinement_key(*args))
    first = property(_pysgpp_swig.refinement_key_first_get, _pysgpp_swig.refinement_key_first_set)
    second = property(_pysgpp_swig.refinement_key_second_get, _pysgpp_swig.refinement_key_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pysgpp_swig.delete_refinement_key

# Register refinement_key in _pysgpp_swig:
_pysgpp_swig.refinement_key_swigregister(refinement_key)

class refinement_map(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.refinement_map_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.refinement_map___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.refinement_map___bool__(self)

    def __len__(self) -> "std::map< std::pair< size_t,unsigned int >,double >::size_type":
        return _pysgpp_swig.refinement_map___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "refinement_key") -> "std::map< std::pair< size_t,unsigned int >,double >::mapped_type const &":
        return _pysgpp_swig.refinement_map___getitem__(self, key)

    def __delitem__(self, key: "refinement_key") -> "void":
        return _pysgpp_swig.refinement_map___delitem__(self, key)

    def has_key(self, key: "refinement_key") -> "bool":
        return _pysgpp_swig.refinement_map_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _pysgpp_swig.refinement_map_keys(self)

    def values(self) -> "PyObject *":
        return _pysgpp_swig.refinement_map_values(self)

    def items(self) -> "PyObject *":
        return _pysgpp_swig.refinement_map_items(self)

    def __contains__(self, key: "refinement_key") -> "bool":
        return _pysgpp_swig.refinement_map___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.refinement_map_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.refinement_map_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.refinement_map___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _pysgpp_swig.refinement_map_asdict(self)

    def __init__(self, *args):
        _pysgpp_swig.refinement_map_swiginit(self, _pysgpp_swig.new_refinement_map(*args))

    def empty(self) -> "bool":
        return _pysgpp_swig.refinement_map_empty(self)

    def size(self) -> "std::map< std::pair< size_t,unsigned int >,double >::size_type":
        return _pysgpp_swig.refinement_map_size(self)

    def swap(self, v: "refinement_map") -> "void":
        return _pysgpp_swig.refinement_map_swap(self, v)

    def begin(self) -> "std::map< std::pair< size_t,unsigned int >,double >::iterator":
        return _pysgpp_swig.refinement_map_begin(self)

    def end(self) -> "std::map< std::pair< size_t,unsigned int >,double >::iterator":
        return _pysgpp_swig.refinement_map_end(self)

    def rbegin(self) -> "std::map< std::pair< size_t,unsigned int >,double >::reverse_iterator":
        return _pysgpp_swig.refinement_map_rbegin(self)

    def rend(self) -> "std::map< std::pair< size_t,unsigned int >,double >::reverse_iterator":
        return _pysgpp_swig.refinement_map_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.refinement_map_clear(self)

    def get_allocator(self) -> "std::map< std::pair< size_t,unsigned int >,double >::allocator_type":
        return _pysgpp_swig.refinement_map_get_allocator(self)

    def count(self, x: "refinement_key") -> "std::map< std::pair< size_t,unsigned int >,double >::size_type":
        return _pysgpp_swig.refinement_map_count(self, x)

    def erase(self, *args) -> "void":
        return _pysgpp_swig.refinement_map_erase(self, *args)

    def find(self, x: "refinement_key") -> "std::map< std::pair< size_t,unsigned int >,double >::iterator":
        return _pysgpp_swig.refinement_map_find(self, x)

    def lower_bound(self, x: "refinement_key") -> "std::map< std::pair< size_t,unsigned int >,double >::iterator":
        return _pysgpp_swig.refinement_map_lower_bound(self, x)

    def upper_bound(self, x: "refinement_key") -> "std::map< std::pair< size_t,unsigned int >,double >::iterator":
        return _pysgpp_swig.refinement_map_upper_bound(self, x)
    __swig_destroy__ = _pysgpp_swig.delete_refinement_map

# Register refinement_map in _pysgpp_swig:
_pysgpp_swig.refinement_map_swigregister(refinement_map)

class SizeVectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.SizeVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.SizeVectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.SizeVectorVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< size_t > >::size_type":
        return _pysgpp_swig.SizeVectorVector___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< size_t > >::difference_type", j: "std::vector< std::vector< size_t > >::difference_type") -> "std::vector< std::vector< size_t,std::allocator< size_t > >,std::allocator< std::vector< size_t,std::allocator< size_t > > > > *":
        return _pysgpp_swig.SizeVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.SizeVectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< size_t > >::difference_type", j: "std::vector< std::vector< size_t > >::difference_type") -> "void":
        return _pysgpp_swig.SizeVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.SizeVectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< size_t > >::value_type const &":
        return _pysgpp_swig.SizeVectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.SizeVectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< size_t > >::value_type":
        return _pysgpp_swig.SizeVectorVector_pop(self)

    def append(self, x: "SizeVector") -> "void":
        return _pysgpp_swig.SizeVectorVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.SizeVectorVector_empty(self)

    def size(self) -> "std::vector< std::vector< size_t > >::size_type":
        return _pysgpp_swig.SizeVectorVector_size(self)

    def swap(self, v: "SizeVectorVector") -> "void":
        return _pysgpp_swig.SizeVectorVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< size_t > >::iterator":
        return _pysgpp_swig.SizeVectorVector_begin(self)

    def end(self) -> "std::vector< std::vector< size_t > >::iterator":
        return _pysgpp_swig.SizeVectorVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< size_t > >::reverse_iterator":
        return _pysgpp_swig.SizeVectorVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< size_t > >::reverse_iterator":
        return _pysgpp_swig.SizeVectorVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.SizeVectorVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< size_t > >::allocator_type":
        return _pysgpp_swig.SizeVectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.SizeVectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< size_t > >::iterator":
        return _pysgpp_swig.SizeVectorVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.SizeVectorVector_swiginit(self, _pysgpp_swig.new_SizeVectorVector(*args))

    def push_back(self, x: "SizeVector") -> "void":
        return _pysgpp_swig.SizeVectorVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< size_t > >::value_type const &":
        return _pysgpp_swig.SizeVectorVector_front(self)

    def back(self) -> "std::vector< std::vector< size_t > >::value_type const &":
        return _pysgpp_swig.SizeVectorVector_back(self)

    def assign(self, n: "std::vector< std::vector< size_t > >::size_type", x: "SizeVector") -> "void":
        return _pysgpp_swig.SizeVectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.SizeVectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.SizeVectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< size_t > >::size_type") -> "void":
        return _pysgpp_swig.SizeVectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< size_t > >::size_type":
        return _pysgpp_swig.SizeVectorVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_SizeVectorVector

# Register SizeVectorVector in _pysgpp_swig:
_pysgpp_swig.SizeVectorVector_swigregister(SizeVectorVector)

class DataVectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.DataVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.DataVectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.DataVectorVector___bool__(self)

    def __len__(self) -> "std::vector< sgpp::base::DataVector >::size_type":
        return _pysgpp_swig.DataVectorVector___len__(self)

    def __getslice__(self, i: "std::vector< sgpp::base::DataVector >::difference_type", j: "std::vector< sgpp::base::DataVector >::difference_type") -> "std::vector< sgpp::base::DataVector,std::allocator< sgpp::base::DataVector > > *":
        return _pysgpp_swig.DataVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.DataVectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< sgpp::base::DataVector >::difference_type", j: "std::vector< sgpp::base::DataVector >::difference_type") -> "void":
        return _pysgpp_swig.DataVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.DataVectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< sgpp::base::DataVector >::value_type const &":
        return _pysgpp_swig.DataVectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.DataVectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< sgpp::base::DataVector >::value_type":
        return _pysgpp_swig.DataVectorVector_pop(self)

    def append(self, x: "DataVector") -> "void":
        return _pysgpp_swig.DataVectorVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.DataVectorVector_empty(self)

    def size(self) -> "std::vector< sgpp::base::DataVector >::size_type":
        return _pysgpp_swig.DataVectorVector_size(self)

    def swap(self, v: "DataVectorVector") -> "void":
        return _pysgpp_swig.DataVectorVector_swap(self, v)

    def begin(self) -> "std::vector< sgpp::base::DataVector >::iterator":
        return _pysgpp_swig.DataVectorVector_begin(self)

    def end(self) -> "std::vector< sgpp::base::DataVector >::iterator":
        return _pysgpp_swig.DataVectorVector_end(self)

    def rbegin(self) -> "std::vector< sgpp::base::DataVector >::reverse_iterator":
        return _pysgpp_swig.DataVectorVector_rbegin(self)

    def rend(self) -> "std::vector< sgpp::base::DataVector >::reverse_iterator":
        return _pysgpp_swig.DataVectorVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.DataVectorVector_clear(self)

    def get_allocator(self) -> "std::vector< sgpp::base::DataVector >::allocator_type":
        return _pysgpp_swig.DataVectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.DataVectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< sgpp::base::DataVector >::iterator":
        return _pysgpp_swig.DataVectorVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.DataVectorVector_swiginit(self, _pysgpp_swig.new_DataVectorVector(*args))

    def push_back(self, x: "DataVector") -> "void":
        return _pysgpp_swig.DataVectorVector_push_back(self, x)

    def front(self) -> "std::vector< sgpp::base::DataVector >::value_type const &":
        return _pysgpp_swig.DataVectorVector_front(self)

    def back(self) -> "std::vector< sgpp::base::DataVector >::value_type const &":
        return _pysgpp_swig.DataVectorVector_back(self)

    def assign(self, n: "std::vector< sgpp::base::DataVector >::size_type", x: "DataVector") -> "void":
        return _pysgpp_swig.DataVectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.DataVectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.DataVectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< sgpp::base::DataVector >::size_type") -> "void":
        return _pysgpp_swig.DataVectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< sgpp::base::DataVector >::size_type":
        return _pysgpp_swig.DataVectorVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_DataVectorVector

# Register DataVectorVector in _pysgpp_swig:
_pysgpp_swig.DataVectorVector_swigregister(DataVectorVector)

class DataMatrixVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.DataMatrixVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.DataMatrixVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.DataMatrixVector___bool__(self)

    def __len__(self) -> "std::vector< sgpp::base::DataMatrix >::size_type":
        return _pysgpp_swig.DataMatrixVector___len__(self)

    def __getslice__(self, i: "std::vector< sgpp::base::DataMatrix >::difference_type", j: "std::vector< sgpp::base::DataMatrix >::difference_type") -> "std::vector< sgpp::base::DataMatrix,std::allocator< sgpp::base::DataMatrix > > *":
        return _pysgpp_swig.DataMatrixVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.DataMatrixVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< sgpp::base::DataMatrix >::difference_type", j: "std::vector< sgpp::base::DataMatrix >::difference_type") -> "void":
        return _pysgpp_swig.DataMatrixVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.DataMatrixVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< sgpp::base::DataMatrix >::value_type const &":
        return _pysgpp_swig.DataMatrixVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.DataMatrixVector___setitem__(self, *args)

    def pop(self) -> "std::vector< sgpp::base::DataMatrix >::value_type":
        return _pysgpp_swig.DataMatrixVector_pop(self)

    def append(self, x: "DataMatrix") -> "void":
        return _pysgpp_swig.DataMatrixVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.DataMatrixVector_empty(self)

    def size(self) -> "std::vector< sgpp::base::DataMatrix >::size_type":
        return _pysgpp_swig.DataMatrixVector_size(self)

    def swap(self, v: "DataMatrixVector") -> "void":
        return _pysgpp_swig.DataMatrixVector_swap(self, v)

    def begin(self) -> "std::vector< sgpp::base::DataMatrix >::iterator":
        return _pysgpp_swig.DataMatrixVector_begin(self)

    def end(self) -> "std::vector< sgpp::base::DataMatrix >::iterator":
        return _pysgpp_swig.DataMatrixVector_end(self)

    def rbegin(self) -> "std::vector< sgpp::base::DataMatrix >::reverse_iterator":
        return _pysgpp_swig.DataMatrixVector_rbegin(self)

    def rend(self) -> "std::vector< sgpp::base::DataMatrix >::reverse_iterator":
        return _pysgpp_swig.DataMatrixVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.DataMatrixVector_clear(self)

    def get_allocator(self) -> "std::vector< sgpp::base::DataMatrix >::allocator_type":
        return _pysgpp_swig.DataMatrixVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.DataMatrixVector_pop_back(self)

    def erase(self, *args) -> "std::vector< sgpp::base::DataMatrix >::iterator":
        return _pysgpp_swig.DataMatrixVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.DataMatrixVector_swiginit(self, _pysgpp_swig.new_DataMatrixVector(*args))

    def push_back(self, x: "DataMatrix") -> "void":
        return _pysgpp_swig.DataMatrixVector_push_back(self, x)

    def front(self) -> "std::vector< sgpp::base::DataMatrix >::value_type const &":
        return _pysgpp_swig.DataMatrixVector_front(self)

    def back(self) -> "std::vector< sgpp::base::DataMatrix >::value_type const &":
        return _pysgpp_swig.DataMatrixVector_back(self)

    def assign(self, n: "std::vector< sgpp::base::DataMatrix >::size_type", x: "DataMatrix") -> "void":
        return _pysgpp_swig.DataMatrixVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.DataMatrixVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.DataMatrixVector_insert(self, *args)

    def reserve(self, n: "std::vector< sgpp::base::DataMatrix >::size_type") -> "void":
        return _pysgpp_swig.DataMatrixVector_reserve(self, n)

    def capacity(self) -> "std::vector< sgpp::base::DataMatrix >::size_type":
        return _pysgpp_swig.DataMatrixVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_DataMatrixVector

# Register DataMatrixVector in _pysgpp_swig:
_pysgpp_swig.DataMatrixVector_swigregister(DataMatrixVector)

class SBasis(object):
    r"""


    Basis class for basis functions.  

    C++ includes: Basis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def eval(self, level: "unsigned int", index: "unsigned int", x: "double") -> "double":
        r"""


        Evaluate the basis function with given level and index.  

        Parameters
        ----------
        * `level` :  
            level of the basis function  
        * `index` :  
            index of the basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of the basis function.  

        """
        return _pysgpp_swig.SBasis_eval(self, level, index, x)

    def getDegree(self) -> "size_t":
        r"""


        Returns the polynomial degree of the basis.  

        Returns
        -------
        polynomial degree of the basis  

        """
        return _pysgpp_swig.SBasis_getDegree(self)

    def getIntegral(self, level: "unsigned int", index: "unsigned int") -> "double":
        r"""


        returns the integal of the current basis function  

        Parameters
        ----------
        * `level` :  
            level of the basis function  
        * `index` :  
            index of the basis function  

        Returns
        -------  

        """
        return _pysgpp_swig.SBasis_getIntegral(self, level, index)
    __swig_destroy__ = _pysgpp_swig.delete_SBasis

# Register SBasis in _pysgpp_swig:
_pysgpp_swig.SBasis_swigregister(SBasis)


def free_array(ptr: "PyObject *") -> "void":
    return _pysgpp_swig.free_array(ptr)
class DataVector(object):
    r"""

    `DataVector()`  
    `DataVector(arg1)`  
    `DataVector(arg1)`  
    `DataVector(input, size)`  
    `DataVector(size)`  
    `DataVector(size, value)`  
    `DataVector(input)`  
    `DataVector(input)`  
    `DataVector(input)`  

    A class to store one-dimensional data.  

    Typically, an object of type DataVector will contain an array of (hierarchical)
    coefficients (or surplusses), or the coordinates of a data point at which a
    sparse grid function should be evaluated.  

    Constructors
    ------------
    * `DataVector()`  

        Create an empty DataVector.  

    * `DataVector(arg1)`  

        Copy constructor.  

    * `DataVector(arg1)`  

        Move constructor.  

    * `DataVector(input, size)`  

        Create a new DataVector from a double array with size elements.  

        Parameters:  
        * `input` :  
            double array that contains the data  
        * `size` :  
            number of elements  

    * `DataVector(size)`  

        Create a DataVector with *size* elements (uninitialized values).  

        Parameters:  
        * `size` :  
            Number of elements  

    * `DataVector(size, value)`  

        Create a DataVector with *size* elements and initializes all elements with
        the same value.  

        Parameters:  
        * `size` :  
            Number of elements  
        * `value` :  
            Value for all entries  

    * `DataVector(input)`  

        Create a new DataVector from a std::initializer_list<double>.  

        Parameters:  
        * `input` :  
            std::initializer_list<double> that contains the data  

    * `DataVector(input)`  

        Create a new DataVector from a std::vector<double>.  

        Parameters:  
        * `input` :  
            std::vector<double> that contains the data  

    * `DataVector(input)`  

        Create a new DataVector from a std::vector<int>.  

        Parameters:  
        * `input` :  
            std::vector<int> that contains the data  

    C++ includes: DataVector.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DataVector()`  

            Create an empty DataVector.  

        * `DataVector(arg1)`  

            Copy constructor.  

        * `DataVector(arg1)`  

            Move constructor.  

        * `DataVector(input, size)`  

            Create a new DataVector from a double array with size elements.  

            Parameters:  
            * `input` :  
                double array that contains the data  
            * `size` :  
                number of elements  

        * `DataVector(size)`  

            Create a DataVector with *size* elements (uninitialized values).  

            Parameters:  
            * `size` :  
                Number of elements  

        * `DataVector(size, value)`  

            Create a DataVector with *size* elements and initializes all elements with
            the same value.  

            Parameters:  
            * `size` :  
                Number of elements  
            * `value` :  
                Value for all entries  

        * `DataVector(input)`  

            Create a new DataVector from a std::initializer_list<double>.  

            Parameters:  
            * `input` :  
                std::initializer_list<double> that contains the data  

        * `DataVector(input)`  

            Create a new DataVector from a std::vector<double>.  

            Parameters:  
            * `input` :  
                std::vector<double> that contains the data  

        * `DataVector(input)`  

            Create a new DataVector from a std::vector<int>.  

            Parameters:  
            * `input` :  
                std::vector<int> that contains the data  

        """
        _pysgpp_swig.DataVector_swiginit(self, _pysgpp_swig.new_DataVector(*args))

    def resize(self, size: "size_t") -> "void":
        return _pysgpp_swig.DataVector_resize(self, size)

    def resizeZero(self, size: "size_t") -> "void":
        r"""


        Resizes the DataVector to size elements.  

        All new additional entries are set to zero. If nrows is smaller than the current
        number of rows, all superfluous entries are removed.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows of the DataVector  

        """
        return _pysgpp_swig.DataVector_resizeZero(self, size)

    def append(self, *args) -> "size_t":
        r"""


        Overloaded function
        -------------------
        * `append() -> size_t`  

            Appends a new element and returns index of it.  

            Returns:
            Index of new element  

        * `append(value) -> size_t`  

            Appends a new element and returns index of new element.  

            Parameters:  
            * `value` :  
                Value of new element  

            Returns:
            Index of new element  

        """
        return _pysgpp_swig.DataVector_append(self, *args)

    def restructure(self, arg2: "SizeVector") -> "void":
        r"""


        Resizes the DataVector by removing entries.  

        Throws an exception if boundaries a violated.  

        Parameters
        ----------
        * `remainingIndex` :  
            vector that contains the remaining indices of the DataVector  

        """
        return _pysgpp_swig.DataVector_restructure(self, arg2)

    def setAll(self, value: "double") -> "void":
        r"""


        Sets all values of DataVector to value.  

        Parameters
        ----------
        * `value` :  
            New value for all entries  

        """
        return _pysgpp_swig.DataVector_setAll(self, value)

    def copyFrom(self, vec: "DataVector") -> "void":
        r"""


        Copies the data from another DataVector vec.  

        Disregards the number of entries set for the two vectors, i.e., just copies the
        data entry by entry. If the size matches, the current DataVector is an exact
        copy of vec. If not, as many elements as possible are copied, and everything
        else is left untouched.  

        Parameters
        ----------
        * `vec` :  
            The source DataVector containing the data  

        """
        return _pysgpp_swig.DataVector_copyFrom(self, vec)

    def assign(self, vec: "DataVector") -> "sgpp::base::DataVector &":
        return _pysgpp_swig.DataVector_assign(self, vec)

    def get(self, i: "size_t") -> "double":
        r"""


        Returns the i-th element.  

        Parameters
        ----------
        * `i` :  
            position of the element  

        Returns
        -------
        data[i]  

        """
        return _pysgpp_swig.DataVector_get(self, i)

    def set(self, i: "size_t", value: "double") -> "void":
        r"""


        Sets the element at index i to value.  

        Parameters
        ----------
        * `i` :  
            Index  
        * `value` :  
            New value for element  

        """
        return _pysgpp_swig.DataVector_set(self, i, value)

    def add(self, vec: "DataVector") -> "void":
        r"""


        Adds the values from another DataVector to the current values.  

        Modifies the current values.  

        Parameters
        ----------
        * `vec` :  
            The DataVector which is added to the current values  

        """
        return _pysgpp_swig.DataVector_add(self, vec)

    def sub(self, vec: "DataVector") -> "void":
        r"""


        Subtracts the values from another DataVector of the current values.  

        Modifies the current values.  

        Parameters
        ----------
        * `vec` :  
            The DataVector which is subtracted from the current values  

        """
        return _pysgpp_swig.DataVector_sub(self, vec)

    def componentwise_mult(self, vec: "DataVector") -> "void":
        r"""


        Multiplies the current DataVector component-wise with another DataVector.  

        Modifies the current values. Performs  

        Parameters
        ----------
        * `vec` :  
            the DataVector which is multiplied to current DataVector  

        """
        return _pysgpp_swig.DataVector_componentwise_mult(self, vec)

    def componentwise_div(self, vec: "DataVector") -> "void":
        r"""


        Divides the current DataVector component-wise by another DataVector.  

        Modifies the current values. Performs  Note: **No check for division by zero!**  

        Parameters
        ----------
        * `vec` :  
            the DataVector which the current DataVector is divided by  

        """
        return _pysgpp_swig.DataVector_componentwise_div(self, vec)

    def mult(self, scalar: "double") -> "void":
        r"""


        multiplies all elements by a constant factor  

        Parameters
        ----------
        * `scalar` :  
            the constant  

        """
        return _pysgpp_swig.DataVector_mult(self, scalar)

    def sqr(self) -> "void":
        r"""


        Squares all elements of the DataVector.  

        """
        return _pysgpp_swig.DataVector_sqr(self)

    def sqrt(self) -> "void":
        r"""


        Takes the square root of all elements of the DataVector.  

        """
        return _pysgpp_swig.DataVector_sqrt(self)

    def abs(self) -> "void":
        r"""


        Sets all elements to their absolute value.  

        """
        return _pysgpp_swig.DataVector_abs(self)

    def sum(self) -> "double":
        r"""


        Returns the sum of all elements.  

        Returns
        -------
        The sum of all elements  

        """
        return _pysgpp_swig.DataVector_sum(self)

    def min(self) -> "double":
        r"""


        Returns the minimum over all entries.  

        Returns
        -------
        Minimal value  

        """
        return _pysgpp_swig.DataVector_min(self)

    def max(self) -> "double":
        r"""


        Returns the maximum over all entries.  

        Returns
        -------
        global maximum  

        """
        return _pysgpp_swig.DataVector_max(self)

    def minmax(self) -> "void":
        r"""


        Determines minimum and maximum over all entries.  

        Parameters
        ----------
        * `min` :  
            Reference variable for the minimum  
        * `max` :  
            Reference variable for the maximum  

        """
        return _pysgpp_swig.DataVector_minmax(self)

    def maxNorm(self) -> "double":
        r"""


        calculates the vector's max norm  

        Returns
        -------
        the vector's max norm  

        """
        return _pysgpp_swig.DataVector_maxNorm(self)

    def RMSNorm(self) -> "double":
        r"""


        Returns the vector's root mean square (RMS)-norm, i.e., $\sqrt{ 1/N
        \sum_{i=1}^N x_i^2 }$.  

        If the vector's entries correspond to function values on a full grid, this is
        the discrete $L^2$-norm of the corresponding function.  

        Returns
        -------
        The vector's root mean square-norm.  

        """
        return _pysgpp_swig.DataVector_RMSNorm(self)

    def l2Norm(self) -> "double":
        r"""


        Returns the vector's $l^2$-norm, i.e., $\sqrt{ \sum_i x_i^2 }$.  

        Returns
        -------
        The vector's $l^2$-norm.  

        """
        return _pysgpp_swig.DataVector_l2Norm(self)

    def dotProduct(self, vec: "DataVector") -> "double":
        r"""


        Returns the dot product of the two vectors.  

        Parameters
        ----------
        * `vec` :  
            Reference to another vector  

        Returns
        -------
        The dot-product  

        """
        return _pysgpp_swig.DataVector_dotProduct(self, vec)

    def axpy(self, alpha: "double", x: "DataVector") -> "void":
        r"""


        Adds a*x to current vector.  

        BLAS Level 1 (elementary vector operations) operation: axpy.  

        Parameters
        ----------
        * `a` :  
            A scalar  
        * `x` :  
            Reference to the DataVector  

        """
        return _pysgpp_swig.DataVector_axpy(self, alpha, x)

    def getSize(self) -> "size_t":
        r"""


        gets the elements stored in the vector  

        Deprecated
        in favour of the equivalent size() method  

        Returns
        -------
        elements stored in the vector  

        """
        return _pysgpp_swig.DataVector_getSize(self)

    def getNumberNonZero(self) -> "size_t":
        r"""


        Determines the number of non-zero elements in the vector.  

        Returns
        -------
        The number of non-zero elements  

        """
        return _pysgpp_swig.DataVector_getNumberNonZero(self)

    def partitionClasses(self, border: "double") -> "void":
        r"""


        Partitions vector into two classes using a choosen border.  

        Parameters
        ----------
        * `threshold` :  
            value of the border  

        """
        return _pysgpp_swig.DataVector_partitionClasses(self, border)

    def normalize(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `normalize()`  

            Normalizes vector entries to [0,1].  

        * `normalize(border)`  

            Normalizes vector entries to [border, 1-border].  

            Parameters:  
            * `border` :  
                width of border  

        """
        return _pysgpp_swig.DataVector_normalize(self, *args)

    def toString(self) -> "std::string":
        r"""


        Overloaded function
        -------------------
        * `toString() -> std::string`  

            Returns a description of the DataVector as a string.  

            Returns:
            string of the DataVector  

        * `toString(text)`  

            Writes the data stored in the DataVector into a string.  

            Parameters:  
            * `text` :  
                string to which the data is written  

        """
        return _pysgpp_swig.DataVector_toString(self)

    def toFile(self, fileName: "std::string const &") -> "void":
        r"""


        """
        return _pysgpp_swig.DataVector_toFile(self, fileName)

    @staticmethod
    def fromFile(fileName: "std::string const &") -> "sgpp::base::DataVector":
        r"""


        """
        return _pysgpp_swig.DataVector_fromFile(fileName)

    def __array(self, datavector: "PyObject *") -> "PyObject *":
        return _pysgpp_swig.DataVector___array(self, datavector)

    def array(self):   
      return self.__array(self)

    def __len__(self):
        return self.getSize()

    def __getitem__(self, i):
        return self.get(i)

    def __setitem__(self, i, value):
        self.set(i, value)

    def __str__(self):
        return self.toString()

    __swig_destroy__ = _pysgpp_swig.delete_DataVector

# Register DataVector in _pysgpp_swig:
_pysgpp_swig.DataVector_swigregister(DataVector)

def DataVector_fromFile(fileName: "std::string const &") -> "sgpp::base::DataVector":
    r"""


    """
    return _pysgpp_swig.DataVector_fromFile(fileName)

class DataMatrix(object):
    r"""

    `DataMatrix()`  
    `DataMatrix(arg1)`  
    `DataMatrix(input, nrows, ncols)`  
    `DataMatrix(arg1)`  
    `DataMatrix(nrows, ncols)`  
    `DataMatrix(nrows, ncols, value)`  
    `DataMatrix(input, nrows)`  
    `DataMatrix(input, nrows)`  

    A class to store two-dimensional data.  

    Typically, DataMatrix would contain a set of (d-dimensional) data or evaluation
    points, i.e., the DataMatrix consists of d columns, and each row is one of the
    points. Thus, typical functionality like obtaining the maximum for a certain
    dimension (or attribute), or normalizing all data points to the unit interval
    for a certain dimension are provided.  

    Constructors
    ------------
    * `DataMatrix()`  

        Creates an empty two-dimensional DataMatrix.  

    * `DataMatrix(arg1)`  

        Copy constructor.  

    * `DataMatrix(input, nrows, ncols)`  

        Create a new DataMatrix from a double array.  

        The double array contains the entries row-wise: x0_0,x0_1,...,x0_ncol-1,
        x1_0,x1_1,... ... xnrow_0, xnrow_1,...,xnrow_ncol-1  

        Parameters:  
        * `input` :  
            double array that contains the data  
        * `nrows` :  
            number of rows  
        * `ncols` :  
            number of columns  

    * `DataMatrix(arg1)`  

        Move constructor.  

    * `DataMatrix(nrows, ncols)`  

        Create a two-dimensional DataMatrix with *nrows* rows and *ncols* columns
        (uninitialized values).  

        Parameters:  
        * `nrows` :  
            Number of rows  
        * `ncols` :  
            Number of columns  

    * `DataMatrix(nrows, ncols, value)`  

        Create a two-dimensional DataMatrix with *nrows* rows and *ncols* columns
        and initializes all elements with the same value.  

        Parameters:  
        * `nrows` :  
            Number of rows  
        * `ncols` :  
            Number of columns  
        * `value` :  
            Value for all entries  

    * `DataMatrix(input, nrows)`  

        Create a new DataMatrix from a std::initializer_list<double>.  

        Parameters:  
        * `input` :  
            std::initializer_list<double> that contains the data  
        * `nrows` :  
            number of rows  

    * `DataMatrix(input, nrows)`  

        Create a new DataMatrix from a std::vector<double>.  

        Parameters:  
        * `input` :  
            std::vector<double> that contains the data  
        * `nrows` :  
            number of rows  

    C++ includes: DataMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DataMatrix()`  

            Creates an empty two-dimensional DataMatrix.  

        * `DataMatrix(arg1)`  

            Copy constructor.  

        * `DataMatrix(input, nrows, ncols)`  

            Create a new DataMatrix from a double array.  

            The double array contains the entries row-wise: x0_0,x0_1,...,x0_ncol-1,
            x1_0,x1_1,... ... xnrow_0, xnrow_1,...,xnrow_ncol-1  

            Parameters:  
            * `input` :  
                double array that contains the data  
            * `nrows` :  
                number of rows  
            * `ncols` :  
                number of columns  

        * `DataMatrix(arg1)`  

            Move constructor.  

        * `DataMatrix(nrows, ncols)`  

            Create a two-dimensional DataMatrix with *nrows* rows and *ncols* columns
            (uninitialized values).  

            Parameters:  
            * `nrows` :  
                Number of rows  
            * `ncols` :  
                Number of columns  

        * `DataMatrix(nrows, ncols, value)`  

            Create a two-dimensional DataMatrix with *nrows* rows and *ncols* columns
            and initializes all elements with the same value.  

            Parameters:  
            * `nrows` :  
                Number of rows  
            * `ncols` :  
                Number of columns  
            * `value` :  
                Value for all entries  

        * `DataMatrix(input, nrows)`  

            Create a new DataMatrix from a std::initializer_list<double>.  

            Parameters:  
            * `input` :  
                std::initializer_list<double> that contains the data  
            * `nrows` :  
                number of rows  

        * `DataMatrix(input, nrows)`  

            Create a new DataMatrix from a std::vector<double>.  

            Parameters:  
            * `input` :  
                std::vector<double> that contains the data  
            * `nrows` :  
                number of rows  

        """
        _pysgpp_swig.DataMatrix_swiginit(self, _pysgpp_swig.new_DataMatrix(*args))

    def resizeRows(self, nrows: "size_t") -> "void":
        r"""


        Resizes the DataMatrix to nrows rows.  

        All new additional entries are uninitialized. If nrows is smaller than the
        current number of rows, all superfluous entries are removed.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows of the DataMatrix  

        """
        return _pysgpp_swig.DataMatrix_resizeRows(self, nrows)

    def resizeRowsCols(self, nrows: "size_t", ncols: "size_t") -> "void":
        r"""


        Resizes the DataMatrix to nrows rows and ncols columns.  

        All new additional entries are uninitialized. If nrows*ncols is smaller than the
        current number of entries, all superfluous entries are removed.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows of the DataMatrix  
        * `ncols` :  
            New number of columns of the DataMatrix  

        """
        return _pysgpp_swig.DataMatrix_resizeRowsCols(self, nrows, ncols)

    def resizeQuadratic(self, size: "size_t") -> "void":
        r"""


        Resizes the quadratic DataMatrix to size rows and size columns.  

        All new additional entries are uninitialized. If size is smaller than the
        current size of the quadratic DataMatrix, all superfluous entries are removed.  

        Parameters
        ----------
        * `size` :  
            New dimension of quadratic data DataMatrix  

        """
        return _pysgpp_swig.DataMatrix_resizeQuadratic(self, size)

    def resizeZero(self, nrows: "size_t", ncols: "size_t") -> "void":
        r"""


        Overloaded function
        -------------------
        * `resizeZero(nrows)`  

            Resizes the DataMatrix to nrows rows.  

            All new additional entries are set to zero. If nrows is smaller than the
            current number of rows, all superfluous entries are removed. Deprecated
            use resizeRows  

            Parameters:  
            * `nrows` :  
                New number of rows of the DataMatrix  

        * `resizeZero(nrows, ncols)`  

            Resizes the DataMatrix to nrows rows and ncols columns.  

            All new additional entries are set to zero. If nrows*ncols is smaller than
            the current number of entries, all superfluous entries are removed.
            Deprecated
            use resizeRowsCols  

            Parameters:  
            * `nrows` :  
                New number of rows of the DataMatrix  
            * `ncols` :  
                New number of columns of the DataMatrix  

        """
        return _pysgpp_swig.DataMatrix_resizeZero(self, nrows, ncols)

    def resizeToSubMatrix(self, row_1: "size_t", col_1: "size_t", row_2: "size_t", col_2: "size_t") -> "void":
        r"""


        Resize current matrix to the submatrix Mat[row_1:row_2, col_1:col_2].  

        Parameters
        ----------
        * `row_1`, `col_1` :  
            corresponding to left upper index of desired submatrix  
        * `row_2`, `col_2` :  
            corresponding to right lower index of desired submatrix  

        """
        return _pysgpp_swig.DataMatrix_resizeToSubMatrix(self, row_1, col_1, row_2, col_2)

    def reserveAdditionalRows(self, inc_nrows: "size_t") -> "void":
        r"""


        Reserves memory for potentially inc_nrows new rows; the actual number of rows
        remains unchanged.  

        Corresponds to a resize to nrows+inc_nrows new rows while leaving the current
        matrix' size unchanged.  

        Parameters
        ----------
        * `inc_nrows` :  
            Number of additional rows for which storage is to be reserved.  

        """
        return _pysgpp_swig.DataMatrix_reserveAdditionalRows(self, inc_nrows)

    def appendRow(self, *args) -> "size_t":
        r"""


        Overloaded function
        -------------------
        * `appendRow() -> size_t`  

            Appends a new row and returns index of it.  

            Returns:
            Index of new row  

        * `appendRow(vec) -> size_t`  

            Appends a new row with data contained in DataVector vec and returns index of
            new row.  

            Parameters:  
            * `vec` :  
                DataVector (length has to match getNcols()) with data  

            Returns:
            Index of new row  

        """
        return _pysgpp_swig.DataMatrix_appendRow(self, *args)

    def appendCol(self, vec: "DataVector") -> "size_t":
        r"""


        Appends a new Col with data contained in DataVector vec and returns index of new
        col.  

        Parameters
        ----------
        * `vec` :  
            DataVector (length has to match getNcols()) with data  

        Returns
        -------
        Index of new col  

        """
        return _pysgpp_swig.DataMatrix_appendCol(self, vec)

    def setAll(self, value: "double") -> "void":
        r"""


        Sets all entries of DataMatrix to value.  

        Parameters
        ----------
        * `value` :  
            New value for all entries  

        """
        return _pysgpp_swig.DataMatrix_setAll(self, value)

    def copyFrom(self, matr: "DataMatrix") -> "void":
        r"""


        Copies the data from another DataMatrix matr.  

        Disregards the number of rows and columns set for the two matrices, i.e., just
        copies the data entry by entry (and row by row). If the dimensions match (nrows,
        ncols), the current DataMatrix is an exact copy of matr. If not, as many
        elements as possible are copied, and everything else is left untouched.  

        Parameters
        ----------
        * `matr` :  
            The source DataMatrix containing the data  

        """
        return _pysgpp_swig.DataMatrix_copyFrom(self, matr)

    def transpose(self) -> "void":
        r"""


        Transposes this DataMatrix.  

        """
        return _pysgpp_swig.DataMatrix_transpose(self)

    def get(self, row: "size_t", col: "size_t") -> "double":
        r"""


        Returns the value of the element at position [row,col].  

        Parameters
        ----------
        * `row` :  
            Row  
        * `col` :  
            Column  

        Returns
        -------
        Value of the element  

        """
        return _pysgpp_swig.DataMatrix_get(self, row, col)

    def set(self, row: "size_t", col: "size_t", value: "double") -> "void":
        r"""


        Sets the element at position [row,col] to value.  

        Parameters
        ----------
        * `row` :  
            Row  
        * `col` :  
            Column  
        * `value` :  
            New value for element  

        """
        return _pysgpp_swig.DataMatrix_set(self, row, col, value)

    def getRow(self, row: "size_t", vec: "DataVector") -> "void":
        r"""


        Overloaded function
        -------------------
        * `getRow(row, vec)`  

            Copies the values of a row to the DataVector vec.  

            Parameters:  
            * `row` :  
                The row  
            * `vec` :  
                DataVector into which the data is written  

        * `getRow(row, vec)`  

            Copies the values of a row to the std::vector vec.  

            Parameters:  
            * `row` :  
                The row  
            * `vec` :  
                std::vector into which the data is written  

        """
        return _pysgpp_swig.DataMatrix_getRow(self, row, vec)

    def setRow(self, row: "size_t", vec: "DataVector") -> "void":
        r"""


        Sets a row of the DataMatrix to the values of a DataVector vec.  

        Parameters
        ----------
        * `row` :  
            The row which is to be overwritten  
        * `vec` :  
            DataVector containing the data of the row  

        """
        return _pysgpp_swig.DataMatrix_setRow(self, row, vec)

    def getColumn(self, col: "size_t", vec: "DataVector") -> "void":
        r"""


        Copies the values of a column to the DataVector vec.  

        Parameters
        ----------
        * `col` :  
            The column  
        * `vec` :  
            DataVector into which the data is written  

        """
        return _pysgpp_swig.DataMatrix_getColumn(self, col, vec)

    def setColumn(self, col: "size_t", vec: "DataVector") -> "void":
        r"""


        Sets a column of the DataMatrix to the values of a DataVector vec.  

        Parameters
        ----------
        * `col` :  
            The column which is to be overwritten  
        * `vec` :  
            DataVector containing the data of the column  

        """
        return _pysgpp_swig.DataMatrix_setColumn(self, col, vec)

    def getPointer(self) -> "double *":
        r"""


        Overloaded function
        -------------------
        * `getPointer() -> double *`  

            Returns pointer to double array containing underlying data.  

            Returns:
            Pointer to data  

        * `getPointer() -> const double *`  

            Returns const pointer to double array containing underlying data.  

            Returns:
            Const pointer to data  

        """
        return _pysgpp_swig.DataMatrix_getPointer(self)

    def add(self, matr: "DataMatrix") -> "void":
        r"""


        Adds the values from another DataMatrix to the current values.  

        Modifies the current values.  

        Parameters
        ----------
        * `matr` :  
            The DataMatrix which is added to the current values  

        """
        return _pysgpp_swig.DataMatrix_add(self, matr)

    def sub(self, matr: "DataMatrix") -> "void":
        r"""


        Subtracts the values from another DataMatrix of the current values.  

        Modifies the current values.  

        Parameters
        ----------
        * `matr` :  
            The DataMatrix which is subtracted from the current values  

        """
        return _pysgpp_swig.DataMatrix_sub(self, matr)

    def componentwise_mult(self, matr: "DataMatrix") -> "void":
        r"""


        Multiplies the current DataMatrix component-wise with another DataMatrix.  

        Modifies the current values. Performs  

        Parameters
        ----------
        * `matr` :  
            the DataMatrix which is multiplied to current DataMatrix  

        """
        return _pysgpp_swig.DataMatrix_componentwise_mult(self, matr)

    def componentwise_div(self, matr: "DataMatrix") -> "void":
        r"""


        Divides the current DataMatrix component-wise by another DataMatrix.  

        Modifies the current values. Performs  Note: **No check for division by zero!**  

        Parameters
        ----------
        * `matr` :  
            the DataMatrix which the current DataMatrix is divided by  

        """
        return _pysgpp_swig.DataMatrix_componentwise_div(self, matr)

    def mult(self, scalar: "double") -> "void":
        r"""


        Overloaded function
        -------------------
        * `mult(x, y)`  

            Multiplies the matrix with a vector x and stores the result in another
            vector y.  

            Parameters:  
            * `x` :  
                vector to be multiplied  
            * `y` :  
                vector in which the result should be stored  

        * `mult(scalar)`  

            Multiplies all elements by a constant factor.  

            Parameters:  
            * `scalar` :  
                the constant  

        """
        return _pysgpp_swig.DataMatrix_mult(self, scalar)

    def sqr(self) -> "void":
        r"""


        Squares all elements of the DataMatrix.  

        """
        return _pysgpp_swig.DataMatrix_sqr(self)

    def sqrt(self) -> "void":
        r"""


        Takes the square root of all elements of the DataMatrix.  

        """
        return _pysgpp_swig.DataMatrix_sqrt(self)

    def abs(self) -> "void":
        r"""


        Sets all elements to their absolute value.  

        """
        return _pysgpp_swig.DataMatrix_abs(self)

    def sum(self) -> "double":
        r"""


        Returns the sum of all elements.  

        Returns
        -------
        The sum of all elements  

        """
        return _pysgpp_swig.DataMatrix_sum(self)

    def getSize(self) -> "size_t":
        r"""


        Returns the total number of (used) elements, i.e., getNrows()*getNCols()  

        Returns
        -------
        Number of elements stored in the matrix  

        """
        return _pysgpp_swig.DataMatrix_getSize(self)

    def getNumberNonZero(self) -> "size_t":
        r"""


        Determines the number of non-zero elements in the vector.  

        Returns
        -------
        The number of non-zero elements  

        """
        return _pysgpp_swig.DataMatrix_getNumberNonZero(self)

    def getNrows(self) -> "size_t":
        r"""


        Returns the number of rows of the DataMatrix.  

        Returns
        -------
        Number of rows  

        """
        return _pysgpp_swig.DataMatrix_getNrows(self)

    def getNcols(self) -> "size_t":
        r"""


        Returns the number of columns of the DataMatrix.  

        Returns
        -------
        Number of columns  

        """
        return _pysgpp_swig.DataMatrix_getNcols(self)

    def normalizeDimension(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `normalizeDimension(d)`  

            Normalizes the d-th dimension (entries in the d-th column) to $[0,1]$.  

            Considers contents of DataMatrix as a d-dimensional dataset, one data point
            per row.  

            Parameters:  
            * `d` :  
                The dimension (column) that should be normalized (starting with 0)  

        * `normalizeDimension(d, border)`  

            Normalizes the d-th dimension (entries in the d-th column) to
            $[border,1-border]$.  

            Considers contents of DataMatrix as a d-dimensional dataset, one data point
            per row.  

            Parameters:  
            * `d` :  
                The dimension (column) that should be normalized (starting with 0)  
            * `border` :  
                Width of the border  

        """
        return _pysgpp_swig.DataMatrix_normalizeDimension(self, *args)

    def min(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `min() -> double`  

            Returns the minimum over all entries.  

            Returns:
            Minimal value of all entries  

        * `min(col) -> double`  

            Returns the minimum value of column col.  

            Parameters:  
            * `col` :  
                Number of the column  

            Returns:
            Minimum value  

        """
        return _pysgpp_swig.DataMatrix_min(self, *args)

    def max(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `max() -> double`  

            Returns the maximum over all entries.  

            Returns:
            Maximal value of all entries  

        * `max(col) -> double`  

            Returns the maximum value of column col.  

            Parameters:  
            * `col` :  
                Number of the column  

            Returns:
            Maximum value  

        """
        return _pysgpp_swig.DataMatrix_max(self, *args)

    def minmax(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `minmax(min, max)`  

            Determines minimum and maximum over all entries.  

            Parameters:  
            * `min` :  
                Reference variable for the minimum  
            * `max` :  
                Reference variable for the maximum  

        * `minmax(col, min, max)`  

            Determines minimum and maximum of column col.  

            Parameters:  
            * `col` :  
                Number of the column  
            * `min` :  
                Reference variable for the minimum  
            * `max` :  
                Reference variable for the maximum  

        """
        return _pysgpp_swig.DataMatrix_minmax(self, *args)

    def __str__(self) -> "std::string":
        r"""


        Overloaded function
        -------------------
        * `toString() -> std::string`  

            Returns a description of the DataMatrix as a string.  

            Returns:
            string of the DataMatrix  

        * `toString(text)`  

            Writes the data stored in the DataMatrix into a string.  

            Parameters:  
            * `text` :  
                String to which the data is written  

        """
        return _pysgpp_swig.DataMatrix___str__(self)

    def toFile(self, fileName: "std::string const &") -> "void":
        r"""


        """
        return _pysgpp_swig.DataMatrix_toFile(self, fileName)

    @staticmethod
    def fromFile(fileName: "std::string const &") -> "sgpp::base::DataMatrix":
        r"""


        """
        return _pysgpp_swig.DataMatrix_fromFile(fileName)

    def __array(self, datavector: "PyObject *") -> "PyObject *":
        return _pysgpp_swig.DataMatrix___array(self, datavector)

    def array(self):
      return self.__array(self)

    __swig_destroy__ = _pysgpp_swig.delete_DataMatrix

# Register DataMatrix in _pysgpp_swig:
_pysgpp_swig.DataMatrix_swigregister(DataMatrix)

def DataMatrix_fromFile(fileName: "std::string const &") -> "sgpp::base::DataMatrix":
    r"""


    """
    return _pysgpp_swig.DataMatrix_fromFile(fileName)

class RegularGridConfiguration(object):
    r"""

    `RegularGridConfiguration()`  

    structure that can be used by applications to cluster regular grid information  

    Constructors
    ------------
    * `RegularGridConfiguration()`  

    C++ includes: Grid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type_ = property(_pysgpp_swig.RegularGridConfiguration_type__get, _pysgpp_swig.RegularGridConfiguration_type__set)
    dim_ = property(_pysgpp_swig.RegularGridConfiguration_dim__get, _pysgpp_swig.RegularGridConfiguration_dim__set)
    level_ = property(_pysgpp_swig.RegularGridConfiguration_level__get, _pysgpp_swig.RegularGridConfiguration_level__set)
    maxDegree_ = property(_pysgpp_swig.RegularGridConfiguration_maxDegree__get, _pysgpp_swig.RegularGridConfiguration_maxDegree__set)
    boundaryLevel_ = property(_pysgpp_swig.RegularGridConfiguration_boundaryLevel__get, _pysgpp_swig.RegularGridConfiguration_boundaryLevel__set)
    filename_ = property(_pysgpp_swig.RegularGridConfiguration_filename__get, _pysgpp_swig.RegularGridConfiguration_filename__set)

    def __init__(self):
        r"""


        """
        _pysgpp_swig.RegularGridConfiguration_swiginit(self, _pysgpp_swig.new_RegularGridConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_RegularGridConfiguration

# Register RegularGridConfiguration in _pysgpp_swig:
_pysgpp_swig.RegularGridConfiguration_swigregister(RegularGridConfiguration)

class AdaptivityConfiguration(object):
    r"""


    structure that can be used by application to define adaptivity strategies  

    C++ includes: Grid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numRefinements_ = property(_pysgpp_swig.AdaptivityConfiguration_numRefinements__get, _pysgpp_swig.AdaptivityConfiguration_numRefinements__set)
    refinementThreshold_ = property(_pysgpp_swig.AdaptivityConfiguration_refinementThreshold__get, _pysgpp_swig.AdaptivityConfiguration_refinementThreshold__set)
    coarseningThreshold_ = property(_pysgpp_swig.AdaptivityConfiguration_coarseningThreshold__get, _pysgpp_swig.AdaptivityConfiguration_coarseningThreshold__set)
    maxLevelType_ = property(_pysgpp_swig.AdaptivityConfiguration_maxLevelType__get, _pysgpp_swig.AdaptivityConfiguration_maxLevelType__set)
    numRefinementPoints_ = property(_pysgpp_swig.AdaptivityConfiguration_numRefinementPoints__get, _pysgpp_swig.AdaptivityConfiguration_numRefinementPoints__set)
    numCoarseningPoints_ = property(_pysgpp_swig.AdaptivityConfiguration_numCoarseningPoints__get, _pysgpp_swig.AdaptivityConfiguration_numCoarseningPoints__set)
    percent_ = property(_pysgpp_swig.AdaptivityConfiguration_percent__get, _pysgpp_swig.AdaptivityConfiguration_percent__set)
    errorBasedRefinement = property(_pysgpp_swig.AdaptivityConfiguration_errorBasedRefinement_get, _pysgpp_swig.AdaptivityConfiguration_errorBasedRefinement_set)
    coarsenInitialPoints_ = property(_pysgpp_swig.AdaptivityConfiguration_coarsenInitialPoints__get, _pysgpp_swig.AdaptivityConfiguration_coarsenInitialPoints__set)

    def __init__(self):
        _pysgpp_swig.AdaptivityConfiguration_swiginit(self, _pysgpp_swig.new_AdaptivityConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_AdaptivityConfiguration

# Register AdaptivityConfiguration in _pysgpp_swig:
_pysgpp_swig.AdaptivityConfiguration_swigregister(AdaptivityConfiguration)

GridType_Linear = _pysgpp_swig.GridType_Linear
GridType_LinearStretched = _pysgpp_swig.GridType_LinearStretched
GridType_LinearL0Boundary = _pysgpp_swig.GridType_LinearL0Boundary
GridType_LinearBoundary = _pysgpp_swig.GridType_LinearBoundary
GridType_LinearStretchedBoundary = _pysgpp_swig.GridType_LinearStretchedBoundary
GridType_LinearTruncatedBoundary = _pysgpp_swig.GridType_LinearTruncatedBoundary
GridType_ModLinear = _pysgpp_swig.GridType_ModLinear
GridType_Poly = _pysgpp_swig.GridType_Poly
GridType_PolyBoundary = _pysgpp_swig.GridType_PolyBoundary
GridType_ModPoly = _pysgpp_swig.GridType_ModPoly
GridType_ModWavelet = _pysgpp_swig.GridType_ModWavelet
GridType_ModBspline = _pysgpp_swig.GridType_ModBspline
GridType_Prewavelet = _pysgpp_swig.GridType_Prewavelet
GridType_SquareRoot = _pysgpp_swig.GridType_SquareRoot
GridType_Periodic = _pysgpp_swig.GridType_Periodic
GridType_LinearClenshawCurtisBoundary = _pysgpp_swig.GridType_LinearClenshawCurtisBoundary
GridType_Bspline = _pysgpp_swig.GridType_Bspline
GridType_BsplineBoundary = _pysgpp_swig.GridType_BsplineBoundary
GridType_BsplineClenshawCurtis = _pysgpp_swig.GridType_BsplineClenshawCurtis
GridType_Wavelet = _pysgpp_swig.GridType_Wavelet
GridType_WaveletBoundary = _pysgpp_swig.GridType_WaveletBoundary
GridType_FundamentalSpline = _pysgpp_swig.GridType_FundamentalSpline
GridType_ModFundamentalSpline = _pysgpp_swig.GridType_ModFundamentalSpline
GridType_ModBsplineClenshawCurtis = _pysgpp_swig.GridType_ModBsplineClenshawCurtis
GridType_LinearStencil = _pysgpp_swig.GridType_LinearStencil
GridType_ModLinearStencil = _pysgpp_swig.GridType_ModLinearStencil
GridType_PolyClenshawCurtisBoundary = _pysgpp_swig.GridType_PolyClenshawCurtisBoundary
GridType_PolyClenshawCurtis = _pysgpp_swig.GridType_PolyClenshawCurtis
GridType_LinearClenshawCurtis = _pysgpp_swig.GridType_LinearClenshawCurtis
GridType_ModPolyClenshawCurtis = _pysgpp_swig.GridType_ModPolyClenshawCurtis
GridType_ModLinearClenshawCurtis = _pysgpp_swig.GridType_ModLinearClenshawCurtis
GridType_NakBsplineBoundaryCombigrid = _pysgpp_swig.GridType_NakBsplineBoundaryCombigrid
GridType_NaturalBsplineBoundary = _pysgpp_swig.GridType_NaturalBsplineBoundary
GridType_NakBsplineBoundary = _pysgpp_swig.GridType_NakBsplineBoundary
GridType_ModNakBspline = _pysgpp_swig.GridType_ModNakBspline
GridType_WeaklyFundamentalSplineBoundary = _pysgpp_swig.GridType_WeaklyFundamentalSplineBoundary
GridType_WeaklyFundamentalNakSplineBoundary = _pysgpp_swig.GridType_WeaklyFundamentalNakSplineBoundary
GridType_ModWeaklyFundamentalNakSpline = _pysgpp_swig.GridType_ModWeaklyFundamentalNakSpline
GridType_FundamentalSplineBoundary = _pysgpp_swig.GridType_FundamentalSplineBoundary
GridType_FundamentalNakSplineBoundary = _pysgpp_swig.GridType_FundamentalNakSplineBoundary
class Grid(object):
    r"""

    `Grid(other)`  

    abstract base class for all types grids used in sgpp the class gives pure
    virtual function definitions that have to be implemented by all types of grids  

    Constructors
    ------------
    * `Grid(other)`  

        delete copy constructor  

        Parameters:  
        * `other` :  

    C++ includes: Grid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def createGrid(gridConfig: "RegularGridConfiguration") -> "sgpp::base::Grid *":
        r"""


        creates a grid defined by the grid configuration  

        Parameters
        ----------
        * `gridConfig` :  
            grid configuration  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createGrid(gridConfig)

    @staticmethod
    def createLinearGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        Creates and returns a grid without grid points on the boundary (zero boundary
        conditions) with piecewise linear basis functions.  

        Level 4 sparse grid  

        Hierarchical basis
         functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createLinearGrid(dim)

    @staticmethod
    def createLinearStretchedGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a linear stretched grid without boundaries  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createLinearStretchedGrid_C2J-small.png"
        "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createLinearStretchedGrid(dim)

    @staticmethod
    def createLinearBoundaryGrid(dim: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        creates a linear boundary grid  

        Level 4 sparse
         grid with boundaryLevel = 0"</td> <td>\image html
        "createLinearBoundaryGrid_C2,_1J-small.png" "Level 4 sparse grid with
        boundaryLevel = 1"</td> <td>\image html
        "createLinearBoundaryGrid_C2,_2J-small.png" "Level 4 sparse grid with
        boundaryLevel = 2"</td>
        <td>\image html "hiba_createLinearGrid_C2J-small.png" "Hierarchical basis
        functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `boundaryLevel` :  
            on which level the boundary grid points and basis functions should be added;
            the default is 1, which results in a grid with the same resolution on the
            boundary as on the main axis  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createLinearBoundaryGrid(dim, boundaryLevel)

    @staticmethod
    def createLinearClenshawCurtisGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a linear Clenshaw-Curtis grid  

        Level 4
         sparse grid"</td>
        <td>\image html "hiba_createLinearClenshawCurtisGrid_C2J-small.png"
        "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createLinearClenshawCurtisGrid(dim)

    @staticmethod
    def createLinearClenshawCurtisBoundaryGrid(dim: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        creates a linear Clenshaw-Curtis boundary grid  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `boundaryLevel` :  
            level of the boundary  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createLinearClenshawCurtisBoundaryGrid(dim, boundaryLevel)

    @staticmethod
    def createModLinearClenshawCurtisGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a modified linear Clenshaw-Curtis grid  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createModLinearClenshawCurtisGrid(dim)

    @staticmethod
    def createLinearStretchedBoundaryGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a linearstretched truncated boundary grid  

        Level 4
         sparse grid"</td>
        <td>\image html "hiba_createLinearStretchedBoundaryGrid_C2J-small.png"
        "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        """
        return _pysgpp_swig.Grid_createLinearStretchedBoundaryGrid(dim)

    @staticmethod
    def createModLinearGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a modified linear grid  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createModLinearGrid_C2J-small.png" "Hierarchical basis
        functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createModLinearGrid(dim)

    @staticmethod
    def createPolyGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a polynomial grid  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createPolyGrid_C2,_3J-small.png" "Hierarchical basis
        functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the polynom's max. degree  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createPolyGrid(dim, degree)

    @staticmethod
    def createPolyBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        creates a polynomial grid with truncated boundary  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createPolyBoundaryGrid_C2,_3J-small.png"
        "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the polynom's max. degree  
        * `boundaryLevel` :  
            on which level the boundary grid points and basis functions should be added;
            the default is 1, which results in a grid with the same resolution on the
            boundary as on the main axis  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createPolyBoundaryGrid(dim, degree, boundaryLevel)

    @staticmethod
    def createModPolyGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a modified polynomial grid  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createModPolyGrid_C2,_3J-small.png" "Hierarchical
        basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the polynom's max. degree  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createModPolyGrid(dim, degree)

    @staticmethod
    def createWaveletGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a wavelet grid  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createWaveletGrid_C2J-small.png" "Hierarchical basis
        functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createWaveletGrid(dim)

    @staticmethod
    def createWaveletBoundaryGrid(dim: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        creates a wavelet trapezoid boundary grid  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createWaveletBoundaryGrid_C2J-small.png"
        "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `boundaryLevel` :  
            on which level the boundary grid points and basis functions should be added;
            the default is 1, which results in a grid with the same resolution on the
            boundary as on the main axis  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createWaveletBoundaryGrid(dim, boundaryLevel)

    @staticmethod
    def createModWaveletGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a modified wavelet grid  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createModWaveletGrid_C2J-small.png" "Hierarchical
        basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createModWaveletGrid(dim)

    @staticmethod
    def createBsplineGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a B-spline grid  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createBsplineGrid_C2,_3J-small.png" "Hierarchical
        basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the B-spline degree  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createBsplineGrid(dim, degree)

    @staticmethod
    def createBsplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        creates a B-spline trapezoid boundary grid  

        Level 4
         sparse grid"</td>
        <td>\image html "hiba_createBsplineBoundaryGrid_C2,_3J-small.png"
        "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the B-spline degree  
        * `boundaryLevel` :  
            on which level the boundary grid points and basis functions should be added;
            the default is 1, which results in a grid with the same resolution on the
            boundary as on the main axis  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createBsplineBoundaryGrid(dim, degree, boundaryLevel)

    @staticmethod
    def createBsplineClenshawCurtisGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        creates a B-spline Clenshaw-Curtis grid  

        Level 4
         sparse grid"</td>
        <td>\image html "hiba_createBsplineClenshawCurtisGrid_C2,_3J-small.png"
        "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the B-spline degree  
        * `boundaryLevel` :  
            on which level the boundary grid points and basis functions should be added;
            the default is 1, which results in a grid with the same resolution on the
            boundary as on the main axis  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createBsplineClenshawCurtisGrid(dim, degree, boundaryLevel)

    @staticmethod
    def createModBsplineGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a modified B-spline grid  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createModBsplineGrid_C2,_3J-small.png" "Hierarchical
        basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the B-spline degree  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createModBsplineGrid(dim, degree)

    @staticmethod
    def createModBsplineClenshawCurtisGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a modified B-spline Clenshaw-Curtis grid  


         "Level 4 sparse
        grid"  


         "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the B-spline degree  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createModBsplineClenshawCurtisGrid(dim, degree)

    @staticmethod
    def createFundamentalSplineGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a fundamental spline grid  

        Level 4
         sparse grid"</td>
        <td>\image html "hiba_createFundamentalSplineGrid_C2,_3J-small.png"
        "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the B-spline degree  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createFundamentalSplineGrid(dim, degree)

    @staticmethod
    def createModFundamentalSplineGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a modified fundamental spline grid  

        Level 4
         sparse grid"</td>
        <td>\image html "hiba_createModFundamentalSplineGrid_C2,_3J-small.png"
        "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the B-spline degree  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createModFundamentalSplineGrid(dim, degree)

    @staticmethod
    def createSquareRootGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a square root grid (h-grid)  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createSquareRootGrid_C2J-small.png" "Hierarchical
        basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createSquareRootGrid(dim)

    @staticmethod
    def createLinearTruncatedBoundaryGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a truncated boundary grid=contains all the gridpoints of the fullgrids
        which have $|l|<level and li>=l_user$  

        Level 4
         sparse grid"</td>
        <td>\image html "hiba_createLinearTruncatedBoundaryGrid_C2J-small.png"
        "Hierarchical basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createLinearTruncatedBoundaryGrid(dim)

    @staticmethod
    def createPrewaveletGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a prewavelet grid  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createPrewaveletGrid_C2J-small.png" "Hierarchical
        basis functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createPrewaveletGrid(dim)

    @staticmethod
    def createLinearGridStencil(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a stencil for a linear grid (without boundaries)  

        Level 4 sparse
         grid"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createLinearGridStencil(dim)

    @staticmethod
    def createModLinearGridStencil(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a stencil for a modified linear grid (without boundaries)  

        Level 4 sparse
         grid"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createModLinearGridStencil(dim)

    @staticmethod
    def createPeriodicGrid(dim: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a periodic grid  

        Level 4 sparse
         grid"</td>
        <td>\image html "hiba_createPeriodicGrid_C2J-small.png" "Hierarchical basis
        functions up to level 3"  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createPeriodicGrid(dim)

    @staticmethod
    def createPolyClenshawCurtisBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        creates a poly Clenshaw Curtis boundary grid with clenshaw curtis points  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the polynom's max. degree  
        * `boundaryLevel` :  
            level at which boundary points are added  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createPolyClenshawCurtisBoundaryGrid(dim, degree, boundaryLevel)

    @staticmethod
    def createPolyClenshawCurtisGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a poly grid with clenshaw curtis points  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the polynom's max. degree  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createPolyClenshawCurtisGrid(dim, degree)

    @staticmethod
    def createModPolyClenshawCurtisGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a modified poly grid with clenshaw curtis points  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the polynom's max. degree  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createModPolyClenshawCurtisGrid(dim, degree)

    @staticmethod
    def createNakBsplineBoundaryCombigridGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates a not a knot B-Spline boundary grid  

        Parameters
        ----------
        * `dim` :  
            the grid's dimension  
        * `degree` :  
            the B-spline degree  

        Returns
        -------
        grid  

        """
        return _pysgpp_swig.Grid_createNakBsplineBoundaryCombigridGrid(dim, degree)

    @staticmethod
    def createNaturalBsplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        """
        return _pysgpp_swig.Grid_createNaturalBsplineBoundaryGrid(dim, degree, boundaryLevel)

    @staticmethod
    def createNakBsplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        """
        return _pysgpp_swig.Grid_createNakBsplineBoundaryGrid(dim, degree, boundaryLevel)

    @staticmethod
    def createModNakBsplineGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
        r"""


        """
        return _pysgpp_swig.Grid_createModNakBsplineGrid(dim, degree)

    @staticmethod
    def createWeaklyFundamentalSplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        """
        return _pysgpp_swig.Grid_createWeaklyFundamentalSplineBoundaryGrid(dim, degree, boundaryLevel)

    @staticmethod
    def createWeaklyFundamentalNakSplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        """
        return _pysgpp_swig.Grid_createWeaklyFundamentalNakSplineBoundaryGrid(dim, degree, boundaryLevel)

    @staticmethod
    def createFundamentalSplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        """
        return _pysgpp_swig.Grid_createFundamentalSplineBoundaryGrid(dim, degree, boundaryLevel)

    @staticmethod
    def createFundamentalNakSplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
        r"""


        """
        return _pysgpp_swig.Grid_createFundamentalNakSplineBoundaryGrid(dim, degree, boundaryLevel)

    @staticmethod
    def unserialize(istr: "std::string const &") -> "sgpp::base::Grid *":
        r"""


        Overloaded function
        -------------------
        * `unserialize(istr) -> Grid *`  

            reads a grid out of a string  

            Parameters:  
            * `istr` :  
                string that contains the grid information  

            Returns:
            grid  

        * `unserialize(istr) -> Grid *`  

            reads a grid out of a stream  

            Parameters:  
            * `istr` :  
                inputstream that contains the grid information  

            Returns:
            grid  

        """
        return _pysgpp_swig.Grid_unserialize(istr)

    @staticmethod
    def stringToGridType(gridType: "std::string const &") -> "sgpp::base::GridType":
        r"""


        Conversion from string to grid type.  

        Parameters
        ----------
        * `gridType` :  
            grid type as a string  

        Returns
        -------
        actual grid type  

        """
        return _pysgpp_swig.Grid_stringToGridType(gridType)
    __swig_destroy__ = _pysgpp_swig.delete_Grid

    def getStorage(self) -> "sgpp::base::GridStorage &":
        r"""


        gets a reference to the GridStorage object  

        Returns
        -------
        reference to the GridStorage obeject  

        """
        return _pysgpp_swig.Grid_getStorage(self)

    def getBoundingBox(self) -> "sgpp::base::BoundingBox &":
        r"""


        gets a reference to the GridStorage's BoundingsBox object  

        Returns
        -------
        reference to the GridStorage's BoundingsBox object  

        """
        return _pysgpp_swig.Grid_getBoundingBox(self)

    def getStretching(self) -> "sgpp::base::Stretching &":
        r"""


        gets a reference to the GridStorage's Stretching object  

        Returns
        -------
        reference to the GridStorage's Stretching object  

        """
        return _pysgpp_swig.Grid_getStretching(self)

    def getGenerator(self) -> "sgpp::base::GridGenerator &":
        r"""


        Returns
        -------
        reference to a GridGenerator object  

        """
        return _pysgpp_swig.Grid_getGenerator(self)

    def getType(self) -> "sgpp::base::GridType":
        r"""


        Returns a string that identifies the grid type uniquely.  

        Returns
        -------
        string that identifies the grid type uniquely  

        """
        return _pysgpp_swig.Grid_getType(self)

    def getBasis(self) -> "sgpp::base::SBasis const &":
        r"""


        Returns the Basis class associated with the grid.  

        Returns
        -------
        Basis class associated with the grid  

        """
        return _pysgpp_swig.Grid_getBasis(self)

    def serialize(self) -> "void":
        r"""


        Overloaded function
        -------------------
        * `serialize(version=SERIALIZATION_VERSION) -> std::string`  

            Serializes grid to a string.  

            Needed for Java compatibility.  

            Parameters:  
            * `version` :  
                the serialization version of the file  

            Returns:
            string into which the grid is written  

        * `serialize(ostr, version=SERIALIZATION_VERSION)`  

            Serializes the grid.  

            Override if additional information need to be saved. Call base function
            before writing anything!  

            Parameters:  
            * `ostr` :  
                stream to which the grid is written  
            * `version` :  
                the serialization version of the file  

        * `serialize(ostr, version=SERIALIZATION_VERSION)`  

            Serializes grid to a string.  

            Needed for Python compatibility. Calls serialize(std::ostream&).  

            Parameters:  
            * `ostr` :  
                string into which the grid is written  
            * `version` :  
                the serialization version of the file  

        """
        return _pysgpp_swig.Grid_serialize(self)

    def refine(self, vector: "DataVector", num: "int") -> "void":
        r"""


        Refine grid Refine the given number of points on the grid according to the
        vector.  

        Parameters
        ----------
        * `vector` :  
            DataVector vector with errors for each basis function or alpha-vector  
        * `numOfPoints` :  
            integer number of points to refine  

        """
        return _pysgpp_swig.Grid_refine(self, vector, num)

    def insertPoint(self, dim: "size_t", levels: "unsigned int []", indeces: "unsigned int []", isLeaf: "bool") -> "void":
        r"""


        Insert one point to the grid.  

        Parameters
        ----------
        * `dim` :  
            dimension of the grid  
        * `levels` :  
            array with levels of the point  
        * `indices` :  
            array with indices of the point  
        * `isLeaf` :  
            indicator whether the point is a leaf  

        """
        return _pysgpp_swig.Grid_insertPoint(self, dim, levels, indeces, isLeaf)

    def getSize(self) -> "int":
        r"""


        Returns the number of points on the grid.  

        Returns
        -------
        the number of points on the grid  

        """
        return _pysgpp_swig.Grid_getSize(self)

    def getTypeAsString(self) -> "std::string":
        r"""


        Returns a string that identifies the grid type uniquely.  

        Returns
        -------
        string that identifies the grid type uniquely  

        """
        return _pysgpp_swig.Grid_getTypeAsString(self)

    def createGridOfEquivalentType(self, numDims: "size_t") -> "sgpp::base::Grid *":
        r"""


        creates an equivalent grid without copying the grid points  

        Parameters
        ----------
        * `numDims` :  
            number of dimensions  

        """
        return _pysgpp_swig.Grid_createGridOfEquivalentType(self, numDims)

    def clone(self) -> "sgpp::base::Grid *":
        r"""


        copies a grid  

        """
        return _pysgpp_swig.Grid_clone(self)

    def createMemento(self) -> "sgpp::base::Grid *":
        return _pysgpp_swig.Grid_createMemento(self)

    @staticmethod
    def setMemento(istr: "std::string const &") -> "sgpp::base::Grid *":
        return _pysgpp_swig.Grid_setMemento(istr)

    def getDegree(self) -> "size_t":
        return _pysgpp_swig.Grid_getDegree(self)

    def hash_hexdigest(self):
      import hashlib

      gs = self.getStorage()
      gps = [None] * gs.getSize()
      for i in xrange(gs.getSize()):
        gps[i] = gs.getPoint(i).getHash()
      return hashlib.sha512(str(gps)).hexdigest()


# Register Grid in _pysgpp_swig:
_pysgpp_swig.Grid_swigregister(Grid)

def Grid_createGrid(gridConfig: "RegularGridConfiguration") -> "sgpp::base::Grid *":
    r"""


    creates a grid defined by the grid configuration  

    Parameters
    ----------
    * `gridConfig` :  
        grid configuration  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createGrid(gridConfig)

def Grid_createLinearGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    Creates and returns a grid without grid points on the boundary (zero boundary
    conditions) with piecewise linear basis functions.  

    Level 4 sparse grid  

    Hierarchical basis
     functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createLinearGrid(dim)

def Grid_createLinearStretchedGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a linear stretched grid without boundaries  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createLinearStretchedGrid_C2J-small.png"
    "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createLinearStretchedGrid(dim)

def Grid_createLinearBoundaryGrid(dim: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    creates a linear boundary grid  

    Level 4 sparse
     grid with boundaryLevel = 0"</td> <td>\image html
    "createLinearBoundaryGrid_C2,_1J-small.png" "Level 4 sparse grid with
    boundaryLevel = 1"</td> <td>\image html
    "createLinearBoundaryGrid_C2,_2J-small.png" "Level 4 sparse grid with
    boundaryLevel = 2"</td>
    <td>\image html "hiba_createLinearGrid_C2J-small.png" "Hierarchical basis
    functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `boundaryLevel` :  
        on which level the boundary grid points and basis functions should be added;
        the default is 1, which results in a grid with the same resolution on the
        boundary as on the main axis  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createLinearBoundaryGrid(dim, boundaryLevel)

def Grid_createLinearClenshawCurtisGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a linear Clenshaw-Curtis grid  

    Level 4
     sparse grid"</td>
    <td>\image html "hiba_createLinearClenshawCurtisGrid_C2J-small.png"
    "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createLinearClenshawCurtisGrid(dim)

def Grid_createLinearClenshawCurtisBoundaryGrid(dim: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    creates a linear Clenshaw-Curtis boundary grid  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `boundaryLevel` :  
        level of the boundary  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createLinearClenshawCurtisBoundaryGrid(dim, boundaryLevel)

def Grid_createModLinearClenshawCurtisGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a modified linear Clenshaw-Curtis grid  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createModLinearClenshawCurtisGrid(dim)

def Grid_createLinearStretchedBoundaryGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a linearstretched truncated boundary grid  

    Level 4
     sparse grid"</td>
    <td>\image html "hiba_createLinearStretchedBoundaryGrid_C2J-small.png"
    "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    """
    return _pysgpp_swig.Grid_createLinearStretchedBoundaryGrid(dim)

def Grid_createModLinearGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a modified linear grid  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createModLinearGrid_C2J-small.png" "Hierarchical basis
    functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createModLinearGrid(dim)

def Grid_createPolyGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a polynomial grid  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createPolyGrid_C2,_3J-small.png" "Hierarchical basis
    functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the polynom's max. degree  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createPolyGrid(dim, degree)

def Grid_createPolyBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    creates a polynomial grid with truncated boundary  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createPolyBoundaryGrid_C2,_3J-small.png"
    "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the polynom's max. degree  
    * `boundaryLevel` :  
        on which level the boundary grid points and basis functions should be added;
        the default is 1, which results in a grid with the same resolution on the
        boundary as on the main axis  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createPolyBoundaryGrid(dim, degree, boundaryLevel)

def Grid_createModPolyGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a modified polynomial grid  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createModPolyGrid_C2,_3J-small.png" "Hierarchical
    basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the polynom's max. degree  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createModPolyGrid(dim, degree)

def Grid_createWaveletGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a wavelet grid  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createWaveletGrid_C2J-small.png" "Hierarchical basis
    functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createWaveletGrid(dim)

def Grid_createWaveletBoundaryGrid(dim: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    creates a wavelet trapezoid boundary grid  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createWaveletBoundaryGrid_C2J-small.png"
    "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `boundaryLevel` :  
        on which level the boundary grid points and basis functions should be added;
        the default is 1, which results in a grid with the same resolution on the
        boundary as on the main axis  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createWaveletBoundaryGrid(dim, boundaryLevel)

def Grid_createModWaveletGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a modified wavelet grid  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createModWaveletGrid_C2J-small.png" "Hierarchical
    basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createModWaveletGrid(dim)

def Grid_createBsplineGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a B-spline grid  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createBsplineGrid_C2,_3J-small.png" "Hierarchical
    basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the B-spline degree  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createBsplineGrid(dim, degree)

def Grid_createBsplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    creates a B-spline trapezoid boundary grid  

    Level 4
     sparse grid"</td>
    <td>\image html "hiba_createBsplineBoundaryGrid_C2,_3J-small.png"
    "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the B-spline degree  
    * `boundaryLevel` :  
        on which level the boundary grid points and basis functions should be added;
        the default is 1, which results in a grid with the same resolution on the
        boundary as on the main axis  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createBsplineBoundaryGrid(dim, degree, boundaryLevel)

def Grid_createBsplineClenshawCurtisGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    creates a B-spline Clenshaw-Curtis grid  

    Level 4
     sparse grid"</td>
    <td>\image html "hiba_createBsplineClenshawCurtisGrid_C2,_3J-small.png"
    "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the B-spline degree  
    * `boundaryLevel` :  
        on which level the boundary grid points and basis functions should be added;
        the default is 1, which results in a grid with the same resolution on the
        boundary as on the main axis  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createBsplineClenshawCurtisGrid(dim, degree, boundaryLevel)

def Grid_createModBsplineGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a modified B-spline grid  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createModBsplineGrid_C2,_3J-small.png" "Hierarchical
    basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the B-spline degree  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createModBsplineGrid(dim, degree)

def Grid_createModBsplineClenshawCurtisGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a modified B-spline Clenshaw-Curtis grid  


     "Level 4 sparse
    grid"  


     "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the B-spline degree  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createModBsplineClenshawCurtisGrid(dim, degree)

def Grid_createFundamentalSplineGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a fundamental spline grid  

    Level 4
     sparse grid"</td>
    <td>\image html "hiba_createFundamentalSplineGrid_C2,_3J-small.png"
    "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the B-spline degree  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createFundamentalSplineGrid(dim, degree)

def Grid_createModFundamentalSplineGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a modified fundamental spline grid  

    Level 4
     sparse grid"</td>
    <td>\image html "hiba_createModFundamentalSplineGrid_C2,_3J-small.png"
    "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the B-spline degree  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createModFundamentalSplineGrid(dim, degree)

def Grid_createSquareRootGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a square root grid (h-grid)  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createSquareRootGrid_C2J-small.png" "Hierarchical
    basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createSquareRootGrid(dim)

def Grid_createLinearTruncatedBoundaryGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a truncated boundary grid=contains all the gridpoints of the fullgrids
    which have $|l|<level and li>=l_user$  

    Level 4
     sparse grid"</td>
    <td>\image html "hiba_createLinearTruncatedBoundaryGrid_C2J-small.png"
    "Hierarchical basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createLinearTruncatedBoundaryGrid(dim)

def Grid_createPrewaveletGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a prewavelet grid  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createPrewaveletGrid_C2J-small.png" "Hierarchical
    basis functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createPrewaveletGrid(dim)

def Grid_createLinearGridStencil(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a stencil for a linear grid (without boundaries)  

    Level 4 sparse
     grid"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createLinearGridStencil(dim)

def Grid_createModLinearGridStencil(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a stencil for a modified linear grid (without boundaries)  

    Level 4 sparse
     grid"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createModLinearGridStencil(dim)

def Grid_createPeriodicGrid(dim: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a periodic grid  

    Level 4 sparse
     grid"</td>
    <td>\image html "hiba_createPeriodicGrid_C2J-small.png" "Hierarchical basis
    functions up to level 3"  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createPeriodicGrid(dim)

def Grid_createPolyClenshawCurtisBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    creates a poly Clenshaw Curtis boundary grid with clenshaw curtis points  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the polynom's max. degree  
    * `boundaryLevel` :  
        level at which boundary points are added  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createPolyClenshawCurtisBoundaryGrid(dim, degree, boundaryLevel)

def Grid_createPolyClenshawCurtisGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a poly grid with clenshaw curtis points  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the polynom's max. degree  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createPolyClenshawCurtisGrid(dim, degree)

def Grid_createModPolyClenshawCurtisGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a modified poly grid with clenshaw curtis points  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the polynom's max. degree  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createModPolyClenshawCurtisGrid(dim, degree)

def Grid_createNakBsplineBoundaryCombigridGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    creates a not a knot B-Spline boundary grid  

    Parameters
    ----------
    * `dim` :  
        the grid's dimension  
    * `degree` :  
        the B-spline degree  

    Returns
    -------
    grid  

    """
    return _pysgpp_swig.Grid_createNakBsplineBoundaryCombigridGrid(dim, degree)

def Grid_createNaturalBsplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    """
    return _pysgpp_swig.Grid_createNaturalBsplineBoundaryGrid(dim, degree, boundaryLevel)

def Grid_createNakBsplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    """
    return _pysgpp_swig.Grid_createNakBsplineBoundaryGrid(dim, degree, boundaryLevel)

def Grid_createModNakBsplineGrid(dim: "size_t", degree: "size_t") -> "sgpp::base::Grid *":
    r"""


    """
    return _pysgpp_swig.Grid_createModNakBsplineGrid(dim, degree)

def Grid_createWeaklyFundamentalSplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    """
    return _pysgpp_swig.Grid_createWeaklyFundamentalSplineBoundaryGrid(dim, degree, boundaryLevel)

def Grid_createWeaklyFundamentalNakSplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    """
    return _pysgpp_swig.Grid_createWeaklyFundamentalNakSplineBoundaryGrid(dim, degree, boundaryLevel)

def Grid_createFundamentalSplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    """
    return _pysgpp_swig.Grid_createFundamentalSplineBoundaryGrid(dim, degree, boundaryLevel)

def Grid_createFundamentalNakSplineBoundaryGrid(dim: "size_t", degree: "size_t", boundaryLevel: "size_t"=1) -> "sgpp::base::Grid *":
    r"""


    """
    return _pysgpp_swig.Grid_createFundamentalNakSplineBoundaryGrid(dim, degree, boundaryLevel)

def Grid_unserialize(istr: "std::string const &") -> "sgpp::base::Grid *":
    r"""


    Overloaded function
    -------------------
    * `unserialize(istr) -> Grid *`  

        reads a grid out of a string  

        Parameters:  
        * `istr` :  
            string that contains the grid information  

        Returns:
        grid  

    * `unserialize(istr) -> Grid *`  

        reads a grid out of a stream  

        Parameters:  
        * `istr` :  
            inputstream that contains the grid information  

        Returns:
        grid  

    """
    return _pysgpp_swig.Grid_unserialize(istr)

def Grid_stringToGridType(gridType: "std::string const &") -> "sgpp::base::GridType":
    r"""


    Conversion from string to grid type.  

    Parameters
    ----------
    * `gridType` :  
        grid type as a string  

    Returns
    -------
    actual grid type  

    """
    return _pysgpp_swig.Grid_stringToGridType(gridType)

def Grid_setMemento(istr: "std::string const &") -> "sgpp::base::Grid *":
    return _pysgpp_swig.Grid_setMemento(istr)


def createOperationDiagonal(grid: "Grid", multiplicationFactor: "double"=0.25) -> "sgpp::base::OperationMatrix *":
    r"""


    Factory method, returning an OperationDiagonal (OperationMatrix) for the grid at
    hand.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used  
    * `multiplicationFactor` :  
        MultiplicationFactor which is to be used  

    Returns
    -------
    Pointer to the new OperationMatrix object for the Grid grid  

    """
    return _pysgpp_swig.createOperationDiagonal(grid, multiplicationFactor)

def createOperationHierarchisation(grid: "Grid") -> "sgpp::base::OperationHierarchisation *":
    r"""


    Factory method, returning an OperationHierarchisation for the grid at hand.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for hierarchisation  

    Returns
    -------
    Pointer to the new OperationHierarchisation object for the Grid grid  

    """
    return _pysgpp_swig.createOperationHierarchisation(grid)

def createOperationArbitraryBoundaryHierarchisation(grid: "Grid") -> "sgpp::base::OperationHierarchisation *":
    r"""


    Factory method, returning an OperationArbitraryBoundaryHierarchisation for the
    grid at hand.  

    Note: object has to be freed after use. This operation should be used if the
    boundary level of your grid is larger than 1.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for hierarchisation  

    Returns
    -------
    Pointer to the new OperationArbitraryBoundaryHierarchisation object for the Grid
    grid  

    """
    return _pysgpp_swig.createOperationArbitraryBoundaryHierarchisation(grid)

def createOperationQuadrature(grid: "Grid") -> "sgpp::base::OperationQuadrature *":
    r"""


    Factory method, returning an OperationQuadrature for the grid at hand.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for quadrature  

    Returns
    -------
    Pointer to the new OperationQuadrature for the Grid grid  

    """
    return _pysgpp_swig.createOperationQuadrature(grid)

def createOperationFirstMoment(grid: "Grid") -> "sgpp::base::OperationFirstMoment *":
    r"""


    Factory method, returning an OperationFirstMoment for the grid at hand.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for quadrature  

    Returns
    -------
    Pointer to the new OperationFirstMoment for the Grid grid  

    """
    return _pysgpp_swig.createOperationFirstMoment(grid)

def createOperationSecondMoment(grid: "Grid") -> "sgpp::base::OperationSecondMoment *":
    r"""


    Factory method, returning an OperationSecondMoment for the grid at hand.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for quadrature  

    Returns
    -------
    Pointer to the new OperationSecondMoment for the Grid grid  

    """
    return _pysgpp_swig.createOperationSecondMoment(grid)

def createOperationConvert(grid: "Grid") -> "sgpp::base::OperationConvert *":
    r"""


    Factory method, returning an OperationConvert for the grid at hand.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for conversion  

    Returns
    -------
    Pointer to the new OperationConvert object for the Grid grid  

    """
    return _pysgpp_swig.createOperationConvert(grid)

def createOperationIdentity(grid: "Grid") -> "sgpp::base::OperationMatrix *":
    r"""


    Factory method, returning an OperationIdentity for the grid at hand.  

    Note: object has to be freed after use. Just calls OperationIdentity()
    independent of grid; factory method provided for uniform use.  

    Returns
    -------
    Pointer to the new OperationIdentity object  

    """
    return _pysgpp_swig.createOperationIdentity(grid)

def createOperationEval(grid: "Grid") -> "sgpp::base::OperationEval *":
    r"""


    Factory method, returning an OperationEval for the grid at hand.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used  

    Returns
    -------
    Pointer to the new OperationEval object for the Grid grid  

    """
    return _pysgpp_swig.createOperationEval(grid)

def createOperationMultipleEvalInter(grid: "Grid", dataset: "DataMatrix", interactions: "std::set< std::set< size_t > >") -> "sgpp::base::OperationMultipleEval *":
    r"""


    Similar to createOperationMultipleEval, but makes use of interaction terms
    during evaluation.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used  
    * `dataset` :  
        The dataset (DataMatrix, one datapoint per row) that is to be evaluated for
        the sparse grid function  
    * `interactions` :  
        A list of Interaction the SG is reduced to  

    Returns
    -------
    Pointer to the new OperationMultipleEval object for the Grid grid  

    """
    return _pysgpp_swig.createOperationMultipleEvalInter(grid, dataset, interactions)

def createOperationMultipleEvalNaive(grid: "Grid", dataset: "DataMatrix") -> "sgpp::base::OperationMultipleEval *":
    r"""


    Factory method, returning an OperationMultipleEvalNaive for the grid at hand.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used  
    * `dataset` :  
        The dataset (DataMatrix, one datapoint per row) that is to be evaluated for
        the sparse grid function  

    Returns
    -------
    Pointer to the new OperationMultipleEval object for the Grid grid  

    """
    return _pysgpp_swig.createOperationMultipleEvalNaive(grid, dataset)

def createOperationEvalNaive(grid: "Grid") -> "sgpp::base::OperationEval *":
    r"""


    Factory method, returning an OperationEval for the grid at hand.  

    In contrast to OperationEval, implementations of OperationEval returned by this
    function should use a "naive" method for evaluating sparse grid functions,
    e.g. evaluate all basis functions by brute force. Note: object has to be freed
    after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used  

    Returns
    -------
    Pointer to the new OperationEval object for the Grid grid  

    """
    return _pysgpp_swig.createOperationEvalNaive(grid)

def createOperationEvalGradientNaive(grid: "Grid") -> "sgpp::base::OperationEvalGradient *":
    r"""


    Factory method, returning an OperationEvalGradient for the grid at hand.  

    Implementations of OperationEvalGradientNaive returned by this function should
    use a "naive" method for evaluating sparse grid function gradients, e.g.
    evaluate all basis functions by brute force. Note: object has to be freed after
    use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used  

    Returns
    -------
    Pointer to the new OperationEvalGradient object for the Grid grid  

    """
    return _pysgpp_swig.createOperationEvalGradientNaive(grid)

def createOperationEvalHessianNaive(grid: "Grid") -> "sgpp::base::OperationEvalHessian *":
    r"""


    Factory method, returning an OperationEvalHessian for the grid at hand.  

    Implementations of OperationEvalHessianNaive returned by this function should
    use a "naive" method for evaluating sparse grid function Hessians, e.g.
    evaluate all basis functions by brute force. Note: object has to be freed after
    use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used  

    Returns
    -------
    Pointer to the new OperationEvalHessian object for the Grid grid  

    """
    return _pysgpp_swig.createOperationEvalHessianNaive(grid)

def createOperationEvalPartialDerivativeNaive(grid: "Grid") -> "sgpp::base::OperationEvalPartialDerivative *":
    r"""


    Factory method, returning an OperationEvalPartialDerivative for the grid at
    hand.  

    Implementations of OperationEvalPartialDerivativeNaive returned by this function
    should use a "naive" method for evaluating sparse grid function partial
    derivatives, e.g. evaluate all basis functions by brute force. Note: object has
    to be freed after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used  

    Returns
    -------
    Pointer to the new OperationEvalPartialDerivative object for the Grid grid  

    """
    return _pysgpp_swig.createOperationEvalPartialDerivativeNaive(grid)
class DataVectorSP(FloatVector):
    r"""

    `DataVectorSP()`  
    `DataVectorSP(arg1)`  
    `DataVectorSP(arg1)`  
    `DataVectorSP(input, size)`  
    `DataVectorSP(size)`  
    `DataVectorSP(size, value)`  
    `DataVectorSP(input)`  
    `DataVectorSP(input)`  
    `DataVectorSP(input)`  

    A class to store one-dimensional data.  

    Typically, an object of type DataVectorSP will contain an array of
    (hierarchical) coefficients (or surplusses), or the coordinates of a data point
    at which a sparse grid function should be evaluated.  

    This is an re-implementation of the standard DataVector for single precision
    floating point numbers in order to increase support for GPUs.  

    Constructors
    ------------
    * `DataVectorSP()`  

        Create an empty DataVectorSP.  

    * `DataVectorSP(arg1)`  

        Copy constructor.  

    * `DataVectorSP(arg1)`  

        Move constructor.  

    * `DataVectorSP(input, size)`  

        Create a new DataVectorSP from a float array with size elements.  

        Parameters:  
        * `input` :  
            float array that contains the data  
        * `size` :  
            number of elements  

    * `DataVectorSP(size)`  

        Create a DataVectorSP with *size* elements (uninitialized values).  

        Parameters:  
        * `size` :  
            Number of elements  

    * `DataVectorSP(size, value)`  

        Create a DataVectorSP with *size* elements and initializes all elements with
        the same value.  

        Parameters:  
        * `size` :  
            Number of elements  
        * `value` :  
            Value for all entries  

    * `DataVectorSP(input)`  

        Create a new DataVector from a std::initializer_list<float>.  

        Parameters:  
        * `input` :  
            std::initializer_list<float> that contains the data  

    * `DataVectorSP(input)`  

        Create a new DataVectorSP from a std::vector<float>.  

        Parameters:  
        * `input` :  
            std::vector<float> that contains the data  

    * `DataVectorSP(input)`  

        Create a new DataVectorSP from a std::vector<int>.  

        Parameters:  
        * `input` :  
            std::vector<int> that contains the data  

    C++ includes: DataVectorSP.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_DataVectorSP

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DataVectorSP()`  

            Create an empty DataVectorSP.  

        * `DataVectorSP(arg1)`  

            Copy constructor.  

        * `DataVectorSP(arg1)`  

            Move constructor.  

        * `DataVectorSP(input, size)`  

            Create a new DataVectorSP from a float array with size elements.  

            Parameters:  
            * `input` :  
                float array that contains the data  
            * `size` :  
                number of elements  

        * `DataVectorSP(size)`  

            Create a DataVectorSP with *size* elements (uninitialized values).  

            Parameters:  
            * `size` :  
                Number of elements  

        * `DataVectorSP(size, value)`  

            Create a DataVectorSP with *size* elements and initializes all elements with
            the same value.  

            Parameters:  
            * `size` :  
                Number of elements  
            * `value` :  
                Value for all entries  

        * `DataVectorSP(input)`  

            Create a new DataVector from a std::initializer_list<float>.  

            Parameters:  
            * `input` :  
                std::initializer_list<float> that contains the data  

        * `DataVectorSP(input)`  

            Create a new DataVectorSP from a std::vector<float>.  

            Parameters:  
            * `input` :  
                std::vector<float> that contains the data  

        * `DataVectorSP(input)`  

            Create a new DataVectorSP from a std::vector<int>.  

            Parameters:  
            * `input` :  
                std::vector<int> that contains the data  

        """
        _pysgpp_swig.DataVectorSP_swiginit(self, _pysgpp_swig.new_DataVectorSP(*args))

    @staticmethod
    def fromFile(fileName: "std::string const &") -> "sgpp::base::DataVectorSP":
        r"""


        """
        return _pysgpp_swig.DataVectorSP_fromFile(fileName)

    @staticmethod
    def fromString(serializedVector: "std::string const &") -> "sgpp::base::DataVectorSP":
        r"""


        """
        return _pysgpp_swig.DataVectorSP_fromString(serializedVector)

    def resizeZero(self, nrows: "size_t") -> "void":
        r"""


        Resizes the DataVectorSP to size elements.  

        All new additional entries are set to zero. If nrows is smaller than the current
        number of rows, all superfluous entries are removed.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows of the DataVectorSP  

        """
        return _pysgpp_swig.DataVectorSP_resizeZero(self, nrows)

    def restructure(self, remainingIndex: "SizeVector") -> "void":
        r"""


        Resizes the DataVectorSP by removing entries.  

        Throws an exception if boundaries a violated.  

        Parameters
        ----------
        * `remainingIndex` :  
            vector that contains the remaining indices of the DataVectorSP  

        """
        return _pysgpp_swig.DataVectorSP_restructure(self, remainingIndex)

    def remove(self, indexesToRemove: "SizeVector") -> "void":
        r"""


        Removes indexes form the vector.  

        Throws an exception if the boundaries are violated  

        Parameters
        ----------
        * `indexesToRemove` :  
            a vector if indexes that will be removed from the vector  

        """
        return _pysgpp_swig.DataVectorSP_remove(self, indexesToRemove)

    def append(self, *args) -> "size_t":
        r"""


        Overloaded function
        -------------------
        * `append() -> size_t`  

            Appends a new element and returns index of it.  

            Returns:
            Index of new element  

        * `append(value) -> size_t`  

            Appends a new element and returns index of new element.  

            Parameters:  
            * `value` :  
                Value of new element  

            Returns:
            Index of new element  

        """
        return _pysgpp_swig.DataVectorSP_append(self, *args)

    def insert(self, index: "size_t", value: "float") -> "void":
        r"""


        Inserts a new element at the given index.  

        Parameters
        ----------
        * `index` :  
            Index of new element  
        * `value` :  
            Value of new element  

        """
        return _pysgpp_swig.DataVectorSP_insert(self, index, value)

    def setAll(self, value: "float") -> "void":
        r"""


        Sets all values of DataVectorSP to value.  

        Parameters
        ----------
        * `value` :  
            New value for all entries  

        """
        return _pysgpp_swig.DataVectorSP_setAll(self, value)

    def get(self, i: "size_t") -> "float":
        r"""


        Returns the i-th element.  

        Parameters
        ----------
        * `i` :  
            position of the element  

        Returns
        -------
        data[i]  

        """
        return _pysgpp_swig.DataVectorSP_get(self, i)

    def set(self, i: "size_t", value: "float") -> "void":
        r"""


        Sets the element at index i to value.  

        Parameters
        ----------
        * `i` :  
            Index  
        * `value` :  
            New value for element  

        """
        return _pysgpp_swig.DataVectorSP_set(self, i, value)

    def copyFrom(self, vec: "DataVectorSP") -> "void":
        r"""


        Copies the data from another DataVectorSP vec.  

        Disregards the number of entries set for the two vectors, i.e., just copies the
        data entry by entry. If the size matches, the current DataVectorSP is an exact
        copy of vec. If not, as many elements as possible are copied, and everything
        else is left untouched.  

        Parameters
        ----------
        * `vec` :  
            The source DataVectorSP containing the data  

        """
        return _pysgpp_swig.DataVectorSP_copyFrom(self, vec)

    def add(self, vec: "DataVectorSP") -> "void":
        r"""


        Adds the values from another DataVectorSP to the current values.  

        Modifies the current values.  

        Parameters
        ----------
        * `vec` :  
            The DataVectorSP which is added to the current values  

        """
        return _pysgpp_swig.DataVectorSP_add(self, vec)

    def accumulate(self, vec: "DataVectorSP") -> "void":
        r"""


        """
        return _pysgpp_swig.DataVectorSP_accumulate(self, vec)

    def sub(self, vec: "DataVectorSP") -> "void":
        r"""


        Subtracts the values from another DataVectorSP of the current values.  

        Modifies the current values.  

        Parameters
        ----------
        * `vec` :  
            The DataVectorSP which is subtracted from the current values  

        """
        return _pysgpp_swig.DataVectorSP_sub(self, vec)

    def componentwise_mult(self, vec: "DataVectorSP") -> "void":
        r"""


        Multiplies the current DataVectorSP component-wise with another DataVectorSP.  

        Modifies the current values. Performs  

        Parameters
        ----------
        * `vec` :  
            the DataVectorSP which is multiplied to current DataVectorSP  

        """
        return _pysgpp_swig.DataVectorSP_componentwise_mult(self, vec)

    def componentwise_div(self, vec: "DataVectorSP") -> "void":
        r"""


        Divides the current DataVectorSP component-wise by another DataVectorSP.  

        Modifies the current values. Performs  Note: **No check for division by zero!**  

        Parameters
        ----------
        * `vec` :  
            the DataVectorSP which the current DataVectorSP is divided by  

        """
        return _pysgpp_swig.DataVectorSP_componentwise_div(self, vec)

    def dotProduct(self, vec: "DataVectorSP") -> "float":
        r"""


        Returns the dot product of the two vectors.  

        Parameters
        ----------
        * `vec` :  
            Reference to another vector  

        Returns
        -------
        The dot-product  

        """
        return _pysgpp_swig.DataVectorSP_dotProduct(self, vec)

    def mult(self, scalar: "float") -> "void":
        r"""


        multiplies all elements by a constant factor  

        Parameters
        ----------
        * `scalar` :  
            the constant  

        """
        return _pysgpp_swig.DataVectorSP_mult(self, scalar)

    def sqr(self) -> "void":
        r"""


        Squares all elements of the DataVectorSP.  

        """
        return _pysgpp_swig.DataVectorSP_sqr(self)

    def sqrt(self) -> "void":
        r"""


        Takes the square root of all elements of the DataVectorSP.  

        """
        return _pysgpp_swig.DataVectorSP_sqrt(self)

    def abs(self) -> "void":
        r"""


        Sets all elements to their absolute value.  

        """
        return _pysgpp_swig.DataVectorSP_abs(self)

    def sum(self) -> "float":
        r"""


        Returns the sum of all elements.  

        Returns
        -------
        The sum of all elements  

        """
        return _pysgpp_swig.DataVectorSP_sum(self)

    def maxNorm(self) -> "float":
        r"""


        calculates the vector's max norm  

        Returns
        -------
        the vector's max norm  

        """
        return _pysgpp_swig.DataVectorSP_maxNorm(self)

    def RMSNorm(self) -> "float":
        r"""


        Returns the vector's root mean square (RMS)-norm, i.e., $\sqrt{ 1/N
        \sum_{i=1}^N x_i^2 }$.  

        If the vector's entries correspond to function values on a full grid, this is
        the discrete $L^2$-norm of the corresponding function.  

        Returns
        -------
        The vector's root mean square-norm.  

        """
        return _pysgpp_swig.DataVectorSP_RMSNorm(self)

    def l2Norm(self) -> "float":
        r"""


        Returns the vector's $l^2$-norm, i.e., $\sqrt{ \sum_i x_i^2 }$.  

        Returns
        -------
        The vector's $l^2$-norm.  

        """
        return _pysgpp_swig.DataVectorSP_l2Norm(self)

    def min(self) -> "float":
        r"""


        Returns the minimum over all entries.  

        Returns
        -------
        Minimal value  

        """
        return _pysgpp_swig.DataVectorSP_min(self)

    def max(self) -> "float":
        r"""


        Returns the maximum over all entries.  

        Returns
        -------
        global maximum  

        """
        return _pysgpp_swig.DataVectorSP_max(self)

    def minmax(self, min: "float *", max: "float *") -> "void":
        r"""


        Determines minimum and maximum over all entries.  

        Parameters
        ----------
        * `min` :  
            Reference variable for the minimum  
        * `max` :  
            Reference variable for the maximum  

        """
        return _pysgpp_swig.DataVectorSP_minmax(self, min, max)

    def axpy(self, a: "float", x: "DataVectorSP") -> "void":
        r"""


        Adds a*x to current vector.  

        BLAS Level 1 (elementary vector operations) operation: axpy.  

        Parameters
        ----------
        * `a` :  
            A scalar  
        * `x` :  
            Reference to the DataVectorSP  

        """
        return _pysgpp_swig.DataVectorSP_axpy(self, a, x)

    def getPointer(self, *args) -> "float const *":
        r"""


        Overloaded function
        -------------------
        * `getPointer() -> float *`  

            gets a pointer to the data array  

            Returns:
            pointer to the data array  

        * `getPointer() -> const float *`  

            gets a const pointer to the data array  

            Returns:
            const pointer to the data array  

        """
        return _pysgpp_swig.DataVectorSP_getPointer(self, *args)

    def getSize(self) -> "size_t":
        r"""


        gets the elements stored in the vector  

        Deprecated
        in favour of the equivalent size() method  

        Returns
        -------
        elements stored in the vector  

        """
        return _pysgpp_swig.DataVectorSP_getSize(self)

    def getNumberNonZero(self) -> "size_t":
        r"""


        Determines the number of non-zero elements in the vector.  

        Returns
        -------
        The number of non-zero elements  

        """
        return _pysgpp_swig.DataVectorSP_getNumberNonZero(self)

    def partitionClasses(self, threshold: "float") -> "void":
        r"""


        Partitions vector into two classes using a choosen border.  

        Parameters
        ----------
        * `threshold` :  
            value of the border  

        """
        return _pysgpp_swig.DataVectorSP_partitionClasses(self, threshold)

    def normalize(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `normalize()`  

            Normalizes vector entries to [0,1].  

        * `normalize(border)`  

            Normalizes vector entries to [border, 1-border].  

            Parameters:  
            * `border` :  
                width of border  

        """
        return _pysgpp_swig.DataVectorSP_normalize(self, *args)

    def toString(self) -> "std::string":
        r"""


        Overloaded function
        -------------------
        * `toString() -> std::string`  

            Returns a description of the DataVectorSP as a string.  

            Returns:
            string of the DataVectorSP  

        * `toString(text)`  

            Writes the data stored in the DataVectorSP into a string.  

            Parameters:  
            * `text` :  
                string to which the data is written  

        """
        return _pysgpp_swig.DataVectorSP_toString(self)

    def toFile(self, fileName: "std::string const &") -> "void":
        r"""


        """
        return _pysgpp_swig.DataVectorSP_toFile(self, fileName)

# Register DataVectorSP in _pysgpp_swig:
_pysgpp_swig.DataVectorSP_swigregister(DataVectorSP)

def DataVectorSP_fromFile(fileName: "std::string const &") -> "sgpp::base::DataVectorSP":
    r"""


    """
    return _pysgpp_swig.DataVectorSP_fromFile(fileName)

def DataVectorSP_fromString(serializedVector: "std::string const &") -> "sgpp::base::DataVectorSP":
    r"""


    """
    return _pysgpp_swig.DataVectorSP_fromString(serializedVector)

class DataMatrixSP(FloatVector):
    r"""

    `DataMatrixSP()`  
    `DataMatrixSP(arg1)`  
    `DataMatrixSP(input, nrows, ncols)`  
    `DataMatrixSP(arg1)`  
    `DataMatrixSP(nrows, ncols)`  
    `DataMatrixSP(nrows, ncols, value)`  
    `DataMatrixSP(input, nrows)`  
    `DataMatrixSP(input, nrows)`  

    A class to store two-dimensional data.  

    Typically, DataMatrixSP would contain a set of (d-dimensional) data or
    evaluation points, i.e., the DataMatrixSP consists of d columns, and each row is
    one of the points. Thus, typical functionality like obtaining the maximum for a
    certain dimension (or attribute), or normalizing all data points to the unit
    interval for a certain dimension are provided.  

    This is an re-implementation of the standard DataMatrix for single precision
    floating point numbers in order to increase support for GPUs.  

    Constructors
    ------------
    * `DataMatrixSP()`  

        Creates an empty two-dimensional DataMatrixSP.  

    * `DataMatrixSP(arg1)`  

        Copy constructor.  

    * `DataMatrixSP(input, nrows, ncols)`  

        Create a new DataMatrixSP from a float array.  

        The float array contains the entries row-wise: x0_0,x0_1,...,x0_ncol-1,
        x1_0,x1_1,... ... xnrow_0, xnrow_1,...,xnrow_ncol-1  

        Parameters:  
        * `input` :  
            float array that contains the data  
        * `nrows` :  
            number of rows  
        * `ncols` :  
            number of columns  

    * `DataMatrixSP(arg1)`  

        Move constructor.  

    * `DataMatrixSP(nrows, ncols)`  

        Create a two-dimensional DataMatrixSP with *nrows* rows and *ncols* columns
        (uninitialized values).  

        Parameters:  
        * `nrows` :  
            Number of rows  
        * `ncols` :  
            Number of columns  

    * `DataMatrixSP(nrows, ncols, value)`  

        Create a two-dimensional DataMatrixSP with *nrows* rows and *ncols* columns
        and initializes all elements with the same value.  

        Parameters:  
        * `nrows` :  
            Number of rows  
        * `ncols` :  
            Number of columns  
        * `value` :  
            Value for all entries  

    * `DataMatrixSP(input, nrows)`  

        Create a new DataMatrixSP from a std::initializer_list<float>.  

        Parameters:  
        * `input` :  
            std::initializer_list<float> that contains the data  
        * `nrows` :  
            number of rows  

    * `DataMatrixSP(input, nrows)`  

        Create a new DataMatrixSP from a std::vector<float>.  

        Parameters:  
        * `input` :  
            std::vector<float> that contains the data  
        * `nrows` :  
            number of rows  

    C++ includes: DataMatrixSP.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_DataMatrixSP

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DataMatrixSP()`  

            Creates an empty two-dimensional DataMatrixSP.  

        * `DataMatrixSP(arg1)`  

            Copy constructor.  

        * `DataMatrixSP(input, nrows, ncols)`  

            Create a new DataMatrixSP from a float array.  

            The float array contains the entries row-wise: x0_0,x0_1,...,x0_ncol-1,
            x1_0,x1_1,... ... xnrow_0, xnrow_1,...,xnrow_ncol-1  

            Parameters:  
            * `input` :  
                float array that contains the data  
            * `nrows` :  
                number of rows  
            * `ncols` :  
                number of columns  

        * `DataMatrixSP(arg1)`  

            Move constructor.  

        * `DataMatrixSP(nrows, ncols)`  

            Create a two-dimensional DataMatrixSP with *nrows* rows and *ncols* columns
            (uninitialized values).  

            Parameters:  
            * `nrows` :  
                Number of rows  
            * `ncols` :  
                Number of columns  

        * `DataMatrixSP(nrows, ncols, value)`  

            Create a two-dimensional DataMatrixSP with *nrows* rows and *ncols* columns
            and initializes all elements with the same value.  

            Parameters:  
            * `nrows` :  
                Number of rows  
            * `ncols` :  
                Number of columns  
            * `value` :  
                Value for all entries  

        * `DataMatrixSP(input, nrows)`  

            Create a new DataMatrixSP from a std::initializer_list<float>.  

            Parameters:  
            * `input` :  
                std::initializer_list<float> that contains the data  
            * `nrows` :  
                number of rows  

        * `DataMatrixSP(input, nrows)`  

            Create a new DataMatrixSP from a std::vector<float>.  

            Parameters:  
            * `input` :  
                std::vector<float> that contains the data  
            * `nrows` :  
                number of rows  

        """
        _pysgpp_swig.DataMatrixSP_swiginit(self, _pysgpp_swig.new_DataMatrixSP(*args))

    @staticmethod
    def fromFile(fileName: "std::string const &") -> "sgpp::base::DataMatrixSP":
        r"""


        """
        return _pysgpp_swig.DataMatrixSP_fromFile(fileName)

    @staticmethod
    def fromString(serializedVector: "std::string const &") -> "sgpp::base::DataMatrixSP":
        r"""


        """
        return _pysgpp_swig.DataMatrixSP_fromString(serializedVector)

    def resizeRows(self, nrows: "size_t") -> "void":
        r"""


        Resizes the DataMatrixSP to nrows rows.  

        All new additional entries are uninitialized. If nrows is smaller than the
        current number of rows, all superfluous entries are removed.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows of the DataMatrixSP  

        """
        return _pysgpp_swig.DataMatrixSP_resizeRows(self, nrows)

    def resize(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `resize(nrows)`  

            Resizes the DataMatrixSP to nrows rows.  

            All new additional entries are uninitialized. If nrows is smaller than the
            current number of rows, all superfluous entries are removed. Deprecated
            use resizeRows  

            Parameters:  
            * `nrows` :  
                New number of rows of the DataMatrixSP  

        * `resize(nrows, ncols)`  

            Resizes the DataMatrixSP to nrows rows and ncols columns.  

            All new additional entries are uninitialized. If nrows*ncols is smaller than
            the current number of entries, all superfluous entries are removed.
            Deprecated
            use resizeRowsCols  

            Parameters:  
            * `nrows` :  
                New number of rows of the DataMatrixSP  
            * `ncols` :  
                New number of columns of the DataMatrixSP  

        """
        return _pysgpp_swig.DataMatrixSP_resize(self, *args)

    def resizeRowsCols(self, nrows: "size_t", ncols: "size_t") -> "void":
        r"""


        Resizes the DataMatrixSP to nrows rows and ncols columns.  

        All new additional entries are uninitialized. If nrows*ncols is smaller than the
        current number of entries, all superfluous entries are removed.  

        Parameters
        ----------
        * `nrows` :  
            New number of rows of the DataMatrixSP  
        * `ncols` :  
            New number of columns of the DataMatrixSP  

        """
        return _pysgpp_swig.DataMatrixSP_resizeRowsCols(self, nrows, ncols)

    def resizeQuadratic(self, size: "size_t") -> "void":
        r"""


        Resizes the quadratic DataMatrixSP to size rows and size columns.  

        All new additional entries are uninitialized. If size is smaller than the
        current size of the quadratic DataMatrixSP, all superfluous entries are removed.  

        Parameters
        ----------
        * `size` :  
            New dimension of quadratic data DataMatrixSP  

        """
        return _pysgpp_swig.DataMatrixSP_resizeQuadratic(self, size)

    def resizeZero(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `resizeZero(nrows)`  

            Resizes the DataMatrixSP to nrows rows.  

            All new additional entries are set to zero. If nrows is smaller than the
            current number of rows, all superfluous entries are removed. Deprecated
            use resizeRows  

            Parameters:  
            * `nrows` :  
                New number of rows of the DataMatrixSP  

        * `resizeZero(nrows, ncols)`  

            Resizes the DataMatrixSP to nrows rows and ncols columns.  

            All new additional entries are set to zero. If nrows*ncols is smaller than
            the current number of entries, all superfluous entries are removed.
            Deprecated
            use resizeRowsCols  

            Parameters:  
            * `nrows` :  
                New number of rows of the DataMatrixSP  
            * `ncols` :  
                New number of columns of the DataMatrixSP  

        """
        return _pysgpp_swig.DataMatrixSP_resizeZero(self, *args)

    def resizeToSubMatrix(self, row_1: "size_t", col_1: "size_t", row_2: "size_t", col_2: "size_t") -> "void":
        r"""


        Resize current matrix to the submatrix Mat[row_1:row_2, col_1:col_2].  

        Parameters
        ----------
        * `row_1`, `col_1` :  
            corresponding to left upper index of desired submatrix  
        * `row_2`, `col_2` :  
            corresponding to right lower index of desired submatrix  

        """
        return _pysgpp_swig.DataMatrixSP_resizeToSubMatrix(self, row_1, col_1, row_2, col_2)

    def reserveAdditionalRows(self, inc_nrows: "size_t") -> "void":
        r"""


        Reserves memory for potentially inc_nrows new rows; the actual number of rows
        remains unchanged.  

        Corresponds to a resize to nrows+inc_nrows new rows while leaving the current
        matrix' size unchanged.  

        Parameters
        ----------
        * `inc_nrows` :  
            Number of additional rows for which storage is to be reserved.  

        """
        return _pysgpp_swig.DataMatrixSP_reserveAdditionalRows(self, inc_nrows)

    def appendRow(self, *args) -> "size_t":
        r"""


        Overloaded function
        -------------------
        * `appendRow() -> size_t`  

            Appends a new row and returns index of it.  

            Returns:
            Index of new row  

        * `appendRow(vec) -> size_t`  

            Appends a new row with data contained in DataVectorSP vec and returns index
            of new row.  

            Parameters:  
            * `vec` :  
                DataVectorSP (length has to match getNcols()) with data  

            Returns:
            Index of new row  

        """
        return _pysgpp_swig.DataMatrixSP_appendRow(self, *args)

    def appendCol(self, vec: "DataVectorSP") -> "size_t":
        r"""


        Appends a new Col with data contained in DataVectorSP vec and returns index of
        new col.  

        Parameters
        ----------
        * `vec` :  
            DataVectorSP (length has to match getNcols()) with data  

        Returns
        -------
        Index of new col  

        """
        return _pysgpp_swig.DataMatrixSP_appendCol(self, vec)

    def setAll(self, value: "float") -> "void":
        r"""


        Sets all entries of DataMatrixSP to value.  

        Parameters
        ----------
        * `value` :  
            New value for all entries  

        """
        return _pysgpp_swig.DataMatrixSP_setAll(self, value)

    def copyFrom(self, matr: "DataMatrixSP") -> "void":
        r"""


        Copies the data from another DataMatrixSP matr.  

        Disregards the number of rows and columns set for the two matrices, i.e., just
        copies the data entry by entry (and row by row). If the dimensions match (nrows,
        ncols), the current DataMatrixSP is an exact copy of matr. If not, as many
        elements as possible are copied, and everything else is left untouched.  

        Parameters
        ----------
        * `matr` :  
            The source DataMatrixSP containing the data  

        """
        return _pysgpp_swig.DataMatrixSP_copyFrom(self, matr)

    def transpose(self) -> "void":
        r"""


        Transposes this DataMatrixSP.  

        """
        return _pysgpp_swig.DataMatrixSP_transpose(self)

    def __call__(self, *args) -> "float const &":
        return _pysgpp_swig.DataMatrixSP___call__(self, *args)

    def get(self, row: "size_t", col: "size_t") -> "float":
        r"""


        Returns the value of the element at position [row,col].  

        Parameters
        ----------
        * `row` :  
            Row  
        * `col` :  
            Column  

        Returns
        -------
        Value of the element  

        """
        return _pysgpp_swig.DataMatrixSP_get(self, row, col)

    def set(self, row: "size_t", col: "size_t", value: "float") -> "void":
        r"""


        Sets the element at position [row,col] to value.  

        Parameters
        ----------
        * `row` :  
            Row  
        * `col` :  
            Column  
        * `value` :  
            New value for element  

        """
        return _pysgpp_swig.DataMatrixSP_set(self, row, col, value)

    def getRow(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `getRow(row, vec)`  

            Copies the values of a row to the DataVectorSP vec.  

            Parameters:  
            * `row` :  
                The row  
            * `vec` :  
                DataVectorSP into which the data is written  

        * `getRow(row, vec)`  

            Copies the values of a row to the std::vector vec.  

            Parameters:  
            * `row` :  
                The row  
            * `vec` :  
                std::vector into which the data is written  

        """
        return _pysgpp_swig.DataMatrixSP_getRow(self, *args)

    def setRow(self, row: "size_t", vec: "DataVectorSP") -> "void":
        r"""


        Sets a row of the DataMatrixSP to the values of a DataVectorSP vec.  

        Parameters
        ----------
        * `row` :  
            The row which is to be overwritten  
        * `vec` :  
            DataVectorSP containing the data of the row  

        """
        return _pysgpp_swig.DataMatrixSP_setRow(self, row, vec)

    def getColumn(self, col: "size_t", vec: "DataVectorSP") -> "void":
        r"""


        Copies the values of a column to the DataVectorSP vec.  

        Parameters
        ----------
        * `col` :  
            The column  
        * `vec` :  
            DataVectorSP into which the data is written  

        """
        return _pysgpp_swig.DataMatrixSP_getColumn(self, col, vec)

    def setColumn(self, col: "size_t", vec: "DataVectorSP") -> "void":
        r"""


        Sets a column of the DataMatrixSP to the values of a DataVectorSP vec.  

        Parameters
        ----------
        * `col` :  
            The column which is to be overwritten  
        * `vec` :  
            DataVectorSP containing the data of the column  

        """
        return _pysgpp_swig.DataMatrixSP_setColumn(self, col, vec)

    def add(self, matr: "DataMatrixSP") -> "void":
        r"""


        Adds the values from another DataMatrixSP to the current values.  

        Modifies the current values.  

        Parameters
        ----------
        * `matr` :  
            The DataMatrixSP which is added to the current values  

        """
        return _pysgpp_swig.DataMatrixSP_add(self, matr)

    def sub(self, matr: "DataMatrixSP") -> "void":
        r"""


        Subtracts the values from another DataMatrixSP of the current values.  

        Modifies the current values.  

        Parameters
        ----------
        * `matr` :  
            The DataMatrixSP which is subtracted from the current values  

        """
        return _pysgpp_swig.DataMatrixSP_sub(self, matr)

    def addReduce(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `addReduce(reduction)`  

            Reduce the DataMatrixSP along the columns by adding all entries in one row.  

            Parameters:  
            * `reduction` :  
                DataVectorSP into which the reduce columns are stored  

        * `addReduce(reduction, beta, start_beta)`  

            Reduce the DataMatrixSP along the columns by adding all entries in one row.  

            Parameters:  
            * `reduction` :  
                DataVectorSP to which the reduce columns are added  
            * `beta` :  
                vector with length of number of columns beta[i] is multiplied to each
                element row[j][i]  
            * `start_beta` :  
                where to start using the beta coefficients  

        """
        return _pysgpp_swig.DataMatrixSP_addReduce(self, *args)

    def expand(self, expand: "DataVectorSP") -> "void":
        r"""


        expands a given DataVectorSP into a DataMatrixSP.  

        Parameters
        ----------
        * `expand` :  
            DataVectorSP that should be expanded  

        """
        return _pysgpp_swig.DataMatrixSP_expand(self, expand)

    def componentwise_mult(self, matr: "DataMatrixSP") -> "void":
        r"""


        Multiplies the current DataMatrixSP component-wise with another DataMatrixSP.  

        Modifies the current values. Performs  

        Parameters
        ----------
        * `matr` :  
            the DataMatrixSP which is multiplied to current DataMatrixSP  

        """
        return _pysgpp_swig.DataMatrixSP_componentwise_mult(self, matr)

    def componentwise_div(self, matr: "DataMatrixSP") -> "void":
        r"""


        Divides the current DataMatrixSP component-wise by another DataMatrixSP.  

        Modifies the current values. Performs  Note: **No check for division by zero!**  

        Parameters
        ----------
        * `matr` :  
            the DataMatrixSP which the current DataMatrixSP is divided by  

        """
        return _pysgpp_swig.DataMatrixSP_componentwise_div(self, matr)

    def mult(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `mult(x, y)`  

            Multiplies the matrix with a vector x and stores the result in another
            vector y.  

            Parameters:  
            * `x` :  
                vector to be multiplied  
            * `y` :  
                vector in which the result should be stored  

        * `mult(scalar)`  

            Multiplies all elements by a constant factor.  

            Parameters:  
            * `scalar` :  
                the constant  

        """
        return _pysgpp_swig.DataMatrixSP_mult(self, *args)

    def sqr(self) -> "void":
        r"""


        Squares all elements of the DataMatrixSP.  

        """
        return _pysgpp_swig.DataMatrixSP_sqr(self)

    def sqrt(self) -> "void":
        r"""


        Takes the square root of all elements of the DataMatrixSP.  

        """
        return _pysgpp_swig.DataMatrixSP_sqrt(self)

    def abs(self) -> "void":
        r"""


        Sets all elements to their absolute value.  

        """
        return _pysgpp_swig.DataMatrixSP_abs(self)

    def sum(self) -> "float":
        r"""


        Returns the sum of all elements.  

        Returns
        -------
        The sum of all elements  

        """
        return _pysgpp_swig.DataMatrixSP_sum(self)

    def min(self, *args) -> "float":
        r"""


        Overloaded function
        -------------------
        * `min() -> float`  

            Returns the minimum over all entries.  

            Returns:
            Minimal value of all entries  

        * `min(col) -> float`  

            Returns the minimum value of column col.  

            Parameters:  
            * `col` :  
                Number of the column  

            Returns:
            Minimum value  

        """
        return _pysgpp_swig.DataMatrixSP_min(self, *args)

    def max(self, *args) -> "float":
        r"""


        Overloaded function
        -------------------
        * `max() -> float`  

            Returns the maximum over all entries.  

            Returns:
            Maximal value of all entries  

        * `max(col) -> float`  

            Returns the maximum value of column col.  

            Parameters:  
            * `col` :  
                Number of the column  

            Returns:
            Maximum value  

        """
        return _pysgpp_swig.DataMatrixSP_max(self, *args)

    def minmax(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `minmax(min, max)`  

            Determines minimum and maximum over all entries.  

            Parameters:  
            * `min` :  
                Reference variable for the minimum  
            * `max` :  
                Reference variable for the maximum  

        * `minmax(col, min, max)`  

            Determines minimum and maximum of column col.  

            Parameters:  
            * `col` :  
                Number of the column  
            * `min` :  
                Reference variable for the minimum  
            * `max` :  
                Reference variable for the maximum  

        """
        return _pysgpp_swig.DataMatrixSP_minmax(self, *args)

    def getPointer(self, *args) -> "float const *":
        r"""


        Overloaded function
        -------------------
        * `getPointer() -> float *`  

            Returns pointer to float array containing underlying data.  

            Returns:
            Pointer to data  

        * `getPointer() -> const float *`  

            Returns const pointer to float array containing underlying data.  

            Returns:
            Const pointer to data  

        """
        return _pysgpp_swig.DataMatrixSP_getPointer(self, *args)

    def getSize(self) -> "size_t":
        r"""


        Returns the total number of (used) elements, i.e., getNrows()*getNCols()  

        Returns
        -------
        Number of elements stored in the matrix  

        """
        return _pysgpp_swig.DataMatrixSP_getSize(self)

    def getAdditionallyReservedRows(self) -> "size_t":
        r"""


        Returns the number of unused rows.  

        Returns
        -------
        number of unused rows  

        """
        return _pysgpp_swig.DataMatrixSP_getAdditionallyReservedRows(self)

    def getNumberNonZero(self) -> "size_t":
        r"""


        Determines the number of non-zero elements in the vector.  

        Returns
        -------
        The number of non-zero elements  

        """
        return _pysgpp_swig.DataMatrixSP_getNumberNonZero(self)

    def getNrows(self) -> "size_t":
        r"""


        Returns the number of rows of the DataMatrixSP.  

        Returns
        -------
        Number of rows  

        """
        return _pysgpp_swig.DataMatrixSP_getNrows(self)

    def getNcols(self) -> "size_t":
        r"""


        Returns the number of columns of the DataMatrixSP.  

        Returns
        -------
        Number of columns  

        """
        return _pysgpp_swig.DataMatrixSP_getNcols(self)

    def normalizeDimension(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `normalizeDimension(d)`  

            Normalizes the d-th dimension (entries in the d-th column) to $[0,1]$.  

            Considers contents of DataMatrixSP as a d-dimensional dataset, one data
            point per row.  

            Parameters:  
            * `d` :  
                The dimension (column) that should be normalized (starting with 0)  

        * `normalizeDimension(d, border)`  

            Normalizes the d-th dimension (entries in the d-th column) to
            $[border,1-border]$.  

            Considers contents of DataMatrixSP as a d-dimensional dataset, one data
            point per row.  

            Parameters:  
            * `d` :  
                The dimension (column) that should be normalized (starting with 0)  
            * `border` :  
                Width of the border  

        """
        return _pysgpp_swig.DataMatrixSP_normalizeDimension(self, *args)

    def toFile(self, fileName: "std::string const &") -> "void":
        r"""


        """
        return _pysgpp_swig.DataMatrixSP_toFile(self, fileName)

    def toString(self) -> "std::string":
        r"""


        Overloaded function
        -------------------
        * `toString() -> std::string`  

            Returns a description of the DataMatrixSP as a string.  

            Returns:
            string of the DataMatrixSP  

        * `toString(text)`  

            Writes the data stored in the DataMatrixSP into a string.  

            Parameters:  
            * `text` :  
                String to which the data is written  

        """
        return _pysgpp_swig.DataMatrixSP_toString(self)

# Register DataMatrixSP in _pysgpp_swig:
_pysgpp_swig.DataMatrixSP_swigregister(DataMatrixSP)

def DataMatrixSP_fromFile(fileName: "std::string const &") -> "sgpp::base::DataMatrixSP":
    r"""


    """
    return _pysgpp_swig.DataMatrixSP_fromFile(fileName)

def DataMatrixSP_fromString(serializedVector: "std::string const &") -> "sgpp::base::DataMatrixSP":
    r"""


    """
    return _pysgpp_swig.DataMatrixSP_fromString(serializedVector)

class BoundingBox1D(object):
    r"""

    `BoundingBox1D()`  
    `BoundingBox1D(leftBoundary, rightBoundary)`  
    `BoundingBox1D(leftBoundary, rightBoundary, bDirichletLeft, bDirichletRight)`  

    struct that defines the boundaries for one specific dimension  

    Constructors
    ------------
    * `BoundingBox1D()`  

        Default constructor initializing leftBoundary = 0, rightBoundary = 1, and
        bDirichletLeft = bDirichletLeft = false.  

    * `BoundingBox1D(leftBoundary, rightBoundary)`  

        Constructor initializing bDirichletLeft = bDirichletLeft = false.  

        Parameters:  
        * `leftBoundary` :  
            left boundary position  
        * `rightBoundary` :  
            right boundary position  

    * `BoundingBox1D(leftBoundary, rightBoundary, bDirichletLeft, bDirichletRight)`  

        Constructor.  

        Parameters:  
        * `leftBoundary` :  
            left boundary position  
        * `rightBoundary` :  
            right boundary position  
        * `bDirichletLeft` :  
            whether to use Dirichlet boundaries on the left boundary  
        * `bDirichletRight` :  
            whether to use Dirichlet boundaries on the right boundary  

    C++ includes: BoundingBox.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    leftBoundary = property(_pysgpp_swig.BoundingBox1D_leftBoundary_get, _pysgpp_swig.BoundingBox1D_leftBoundary_set)
    rightBoundary = property(_pysgpp_swig.BoundingBox1D_rightBoundary_get, _pysgpp_swig.BoundingBox1D_rightBoundary_set)
    bDirichletLeft = property(_pysgpp_swig.BoundingBox1D_bDirichletLeft_get, _pysgpp_swig.BoundingBox1D_bDirichletLeft_set)
    bDirichletRight = property(_pysgpp_swig.BoundingBox1D_bDirichletRight_get, _pysgpp_swig.BoundingBox1D_bDirichletRight_set)

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `BoundingBox1D()`  

            Default constructor initializing leftBoundary = 0, rightBoundary = 1, and
            bDirichletLeft = bDirichletLeft = false.  

        * `BoundingBox1D(leftBoundary, rightBoundary)`  

            Constructor initializing bDirichletLeft = bDirichletLeft = false.  

            Parameters:  
            * `leftBoundary` :  
                left boundary position  
            * `rightBoundary` :  
                right boundary position  

        * `BoundingBox1D(leftBoundary, rightBoundary, bDirichletLeft, bDirichletRight)`  

            Constructor.  

            Parameters:  
            * `leftBoundary` :  
                left boundary position  
            * `rightBoundary` :  
                right boundary position  
            * `bDirichletLeft` :  
                whether to use Dirichlet boundaries on the left boundary  
            * `bDirichletRight` :  
                whether to use Dirichlet boundaries on the right boundary  

        """
        _pysgpp_swig.BoundingBox1D_swiginit(self, _pysgpp_swig.new_BoundingBox1D(*args))
    __swig_destroy__ = _pysgpp_swig.delete_BoundingBox1D

# Register BoundingBox1D in _pysgpp_swig:
_pysgpp_swig.BoundingBox1D_swigregister(BoundingBox1D)

class BoundingBox(object):
    r"""

    `BoundingBox(boundingBox1Ds)`  
    `BoundingBox(dimension)`  

    This class implements the boundaries of the sparse grid.  

    Internally the grid is set up on a trivial cube.  

    This class gives the class gives the opportunity to stretch this cube in every
    dimension separately.  

    Constructors
    ------------
    * `BoundingBox(boundingBox1Ds)`  

        Constructor for BoundingBox.  

        initializes the Bounding with specific values for all dimensions  

        Parameters:  
        * `boundingBox1Ds` :  
            array that contains all boundaries  

    * `BoundingBox(dimension)`  

        Constructor for BoundingBox.  

        initializes the Bounding with a N-d trivial cube  

        Parameters:  
        * `dimension` :  
            number of the dimensions used with the grid  

    C++ includes: BoundingBox.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `BoundingBox(boundingBox1Ds)`  

            Constructor for BoundingBox.  

            initializes the Bounding with specific values for all dimensions  

            Parameters:  
            * `boundingBox1Ds` :  
                array that contains all boundaries  

        * `BoundingBox(dimension)`  

            Constructor for BoundingBox.  

            initializes the Bounding with a N-d trivial cube  

            Parameters:  
            * `dimension` :  
                number of the dimensions used with the grid  

        """
        _pysgpp_swig.BoundingBox_swiginit(self, _pysgpp_swig.new_BoundingBox(*args))
    __swig_destroy__ = _pysgpp_swig.delete_BoundingBox

    def setBoundary(self, d: "size_t", boundingBox1D: "BoundingBox1D") -> "void":
        r"""


        Sets left and right boundary for a specific dimension.  

        Parameters
        ----------
        * `d` :  
            the dimension in which the boundary should be changed  
        * `boundingBox1D` :  
            reference to a BoundingBox1D object that contains the new boundaries  

        """
        return _pysgpp_swig.BoundingBox_setBoundary(self, d, boundingBox1D)

    def getBoundary(self, d: "size_t") -> "sgpp::base::BoundingBox1D const &":
        r"""


        Returns the left and right boundary for a specific dimension.  

        Parameters
        ----------
        * `d` :  
            the dimension in which the boundary should be read  

        Returns
        -------
        a BoundingBox1D object that contains the boundaries  

        """
        return _pysgpp_swig.BoundingBox_getBoundary(self, d)

    def getDimension(self) -> "size_t":
        r"""


        Returns the number of dimensions of this bounding box.  

        Returns
        -------
        number of dimensions  

        """
        return _pysgpp_swig.BoundingBox_getDimension(self)

    def getIntervalWidth(self, d: "size_t") -> "double":
        r"""


        Calculates the width of the interval in one dimension.  

        Parameters
        ----------
        * `d` :  
            the dimension in which the width of the interval should be determined  

        Returns
        -------
        width of the interval  

        """
        return _pysgpp_swig.BoundingBox_getIntervalWidth(self, d)

    def getIntervalOffset(self, d: "size_t") -> "double":
        r"""


        Returns the offset in positive x-direction of the interval in one dimension.  

        Parameters
        ----------
        * `d` :  
            dimension in which the offset of the interval should be determined  

        Returns
        -------
        offset in positive x-direction of the interval  

        """
        return _pysgpp_swig.BoundingBox_getIntervalOffset(self, d)

    def isUnitCube(self) -> "bool":
        r"""


        Determine if this bounding box describes the unit cube $[0, 1]^d$.  

        Returns
        -------
        true if this bounding box is the unit cube, otherwise false  

        """
        return _pysgpp_swig.BoundingBox_isUnitCube(self)

    def transformPointsToBoundingBox(self, points: "DataMatrix") -> "void":
        r"""


        Transform points in the unit cube $[0, 1]^d$ to points in the BoundingBox.  

        Parameters
        ----------
        * `points` :  
            points to be transformed in-place  

        """
        return _pysgpp_swig.BoundingBox_transformPointsToBoundingBox(self, points)

    def transformPointToBoundingBox(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `transformPointToBoundingBox(point)`  

            Transform a point in the unit cube $[0, 1]^d$ to a point in the BoundingBox.  

            Parameters:  
            * `point` :  
                point to be transformed in-place  

        * `transformPointToBoundingBox(d, point) -> double`  

            Transform a point in the unit interval $[0, 1]$ to a point in the
            BoundingBox in 1D.  

            Parameters:  
            * `d` :  
                dimension  
            * `point` :  
                1D point in unit interval  

            Returns:
            transformed 1D point in the BoundingBox  

        """
        return _pysgpp_swig.BoundingBox_transformPointToBoundingBox(self, *args)

    def transformPointsToUnitCube(self, points: "DataMatrix") -> "void":
        r"""


        Transform points in the BoundingBox to points in the unit cube $[0, 1]^d$.  

        Parameters
        ----------
        * `points` :  
            points to be transformed in-place (row-wise)  

        """
        return _pysgpp_swig.BoundingBox_transformPointsToUnitCube(self, points)

    def transformPointToUnitCube(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `transformPointToUnitCube(point)`  

            Transform a point in the BoundingBox to a point in the unit cube $[0, 1]^d$.  

            Parameters:  
            * `point` :  
                point to be transformed in-place  

        * `transformPointToUnitCube(d, point) -> double`  

            Transform a point in the BoundingBox to a point in the unit interval $[0,
            1]$ in 1D.  

            Parameters:  
            * `d` :  
                dimension  
            * `point` :  
                1D point in the BoundingBox  

            Returns:
            transformed 1D point in the unit interval  

        """
        return _pysgpp_swig.BoundingBox_transformPointToUnitCube(self, *args)

    def isContainingPoint(self, *args) -> "bool":
        r"""


        Overloaded function
        -------------------
        * `isContainingPoint(point) -> bool`  

            Check whether the BoundingBox contains a given point.  

            Parameters:  
            * `point` :  
                point to be checked  

            Returns:
            whether the point is contained in the BoundingBox  

        * `isContainingPoint(d, point) -> bool`  

            Check whether the BoundingBox contains a given point in a specific
            dimension.  

            Parameters:  
            * `d` :  
                dimension to be checked  
            * `point` :  
                1D point to be checked  

            Returns:
            whether the point is contained in the BoundingBox in the given dimension  

        """
        return _pysgpp_swig.BoundingBox_isContainingPoint(self, *args)

    def hasDirichletBoundaryLeft(self, d: "size_t") -> "bool":
        r"""


        Determines if the interval in the specified dimension has left Dirichlet
        boundary conditions.  

        Parameters
        ----------
        * `d` :  
            the dimension for which the left boundary condition should be determined  

        Returns
        -------
        true if Dirichlet Boundary conditions, otherwise false  

        """
        return _pysgpp_swig.BoundingBox_hasDirichletBoundaryLeft(self, d)

    def hasDirichletBoundaryRight(self, d: "size_t") -> "bool":
        r"""


        Determines if the interval in the specified dimension has right Dirichlet
        boundary conditions.  

        Parameters
        ----------
        * `d` :  
            the dimension for which the right boundary condition should be determined  

        Returns
        -------
        true if Dirichlet Boundary conditions, otherwise false  

        """
        return _pysgpp_swig.BoundingBox_hasDirichletBoundaryRight(self, d)

    def serialize(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `serialize(version=SERIALIZATION_VERSION) -> std::string`  

            Serialize the BoundingBox into a string.  

            Parameters:  
            * `version` :  
                the serialization version of the file  

            Returns:
            string that contains all BoundingBox information  

        * `serialize(ostream, version=SERIALIZATION_VERSION)`  

            Serialize the BoundingBox into a stream.  

            Parameters:  
            * `ostream` :  
                reference to a stream into that all BoundingBox information is written  
            * `version` :  
                the serialization version of the file  

        """
        return _pysgpp_swig.BoundingBox_serialize(self, *args)

    def unserialize(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `unserialize(istr, version)`  

            Unserialize from a string.  

            Parameters:  
            * `istr` :  
                string which contains a serialized BoundingBox  
            * `version` :  
                the serialization version of the file  

        * `unserialize(istr, version)`  

            Unserialize from a stream.  

            Parameters:  
            * `istr` :  
                stream which contains a serialized BoundingBox  
            * `version` :  
                the serialization version of the file  

        """
        return _pysgpp_swig.BoundingBox_unserialize(self, *args)

    def toString(self) -> "std::string":
        r"""


        Overloaded function
        -------------------
        * `toString() -> std::string`  

            Converts the BoundingBox to a string.  

            Returns:
            string to which the data is written  

        * `toString(text)`  

            Converts the BoundingBox to a string.  

            Parameters:  
            * `text` :  
                string to which the data is written  

        """
        return _pysgpp_swig.BoundingBox_toString(self)

# Register BoundingBox in _pysgpp_swig:
_pysgpp_swig.BoundingBox_swigregister(BoundingBox)

LOOKUPSIZE = _pysgpp_swig.LOOKUPSIZE
LOOKUPMAX = _pysgpp_swig.LOOKUPMAX
class Stretching1D(object):
    r"""

    `Stretching1D()`  
    `Stretching1D(type)`  

    Constructors
    ------------
    * `Stretching1D()`  

        Default constructor initializing type = "id", x_0 = 0.0, and xsi = 1.0.  

    * `Stretching1D(type)`  

        Constructor initializing x_0 = 0.0, and xsi = 1.0.  

    C++ includes: Stretching.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_pysgpp_swig.Stretching1D_type_get, _pysgpp_swig.Stretching1D_type_set)
    x_0 = property(_pysgpp_swig.Stretching1D_x_0_get, _pysgpp_swig.Stretching1D_x_0_set)
    xsi = property(_pysgpp_swig.Stretching1D_xsi_get, _pysgpp_swig.Stretching1D_xsi_set)
    lookup = property(_pysgpp_swig.Stretching1D_lookup_get, _pysgpp_swig.Stretching1D_lookup_set)

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `Stretching1D()`  

            Default constructor initializing type = "id", x_0 = 0.0, and xsi = 1.0.  

        * `Stretching1D(type)`  

            Constructor initializing x_0 = 0.0, and xsi = 1.0.  

        """
        _pysgpp_swig.Stretching1D_swiginit(self, _pysgpp_swig.new_Stretching1D(*args))
    __swig_destroy__ = _pysgpp_swig.delete_Stretching1D

# Register Stretching1D in _pysgpp_swig:
_pysgpp_swig.Stretching1D_swigregister(Stretching1D)

class Stretching(BoundingBox):
    r"""

    `Stretching(boundaries, stretching1Ds)`  
    `Stretching(dimension)`  
    `Stretching(dimension, coordinates)`  

    Stretching can be done in different ways:  

    1.  No Stretching operation is done  
    2.  Clenshaw-Curtis Stretching  
    3.  Stretching is done via log/exp calculation  
    4.  Sinh Stretching  
    5.  Fitob Stretching  
    6.  Discrete Stretching (No function used, grid points are directly taken)  

    Constructors
    ------------
    * `Stretching(boundaries, stretching1Ds)`  

        Constructor for Stretching.  

        initializes the Stretching using the boundaries with the input type array
        given for each dimension  

        Parameters:  
        * `boundaries` :  
            BoundingBox1D struct to get the boundary values for Stretching  
        * `stretching1Ds` :  
            array to define the stretching type  

    * `Stretching(dimension)`  

        Constructor for Stretching.  

        initializes the Stretching with using no stretching  

        Parameters:  
        * `dimension` :  
            number of the dimensions used with the grid  

    * `Stretching(dimension, coordinates)`  

        Constructor for Stretching.  

        initializes the Stretching using the coordinates given. (For Janos' request)  

        Parameters:  
        * `dimension` :  
            number of the dimensions used with the grid  
        * `coordinates` :  
            vector<double> array to get the boundaries, as well as the coordinates
            of the specific level the vector defines for each dimension.  

    C++ includes: Stretching.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `Stretching(boundaries, stretching1Ds)`  

            Constructor for Stretching.  

            initializes the Stretching using the boundaries with the input type array
            given for each dimension  

            Parameters:  
            * `boundaries` :  
                BoundingBox1D struct to get the boundary values for Stretching  
            * `stretching1Ds` :  
                array to define the stretching type  

        * `Stretching(dimension)`  

            Constructor for Stretching.  

            initializes the Stretching with using no stretching  

            Parameters:  
            * `dimension` :  
                number of the dimensions used with the grid  

        * `Stretching(dimension, coordinates)`  

            Constructor for Stretching.  

            initializes the Stretching using the coordinates given. (For Janos' request)  

            Parameters:  
            * `dimension` :  
                number of the dimensions used with the grid  
            * `coordinates` :  
                vector<double> array to get the boundaries, as well as the coordinates
                of the specific level the vector defines for each dimension.  

        """
        _pysgpp_swig.Stretching_swiginit(self, _pysgpp_swig.new_Stretching(*args))
    __swig_destroy__ = _pysgpp_swig.delete_Stretching

    def getCoordinate(self, level: "sgpp::base::level_t", index: "sgpp::base::index_t", d: "size_t") -> "double":
        r"""


        """
        return _pysgpp_swig.Stretching_getCoordinate(self, level, index, d)

    def getStretching1D(self, d: "size_t") -> "sgpp::base::Stretching1D const &":
        r"""


        """
        return _pysgpp_swig.Stretching_getStretching1D(self, d)

    def printLookupTable(self) -> "void":
        r"""


        """
        return _pysgpp_swig.Stretching_printLookupTable(self)

    def getAdjacentPositions(self, level: "sgpp::base::level_t", index: "sgpp::base::index_t", d: "size_t", posc: "double &", posl: "double &", posr: "double &") -> "void":
        r"""


        """
        return _pysgpp_swig.Stretching_getAdjacentPositions(self, level, index, d, posc, posl, posr)

    def getStretchingMode(self) -> "std::string":
        r"""


        """
        return _pysgpp_swig.Stretching_getStretchingMode(self)

    def getDiscreteVector(self, bSort: "bool") -> "std::vector< double,std::allocator< double > > *":
        r"""


        """
        return _pysgpp_swig.Stretching_getDiscreteVector(self, bSort)

    def getDiscreteVectorLevel(self) -> "std::vector< sgpp::base::level_t,std::allocator< sgpp::base::level_t > >":
        r"""


        """
        return _pysgpp_swig.Stretching_getDiscreteVectorLevel(self)

    def calculateNeighborLookup(self, maxlevel: "sgpp::base::level_t") -> "void":
        r"""


        """
        return _pysgpp_swig.Stretching_calculateNeighborLookup(self, maxlevel)

    def serialize(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `serialize(version=SERIALIZATION_VERSION) -> std::string`  

            Serialize the Stretching into a string.  

            Parameters:  
            * `version` :  
                the serialization version of the file  

            Returns:
            string that contains all Stretching information  

        * `serialize(ostream, version=SERIALIZATION_VERSION)`  

            Serialize the Stretching into a stream.  

            Parameters:  
            * `ostream` :  
                reference to a stream into that all Stretching information is written  
            * `version` :  
                the serialization version of the file  

        """
        return _pysgpp_swig.Stretching_serialize(self, *args)

    def unserialize(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `unserialize(istr, mode, version)`  

            Unserialize from a string.  

            Parameters:  
            * `istr` :  
                string which contains a serialized Stretching  
            * `mode` :  
                stretching mode ("analytic" or "discrete")  
            * `version` :  
                the serialization version of the file  

        * `unserialize(istr, mode, version)`  

            Unserialize from a stream.  

            Parameters:  
            * `istr` :  
                stream which contains a serialized Stretching  
            * `mode` :  
                stretching mode ("analytic" or "discrete")  
            * `version` :  
                the serialization version of the file  

        """
        return _pysgpp_swig.Stretching_unserialize(self, *args)

# Register Stretching in _pysgpp_swig:
_pysgpp_swig.Stretching_swigregister(Stretching)

SERIALIZATION_VERSION = _pysgpp_swig.SERIALIZATION_VERSION
class HashGridPoint(object):
    r"""

    `HashGridPoint()`  
    `HashGridPoint(o)`  
    `HashGridPoint(dimension)`  
    `HashGridPoint(istream, version)`  

    This Class represents one Gridpoint.  

    A Gridpoint is given by its ansatzfunctions that are not zero in every
    dimension. Instances of this class are members in the hashmap that represents
    the whole grid.  

    Constructors
    ------------
    * `HashGridPoint()`  

        Standard-Constructor.  

    * `HashGridPoint(o)`  

        Copy-Constructor.  

        Parameters:  
        * `o` :  
            constant reference to HashGridPoint object  

    * `HashGridPoint(dimension)`  

        Constructor of a n-Dim gridpoint.  

        Parameters:  
        * `dimension` :  
            the dimension of the gridpoint  

    * `HashGridPoint(istream, version)`  

        Serialisation-Constructor.  

        Parameters:  
        * `istream` :  
            instream object the contains the information about the gridpoint  
        * `version` :  
            the serialization version of the file  

    C++ includes: HashGridPoint.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `HashGridPoint()`  

            Standard-Constructor.  

        * `HashGridPoint(o)`  

            Copy-Constructor.  

            Parameters:  
            * `o` :  
                constant reference to HashGridPoint object  

        * `HashGridPoint(dimension)`  

            Constructor of a n-Dim gridpoint.  

            Parameters:  
            * `dimension` :  
                the dimension of the gridpoint  

        * `HashGridPoint(istream, version)`  

            Serialisation-Constructor.  

            Parameters:  
            * `istream` :  
                instream object the contains the information about the gridpoint  
            * `version` :  
                the serialization version of the file  

        """
        _pysgpp_swig.HashGridPoint_swiginit(self, _pysgpp_swig.new_HashGridPoint(*args))
    __swig_destroy__ = _pysgpp_swig.delete_HashGridPoint

    def serialize(self, ostream: "std::ostream &", version: "int") -> "void":
        r"""


        Serialize this Gridpoint e.g.  

        for a storage or checkpointing  

        Parameters
        ----------
        * `ostream` :  
            outstream object to which the gridpoint's information is written  
        * `version` :  
            the serialization version of the file  

        """
        return _pysgpp_swig.HashGridPoint_serialize(self, ostream, version)

    def getDimension(self) -> "size_t":
        r"""


        Gets the dimension of the gridpoint.  

        Returns
        -------
        the dimension of the gridpoint  

        """
        return _pysgpp_swig.HashGridPoint_getDimension(self)

    def set(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `set(d, l, i)`  

            Sets level *l* and index *i* in dimension *d* and rehashs the HashGridPoint
            object.  

            Parameters:  
            * `d` :  
                the dimension in which the ansatzfunction is set  
            * `l` :  
                the level of the ansatzfunction  
            * `i` :  
                the index of the ansatzfunction  

        * `set(d, l, i, isLeaf)`  

            Sets level *l* and index *i* in dimension *d* and the Leaf property and
            rehashs the HashGridPoint object.  

            Parameters:  
            * `d` :  
                the dimension in which the ansatzfunction is set  
            * `l` :  
                the level of the ansatzfunction  
            * `i` :  
                the index of the ansatzfunction  
            * `isLeaf` :  
                specifies if this gridpoint has any childrens in any dimension  

        """
        return _pysgpp_swig.HashGridPoint_set(self, *args)

    def push(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `push(d, l, i)`  

            Sets level *l* and index *i* in dimension *d* and doesn't rehash the
            HashGridPoint object.  

            Parameters:  
            * `d` :  
                the dimension in which the ansatzfunction is set  
            * `l` :  
                the level of the ansatzfunction  
            * `i` :  
                the index of the ansatzfunction  

        * `push(d, l, i, isLeaf)`  

            Sets level *l* and index *i* in dimension *d* and the Leaf property and
            doesn't rehash the HashGridPoint object.  

            Parameters:  
            * `d` :  
                the dimension in which the ansatzfunction is set  
            * `l` :  
                the level of the ansatzfunction  
            * `i` :  
                the index of the ansatzfunction  
            * `isLeaf` :  
                specifies if this gridpoint has any childrens in any dimension  

        """
        return _pysgpp_swig.HashGridPoint_push(self, *args)

    def get(self, d: "size_t") -> "void":
        r"""


        gets level *l* and index *i* in dimension *d* by reference parameters  

        Parameters
        ----------
        * `d` :  
            the dimension in which the ansatz function should be read  
        * `l` :  
            reference parameter for the level of the ansatz function  
        * `i` :  
            reference parameter for the index of the ansatz function  

        """
        return _pysgpp_swig.HashGridPoint_get(self, d)

    def getLevel(self, d: "size_t") -> "sgpp::base::HashGridPoint::level_type":
        r"""


        gets level *l* in dimension *d*  

        Parameters
        ----------
        * `d` :  
            the dimension in which the ansatz function should be read  

        Returns
        -------
        level  

        """
        return _pysgpp_swig.HashGridPoint_getLevel(self, d)

    def getIndex(self, d: "size_t") -> "sgpp::base::HashGridPoint::index_type":
        r"""


        gets index *i* in dimension *d*  

        Parameters
        ----------
        * `d` :  
            the dimension in which the ansatz function should be read  

        Returns
        -------
        index  

        """
        return _pysgpp_swig.HashGridPoint_getIndex(self, d)

    def setLeaf(self, isLeaf: "bool") -> "void":
        r"""


        Set the leaf property; a grid point is called a leaf, if it has **not a single**
        child.  

        Parameters
        ----------
        * `isLeaf` :  
            specifies if the current index is a leaf (i.e. has **no** child nodes) or
            not  

        """
        return _pysgpp_swig.HashGridPoint_setLeaf(self, isLeaf)

    def isLeaf(self) -> "bool":
        r"""


        Checks if this grid point has **not a single** child in any dimension.  

        Returns
        -------
        Returns true if this grid point has **no** children, otherwise false  

        """
        return _pysgpp_swig.HashGridPoint_isLeaf(self)

    def getStandardCoordinate(self, d: "size_t") -> "double":
        r"""


        determines the coordinate in a given dimension "Standard" means no bounding
        box (i.e., the domain is the unit hypercube) and no stretching (i.e., the points
        have the standard locations $i \cdot 2^{-\ell}$).  

        Parameters
        ----------
        * `d` :  
            the dimension in which the coordinate should be calculated  

        Returns
        -------
        the coordinate in the given dimension  

        """
        return _pysgpp_swig.HashGridPoint_getStandardCoordinate(self, d)

    def getStandardCoordinates(self, coordinates: "DataVector") -> "void":
        r"""


        Sets the entries of DataVector p to the coordinates of the gridpoint
        "Standard" means no bounding box (i.e., the domain is the unit hypercube) and
        no stretching (i.e., the points have the standard locations $i \cdot
        2^{-\ell}$).  

        Parameters
        ----------
        * `coordinates` :  
            the DataVector that should be overwritten with the coordinates  

        """
        return _pysgpp_swig.HashGridPoint_getStandardCoordinates(self, coordinates)

    def isInnerPoint(self) -> "bool":
        r"""


        Determines if the grid point is an inner grid point.  

        Inner points are exactly those points which are not on the boundary in any
        dimension.  

        Returns
        -------
        true if the grid point is an inner grid point  

        """
        return _pysgpp_swig.HashGridPoint_isInnerPoint(self)

    def rehash(self) -> "void":
        r"""


        rehashs the current gridpoint and sets hInv  

        """
        return _pysgpp_swig.HashGridPoint_rehash(self)

    def getHash(self) -> "size_t":
        r"""


        gets the hash value of the current instance  

        Returns
        -------
        the hash value of the instance  

        """
        return _pysgpp_swig.HashGridPoint_getHash(self)

    def equals(self, rhs: "HashGridPoint") -> "bool":
        r"""


        checks whether this gridpoints is identical to another one  

        Running under WINDOW this is defined the way around, MSDN 2009: A binary
        predicate f(x,y) is a function object that has two argument objects x and y and
        a return value of true or false. An ordering imposed on a hash_map is a strict
        weak ordering if the binary predicate is irreflexive, antisymmetric, and
        transitive and if equivalence is transitive, where two objects x and y are
        defined to be equivalent when both f(x,y) and f(y,x) are false ->
        equalsSGLRBHash  

        Parameters
        ----------
        * `rhs` :  
            reference the another HashGridPoint instance  

        Returns
        -------
        true if the gridpoints are identical otherwise false  

        """
        return _pysgpp_swig.HashGridPoint_equals(self, rhs)

    def assign(self, rhs: "HashGridPoint") -> "sgpp::base::HashGridPoint &":
        r"""


        A wrapper for operator=.  

        Parameters
        ----------
        * `rhs` :  
            a reference to a HashGridPoint that contains the values that should be
            copied  

        Returns
        -------
        returns a reference HashGridPoint  

        """
        return _pysgpp_swig.HashGridPoint_assign(self, rhs)

    def toString(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `toString() -> std::string`  

            Generates a string with level and index of the gridpoint.  

            The format is `[l1, i1, l2, i2, ..., ld, id]`. Needed for Java
            compatibility.  

            Returns:
            string into which the gridpoint is written  

        * `toString(stream)`  

            Generates a string with level and index of the gridpoint.  

            The format is `[l1, i1, l2, i2, ..., ld, id]`.  

            Parameters:  
            * `stream` :  
                reference to a output stream  

        """
        return _pysgpp_swig.HashGridPoint_toString(self, *args)

    def getLevelSum(self) -> "sgpp::base::HashGridPoint::level_type":
        r"""


        Returns the sum of the one-dimensional levels, i.e., $ |\vec{l}|_1 $.  

        Returns
        -------
        the sum of the one-dimensional levels  

        """
        return _pysgpp_swig.HashGridPoint_getLevelSum(self)

    def getLevelMax(self) -> "sgpp::base::HashGridPoint::level_type":
        r"""


        Returns the maximum of the one-dimensional levels, i.e., $ |\vec{l}|_\infty $.  

        Returns
        -------
        the maximum of the one-dimensional levels  

        """
        return _pysgpp_swig.HashGridPoint_getLevelMax(self)

    def getLevelMin(self) -> "sgpp::base::HashGridPoint::level_type":
        r"""


        Returns the minimum of the one-dimensional levels.  

        Returns
        -------
        the minimum of the one-dimensional levels  

        """
        return _pysgpp_swig.HashGridPoint_getLevelMin(self)

    def getLeftLevelZero(self, dim: "size_t") -> "void":
        r"""


        Sets the index to the left level zero parent.  

        Parameters
        ----------
        * `dim` :  
            the dimension in which the modification is taken place  

        """
        return _pysgpp_swig.HashGridPoint_getLeftLevelZero(self, dim)

    def getRightLevelZero(self, dim: "size_t") -> "void":
        r"""


        Sets the index to the right level zero parent.  

        Parameters
        ----------
        * `dim` :  
            the dimension in which the modification is taken place  

        """
        return _pysgpp_swig.HashGridPoint_getRightLevelZero(self, dim)

    def getLeftChild(self, dim: "size_t") -> "void":
        r"""


        Sets the index to the left child.  

        Parameters
        ----------
        * `dim` :  
            the dimension in which the modification is taken place  

        """
        return _pysgpp_swig.HashGridPoint_getLeftChild(self, dim)

    def getRightChild(self, dim: "size_t") -> "void":
        r"""


        Sets the index to the right child.  

        Parameters
        ----------
        * `dim` :  
            the dimension in which the modification is taken place  

        """
        return _pysgpp_swig.HashGridPoint_getRightChild(self, dim)

    def getRoot(self, d: "size_t") -> "void":
        r"""


        Resets the index to the top level in direction d.  

        Parameters
        ----------
        * `d` :  
            the dimension in which the modification is taken place  

        """
        return _pysgpp_swig.HashGridPoint_getRoot(self, d)

    def getParent(self, dim: "size_t") -> "void":
        r"""


        Sets the index to the parent WARNING: this just works for grids without
        boundaries.  

        Parameters
        ----------
        * `dim` :  
            the dimension in which the modification is taken place  

        """
        return _pysgpp_swig.HashGridPoint_getParent(self, dim)

    def getRightBoundaryPoint(self, dim: "size_t") -> "void":
        r"""


        Sets the index to the grid point at the right boundary of the support For
        details see http://graphics.stanford.edu/~seander/bithacks.html and
        http://supertech.csail.mit.edu/papers/debruijn.pdf WARNING: this just works
        for grids with non-overlapping basis functions at the same level and for
        uint32_t as index_type.  

        Parameters
        ----------
        * `dim` :  
            the dimension in which the modification is taken place  

        """
        return _pysgpp_swig.HashGridPoint_getRightBoundaryPoint(self, dim)

    def getLeftBoundaryPoint(self, dim: "size_t") -> "void":
        r"""


        Sets the index to the grid point at the left boundary of the support For details
        see http://graphics.stanford.edu/~seander/bithacks.html and
        http://supertech.csail.mit.edu/papers/debruijn.pdf WARNING: this just works
        for grids with non-overlapping basis functions at the same level and for
        uint32_t as index_type.  

        Parameters
        ----------
        * `dim` :  
            the dimension in which the modification is taken place  

        """
        return _pysgpp_swig.HashGridPoint_getLeftBoundaryPoint(self, dim)

    def setAsHierarchicalGridPoint(self, dim: "size_t", level: "sgpp::base::HashGridPoint::level_type", index: "sgpp::base::HashGridPoint::index_type") -> "void":
        r"""


        Sets the index to the grid point at the left boundary of the support For details
        see http://graphics.stanford.edu/~seander/bithacks.html and
        http://supertech.csail.mit.edu/papers/debruijn.pdf WARNING: this just works
        for grids with non-overlapping basis functions at the same level and for
        uint32_t as index_type.  

        Parameters
        ----------
        * `dim` :  
            the dimension in which the modification is taken place  
        * `level` :  
            level in direction dim  
        * `index` :  
            index in direction dim  

        """
        return _pysgpp_swig.HashGridPoint_setAsHierarchicalGridPoint(self, dim, level, index)

    def isHierarchicalAncestor(self, *args) -> "bool":
        r"""


        Overloaded function
        -------------------
        * `isHierarchicalAncestor(gpj) -> bool`  

            checks if this is a hierarchical ancestor of gpj  

            Parameters:  
            * `gpj` :  

            Returns:  

        * `isHierarchicalAncestor(gpj, dim) -> bool`  

            checks if this is a hierarchical ancestor of gpj in dimension dim  

            Parameters:  
            * `gpj` :  
            * `dim` :  

            Returns:  

        """
        return _pysgpp_swig.HashGridPoint_isHierarchicalAncestor(self, *args)

# Register HashGridPoint in _pysgpp_swig:
_pysgpp_swig.HashGridPoint_swigregister(HashGridPoint)

class HashGridPointPointerHashFunctor(object):
    r"""


    C++ includes: HashGridPoint.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __call__(self, index: "HashGridPoint") -> "size_t":
        return _pysgpp_swig.HashGridPointPointerHashFunctor___call__(self, index)

    def __init__(self):
        _pysgpp_swig.HashGridPointPointerHashFunctor_swiginit(self, _pysgpp_swig.new_HashGridPointPointerHashFunctor())
    __swig_destroy__ = _pysgpp_swig.delete_HashGridPointPointerHashFunctor

# Register HashGridPointPointerHashFunctor in _pysgpp_swig:
_pysgpp_swig.HashGridPointPointerHashFunctor_swigregister(HashGridPointPointerHashFunctor)

class HashGridPointPointerEqualityFunctor(object):
    r"""


    C++ includes: HashGridPoint.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __call__(self, s1: "HashGridPoint", s2: "HashGridPoint") -> "size_t":
        return _pysgpp_swig.HashGridPointPointerEqualityFunctor___call__(self, s1, s2)

    def __init__(self):
        _pysgpp_swig.HashGridPointPointerEqualityFunctor_swiginit(self, _pysgpp_swig.new_HashGridPointPointerEqualityFunctor())
    __swig_destroy__ = _pysgpp_swig.delete_HashGridPointPointerEqualityFunctor

# Register HashGridPointPointerEqualityFunctor in _pysgpp_swig:
_pysgpp_swig.HashGridPointPointerEqualityFunctor_swigregister(HashGridPointPointerEqualityFunctor)

class HashGridPointHashFunctor(object):
    r"""


    C++ includes: HashGridPoint.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __call__(self, index: "HashGridPoint") -> "size_t":
        return _pysgpp_swig.HashGridPointHashFunctor___call__(self, index)

    def __init__(self):
        _pysgpp_swig.HashGridPointHashFunctor_swiginit(self, _pysgpp_swig.new_HashGridPointHashFunctor())
    __swig_destroy__ = _pysgpp_swig.delete_HashGridPointHashFunctor

# Register HashGridPointHashFunctor in _pysgpp_swig:
_pysgpp_swig.HashGridPointHashFunctor_swigregister(HashGridPointHashFunctor)

class HashGridPointEqualityFunctor(object):
    r"""


    C++ includes: HashGridPoint.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __call__(self, s1: "HashGridPoint", s2: "HashGridPoint") -> "size_t":
        return _pysgpp_swig.HashGridPointEqualityFunctor___call__(self, s1, s2)

    def __init__(self):
        _pysgpp_swig.HashGridPointEqualityFunctor_swiginit(self, _pysgpp_swig.new_HashGridPointEqualityFunctor())
    __swig_destroy__ = _pysgpp_swig.delete_HashGridPointEqualityFunctor

# Register HashGridPointEqualityFunctor in _pysgpp_swig:
_pysgpp_swig.HashGridPointEqualityFunctor_swigregister(HashGridPointEqualityFunctor)

class HashGridStorage(object):
    r"""

    `HashGridStorage(creationBoundingBox)`  
    `HashGridStorage(copyFrom)`  
    `HashGridStorage(dimension)`  
    `HashGridStorage(istream)`  
    `HashGridStorage(istr)`  
    `HashGridStorage(creationStretching)`  

    Generic hash table based storage of grid points.  

    Constructors
    ------------
    * `HashGridStorage(creationBoundingBox)`  

        Constructor.  

        initializes the boundingBox with a reference to another boundingbox  

        Parameters:  
        * `creationBoundingBox` :  
            reference to bounding box object that describes the grid boundaries  

    * `HashGridStorage(copyFrom)`  

        Copy Constructor.  

    * `HashGridStorage(dimension)`  

        Constructor.  

        initializes the boundingBox with a trivial cube  

        Parameters:  
        * `dimension` :  
            the dimension of the sparse grid  

    * `HashGridStorage(istream)`  

        Constructor that reads the data from an input stream.  

        Parameters:  
        * `istream` :  
            the inputstream that contains the data  

    * `HashGridStorage(istr)`  

        Constructor that reads the data from a string.  

        Parameters:  
        * `istr` :  
            the string that contains the data  

    * `HashGridStorage(creationStretching)`  

        Constructor.  

        initializes the stretching with a reference to another stretching  

        Parameters:  
        * `creationStretching` :  
            reference to stretching object that describes the grid boundaries and
            the stretching  

    C++ includes: HashGridStorage.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `HashGridStorage(creationBoundingBox)`  

            Constructor.  

            initializes the boundingBox with a reference to another boundingbox  

            Parameters:  
            * `creationBoundingBox` :  
                reference to bounding box object that describes the grid boundaries  

        * `HashGridStorage(copyFrom)`  

            Copy Constructor.  

        * `HashGridStorage(dimension)`  

            Constructor.  

            initializes the boundingBox with a trivial cube  

            Parameters:  
            * `dimension` :  
                the dimension of the sparse grid  

        * `HashGridStorage(istream)`  

            Constructor that reads the data from an input stream.  

            Parameters:  
            * `istream` :  
                the inputstream that contains the data  

        * `HashGridStorage(istr)`  

            Constructor that reads the data from a string.  

            Parameters:  
            * `istr` :  
                the string that contains the data  

        * `HashGridStorage(creationStretching)`  

            Constructor.  

            initializes the stretching with a reference to another stretching  

            Parameters:  
            * `creationStretching` :  
                reference to stretching object that describes the grid boundaries and
                the stretching  

        """
        _pysgpp_swig.HashGridStorage_swiginit(self, _pysgpp_swig.new_HashGridStorage(*args))
    __swig_destroy__ = _pysgpp_swig.delete_HashGridStorage

    def clear(self) -> "void":
        r"""


        deletes all grid points in the storage  

        """
        return _pysgpp_swig.HashGridStorage_clear(self)

    def deletePoints(self, removePoints: "SizeList") -> "std::vector< size_t,std::allocator< size_t > >":
        r"""


        Remove several point from HashGridStorage.  

        The points to removed are stored in a list. This function returns a vector of
        remaining points given by their  

        Parameters
        ----------
        * `removePoints` :  
            vector containing the indices of the points that should be removed  

        Returns
        -------
        a vector containing the indices of remaining points given by their "old" index  

        """
        return _pysgpp_swig.HashGridStorage_deletePoints(self, removePoints)

    def unserializeNoAlgoDims(self, istr: "std::string &") -> "void":
        r"""


        unserializes the grid from a string, algorithmic dimensions are not reseted  

        Parameters
        ----------
        * `istr` :  
            the string that contains the data  

        """
        return _pysgpp_swig.HashGridStorage_unserializeNoAlgoDims(self, istr)

    def serialize(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `serialize(version=SERIALIZATION_VERSION) -> std::string`  

            serialize the gridstorage into a string  

            Parameters:  
            * `version` :  
                the serialization version of the file  

            Returns:
            a string that contains all gridstorage information  

        * `serialize(ostream, version=SERIALIZATION_VERSION)`  

            serialize the gridstorage into a stream  

            Parameters:  
            * `ostream` :  
                reference to a stream into that all gridstorage information is written  
            * `version` :  
                the serialization version of the file  

        """
        return _pysgpp_swig.HashGridStorage_serialize(self, *args)

    def toString(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `toString() -> std::string`  

            serialize the gridstorage's gridpoints into a stream  

            Returns:
            returns the string that contains all gridpoint information  

        * `toString(stream)`  

            serialize the gridstorage's gridpoints into a stream  

            Parameters:  
            * `stream` :  
                reference to a stream into that all gridpoint information is written  

        """
        return _pysgpp_swig.HashGridStorage_toString(self, *args)

    def getSize(self) -> "size_t":
        r"""


        gets the size of the hashmap  

        Returns
        -------
        returns the size of the hashmap  

        """
        return _pysgpp_swig.HashGridStorage_getSize(self)

    def getNumberOfInnerPoints(self) -> "size_t":
        r"""


        gets the number of inner grid points  

        Returns
        -------
        the number of inner grid points  

        """
        return _pysgpp_swig.HashGridStorage_getNumberOfInnerPoints(self)

    def getDimension(self) -> "size_t":
        r"""


        gets the dimension of the grid  

        Returns
        -------
        the dimension of the grid stored in this HashGridStorage object  

        """
        return _pysgpp_swig.HashGridStorage_getDimension(self)

    def getPoint(self, seq: "size_t") -> "sgpp::base::HashGridPoint &":
        r"""


        gets the index number for given gridpoint by its sequence number  

        Parameters
        ----------
        * `seq` :  
            the sequence number of the index  

        Returns
        -------
        gridpoint object (pointer)  

        """
        return _pysgpp_swig.HashGridStorage_getPoint(self, seq)

    def insert(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `insert(index) -> size_t`  

            insert a new index into map  

            Parameters:  
            * `index` :  
                reference to the index that should be inserted  

            Returns:  

        * `insert(index, insertedPoints)`  

            insert a new index into map including all its ancestors.  

            Boundary points are not added  

            Parameters:  
            * `index` :  
                reference to the index that should be inserted  
            * `insertedPoints` :  
                containing the indices of the new points  

            Returns:  

        """
        return _pysgpp_swig.HashGridStorage_insert(self, *args)

    def update(self, index: "HashGridPoint", pos: "size_t") -> "void":
        r"""


        updates an already stored index  

        Parameters
        ----------
        * `index` :  
            reference to the index that should be updated  
        * `pos` :  
            position where the index should be stored  

        """
        return _pysgpp_swig.HashGridStorage_update(self, index, pos)

    def deleteLast(self) -> "void":
        r"""


        This methods removes the gridpoint added last.  

        Use with coution, only needed for expanding the grid because of the shadow-
        storage of prewavelets. Please refer to the Prewavelet grid for further
        description of the shadow storage.  

        """
        return _pysgpp_swig.HashGridStorage_deleteLast(self)

    def create(self, index: "HashGridPoint") -> "sgpp::base::HashGridStorage::point_pointer":
        r"""


        creates a pointer to index from a reference to index by creating a new instance
        of a index object  

        Parameters
        ----------
        * `index` :  
            address of index object  

        Returns
        -------
        pointer to new index object  

        """
        return _pysgpp_swig.HashGridStorage_create(self, index)

    def destroy(self, index: "HashGridPoint") -> "void":
        r"""


        removes an index from gridstorage  

        Parameters
        ----------
        * `index` :  
            pointer to index that should be removed  

        """
        return _pysgpp_swig.HashGridStorage_destroy(self, index)

    def store(self, index: "HashGridPoint") -> "unsigned int":
        r"""


        stores a given index in the hashmap  

        Parameters
        ----------
        * `index` :  
            pointer to index that should be stored  

        Returns
        -------
        sequence number  

        """
        return _pysgpp_swig.HashGridStorage_store(self, index)

    def find(self, index: "HashGridPoint") -> "sgpp::base::HashGridStorage::grid_map_iterator":
        r"""


        sets the iterator to a given index  

        Parameters
        ----------
        * `index` :  
            the index to which the cursor should be moved  

        Returns
        -------
        iterator pointing to the index  

        """
        return _pysgpp_swig.HashGridStorage_find(self, index)

    def begin(self) -> "sgpp::base::HashGridStorage::grid_map_iterator":
        r"""


        set iterator to the first position in the map  

        Returns
        -------
        iterator pointing to the beginning of the map  

        """
        return _pysgpp_swig.HashGridStorage_begin(self)

    def end(self) -> "sgpp::base::HashGridStorage::grid_map_iterator":
        r"""


        sets the iterator to last position in the map  

        Returns
        -------
        iterator pointing to the end of the map  

        """
        return _pysgpp_swig.HashGridStorage_end(self)

    def isContaining(self, index: "HashGridPoint") -> "bool":
        r"""


        Tests if index is in the storage.  

        Parameters
        ----------
        * `index` :  
            pointer to index that should be tested  

        Returns
        -------
        true if the index is in the storage  

        """
        return _pysgpp_swig.HashGridStorage_isContaining(self, index)

    def getSequenceNumber(self, index: "HashGridPoint") -> "size_t":
        r"""


        Gets the seq number for index.  

        Parameters
        ----------
        * `index` :  
            pointer to index which sequence number should be determined  

        Returns
        -------
        the seq number for index  

        """
        return _pysgpp_swig.HashGridStorage_getSequenceNumber(self, index)

    def isInvalidSequenceNumber(self, s: "size_t") -> "bool":
        r"""


        Tests if seq number does not point to a valid grid point.  

        Parameters
        ----------
        * `s` :  
            sequence number that should be tested  

        Returns
        -------
        true if we are not EOF  

        """
        return _pysgpp_swig.HashGridStorage_isInvalidSequenceNumber(self, s)

    def getAlgorithmicDimensions(self) -> "std::vector< size_t,std::allocator< size_t > >":
        r"""


        returns the algorithmic dimensions (the dimensions in which the Up Down
        operations should be applied)  

        Returns
        -------
        the algorithmic dimensions  

        """
        return _pysgpp_swig.HashGridStorage_getAlgorithmicDimensions(self)

    def setAlgorithmicDimensions(self, newAlgoDims: "SizeVector") -> "void":
        r"""


        sets the algorithmic dimensions (the dimensions in which the Up Down operations
        should be applied)  

        Parameters
        ----------
        * `newAlgoDims` :  
            std::vector containing the algorithmic dimensions  

        """
        return _pysgpp_swig.HashGridStorage_setAlgorithmicDimensions(self, newAlgoDims)

    def recalcLeafProperty(self) -> "void":
        r"""


        Recalculates the leaf-property of every grid point.  

        This might be useful in case of a grid unserialization  

        """
        return _pysgpp_swig.HashGridStorage_recalcLeafProperty(self)

    def getBoundingBox(self) -> "sgpp::base::BoundingBox *":
        r"""


        get the bounding box of the current grid  

        Returns
        -------
        returns a pointer to HashGridStorage's bounding box  

        """
        return _pysgpp_swig.HashGridStorage_getBoundingBox(self)

    def getStretching(self) -> "sgpp::base::Stretching *":
        r"""


        get the stretching bounding box of the current grid  

        Returns
        -------
        returns a pointer to HashGridStorage's bounding box  

        """
        return _pysgpp_swig.HashGridStorage_getStretching(self)

    def setBoundingBox(self, boundingBox: "BoundingBox") -> "void":
        r"""


        sets the bounding box of the current grid  

        Parameters
        ----------
        * `boundingBox` :  
            bounding box to which the HashGridStorage's pointer is set  

        """
        return _pysgpp_swig.HashGridStorage_setBoundingBox(self, boundingBox)

    def setStretching(self, stretching: "Stretching") -> "void":
        r"""


        sets the stretching bounding box of the current grid  

        Parameters
        ----------
        * `stretching` :  
            stretching to which the HashGridStorage's pointer is set  

        """
        return _pysgpp_swig.HashGridStorage_setStretching(self, stretching)

    def getLevelIndexArraysForEval(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `getLevelIndexArraysForEval(level, index)`  

            Converts this storage from AOS (array of structures) to SOA (structure of
            array) with modification to speed up iterative function evaluation.  

            The Level array won't contain the levels, it contains the level to the power
            of two  

            Parameters:  
            * `level` :  
                DataMatrix to store the grid's level to the power of two  
            * `index` :  
                DataMatrix to store the grid's indices  

        * `getLevelIndexArraysForEval(level, index)`  

            Converts this storage from AOS (array of structures) to SOA (structure of
            array) with modification to speed up iterative function evaluation.  

            The Level array won't contain the levels, it contains the level to the power
            of two  

            Parameters:  
            * `level` :  
                DataMatrix to store the grid's level to the power of two  
            * `index` :  
                DataMatrix to store the grid's indices  

        """
        return _pysgpp_swig.HashGridStorage_getLevelIndexArraysForEval(self, *args)

    def getLevelForIntegral(self, level: "DataMatrix") -> "void":
        r"""


        Converts this storage from AOS (array of structures) to SOA (structure of array)
        with modification to speed up iterative Laplace Calculations: the level won't
        contain the levels, it contains 2 to the neagative power of the level.  

        Parameters
        ----------
        * `level` :  
            DataMatrix to store the grid's modified level  

        """
        return _pysgpp_swig.HashGridStorage_getLevelForIntegral(self, level)

    def getCoordinateArrays(self, coordinates: "DataMatrix") -> "void":
        r"""


        Converts this storage from AOS (array of structures) to SOA (structure of array)
        to speed up operations on the position of the grid points.  

        Parameters
        ----------
        * `coordinates` :  
            DataMatrix to store the coordinates of the grid points  

        """
        return _pysgpp_swig.HashGridStorage_getCoordinateArrays(self, coordinates)

    def getMaxLevel(self) -> "size_t":
        r"""


        returns the max.  

        depth in all dimension of the grid  

        """
        return _pysgpp_swig.HashGridStorage_getMaxLevel(self)

    def getLevelIndexMaskArraysForModEval(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `getLevelIndexMaskArraysForModEval(level, index, mask, offset)`  

            Converts this storage from AOS (array of structures) to SOA (structure of
            array) with modification to speed up iterative function evaluation.  

            The Level array won't contain the levels, it contains the level to the power
            of two.  

            The returned format is only useful for a multi-evaluation of modlinear grids  

            Parameters:  
            * `level` :  
                DataMatrix to store the grid's level to the power of two  
            * `index` :  
                DataMatrix to store the grid's indices  
            * `mask` :  
                DataMatrix to store masks of operations  
            * `offset` :  
                DataMatrix to store offset for operations  

        * `getLevelIndexMaskArraysForModEval(level, index, mask, offset)`  

            Converts this storage from AOS (array of structures) to SOA (structure of
            array) with modification to speed up iterative function evaluation.  

            The Level array won't contain the levels, it contains the level to the power
            of two.  

            The returned format is only useful for a multi-evaluation of modlinear grids  

            Parameters:  
            * `level` :  
                DataMatrixSP to store the grid's level to the power of two  
            * `index` :  
                DataMatrixSP to store the grid's indices  
            * `mask` :  
                DataMatrixSP to store masks of operations  
            * `offset` :  
                DataMatrixSP to store offset for operations  

        """
        return _pysgpp_swig.HashGridStorage_getLevelIndexMaskArraysForModEval(self, *args)

    def getCoordinate(self, point: "HashGridPoint", d: "size_t") -> "double":
        r"""


        Calculates the coordinate of a given grid point in specific dimension.  

        In contrast to HashGridPoint::getStandardCoordinate, this takes the BoundingBox
        and Stretching into account.  

        Parameters
        ----------
        * `point` :  
            grid point  
        * `d` :  
            dimension  

        Returns
        -------
        coordinate of the point in dimension d  

        """
        return _pysgpp_swig.HashGridStorage_getCoordinate(self, point, d)

    def getUnitCoordinate(self, point: "HashGridPoint", d: "size_t") -> "double":
        r"""


        Calculates corresponding unit hypercube coordinate of a given point in specific
        dimension, taking into account the BoundingBox and Stretching.  

        """
        return _pysgpp_swig.HashGridStorage_getUnitCoordinate(self, point, d)

    def getCoordinates(self, *args) -> "sgpp::base::DataVector":
        r"""


        Overloaded function
        -------------------
        * `getCoordinates(point) -> DataVector`  

            Calculates the coordinates of a given grid point.  

            In contrast to HashGridPoint::getStandardCoordinates, this takes the
            BoundingBox and Stretching into account.  

            Parameters:  
            * `point` :  
                grid point  

            Returns:
            vector of coordinates  

        * `getCoordinates(point, coordinates)`  

            Calculates the coordinates of a given grid point.  

            In contrast to HashGridPoint::getStandardCoordinates, this takes the
            BoundingBox and Stretching into account.  

            Parameters:  
            * `point` :  
                grid point  
            * `coordinates` :  
                vector of coordinates  

        """
        return _pysgpp_swig.HashGridStorage_getCoordinates(self, *args)

# Register HashGridStorage in _pysgpp_swig:
_pysgpp_swig.HashGridStorage_swigregister(HashGridStorage)

class HashGridIterator(object):
    r"""

    `HashGridIterator(copy)`  
    `HashGridIterator(storage)`  

    This class can be used for storage agnostic algorithms.  

    GridPoint has to support: constructor, get, set, push, rehash  

    Constructors
    ------------
    * `HashGridIterator(copy)`  

        Copy Constructor of the griditerator object.  

        Parameters:  
        * `copy` :  
            a HashGridIterator object that is used to build this instance  

    * `HashGridIterator(storage)`  

        Constructor of the griditerator object.  

        Parameters:  
        * `storage` :  
            reference to the hashmap that stores the grid points  

    C++ includes: HashGridIterator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `HashGridIterator(copy)`  

            Copy Constructor of the griditerator object.  

            Parameters:  
            * `copy` :  
                a HashGridIterator object that is used to build this instance  

        * `HashGridIterator(storage)`  

            Constructor of the griditerator object.  

            Parameters:  
            * `storage` :  
                reference to the hashmap that stores the grid points  

        """
        _pysgpp_swig.HashGridIterator_swiginit(self, _pysgpp_swig.new_HashGridIterator(*args))
    __swig_destroy__ = _pysgpp_swig.delete_HashGridIterator

    def resetToLevelZero(self) -> "void":
        r"""


        Sets 0,0 in every dimension (Left Level zero ansatzfunction)  

        """
        return _pysgpp_swig.HashGridIterator_resetToLevelZero(self)

    def resetToLeftLevelZero(self, dim: "size_t") -> "void":
        r"""


        left level zero ansatz function for a given dimension  

        Parameters
        ----------
        * `dim` :  
            dimension in which we should step to level zero  

        """
        return _pysgpp_swig.HashGridIterator_resetToLeftLevelZero(self, dim)

    def resetToRightLevelZero(self, dim: "size_t") -> "void":
        r"""


        right level zero ansatz function for a given dimension  

        Parameters
        ----------
        * `dim` :  
            dimension in which we should step to level zero  

        """
        return _pysgpp_swig.HashGridIterator_resetToRightLevelZero(self, dim)

    def resetToLevelOne(self, d: "size_t") -> "void":
        r"""


        resets the iterator to the top if dimension d  

        Parameters
        ----------
        * `d` :  
            the moving direction  

        """
        return _pysgpp_swig.HashGridIterator_resetToLevelOne(self, d)

    def leftChild(self, dim: "size_t") -> "void":
        r"""


        left child in direction dim  

        Parameters
        ----------
        * `dim` :  
            dimension in which we should step to the left child  

        """
        return _pysgpp_swig.HashGridIterator_leftChild(self, dim)

    def rightChild(self, dim: "size_t") -> "void":
        r"""


        right child in direction dim  

        Parameters
        ----------
        * `dim` :  
            dimension in which we should step to the right child  

        """
        return _pysgpp_swig.HashGridIterator_rightChild(self, dim)

    def up(self, d: "size_t") -> "void":
        r"""


        hierarchical parent in direction dim  

        Parameters
        ----------
        * `d` :  
            the moving direction  

        """
        return _pysgpp_swig.HashGridIterator_up(self, d)

    def stepLeft(self, d: "size_t") -> "void":
        r"""


        step left in direction dim  

        Parameters
        ----------
        * `d` :  
            the moving direction  

        """
        return _pysgpp_swig.HashGridIterator_stepLeft(self, d)

    def stepRight(self, d: "size_t") -> "void":
        r"""


        step right in direction dim  

        Parameters
        ----------
        * `d` :  
            the moving direction  

        """
        return _pysgpp_swig.HashGridIterator_stepRight(self, d)

    def isInnerPoint(self) -> "bool":
        r"""


        determines if the grid point is an inner grid point  

        Returns
        -------
        true if the grid point is an inner grid point  

        """
        return _pysgpp_swig.HashGridIterator_isInnerPoint(self)

    def hint(self) -> "bool":
        r"""


        returns true if there are no more children in any dimension  

        Returns
        -------
        returns true if there are no more children in any dimension  

        """
        return _pysgpp_swig.HashGridIterator_hint(self)

    def hintLeft(self, d: "size_t") -> "bool":
        r"""


        returns true if there are more left children in dimension d  

        Parameters
        ----------
        * `d` :  
            the moving direction  

        Returns
        -------
        true if there are more left children in dimension d  

        """
        return _pysgpp_swig.HashGridIterator_hintLeft(self, d)

    def hintRight(self, d: "size_t") -> "bool":
        r"""


        returns true if there are more right children in dimension d  

        Parameters
        ----------
        * `d` :  
            the moving direction  

        Returns
        -------
        true if there are more right children in dimension d  

        """
        return _pysgpp_swig.HashGridIterator_hintRight(self, d)

    def get(self, d: "size_t") -> "void":
        r"""


        Gets level `l` and index `i` in dimension `d` of the current grid point.  

        Parameters
        ----------
        * `d` :  
            the dimension of interest  
        * `l` :  
            the ansatz function's level  
        * `i` :  
            the ansatz function's index  

        """
        return _pysgpp_swig.HashGridIterator_get(self, d)

    def set(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `set(point)`  

            Sets the iterator to a grid point.  

            Recomputes the hash value of the current grid point.  

            Parameters:  
            * `point` :  
                new grid point  

        * `set(d, l, i)`  

            Sets level `l` and index `i` in dimension `d` of the current grid point.  

            Recomputes the hash value of the current grid point.  

            Parameters:  
            * `d` :  
                the dimension of interest  
            * `l` :  
                the ansatz function's level  
            * `i` :  
                the ansatz function's index  

        """
        return _pysgpp_swig.HashGridIterator_set(self, *args)

    def push(self, d: "size_t", l: "sgpp::base::HashGridIterator::index_type::level_type", i: "sgpp::base::HashGridIterator::index_type::index_type") -> "void":
        r"""


        Sets level `l` and index `i` in dimension `d` of the current grid point.  

        Does not recompute hash value of the current grid point.  

        Parameters
        ----------
        * `d` :  
            the dimension of the gridpoint  
        * `l` :  
            the ansatz function's level  
        * `i` :  
            the ansatz function's index  

        """
        return _pysgpp_swig.HashGridIterator_push(self, d, l, i)

    def seq(self) -> "size_t":
        r"""


        returns the current sequence number  

        Returns
        -------
        the current sequence number  

        """
        return _pysgpp_swig.HashGridIterator_seq(self)

    def getGridDepth(self, dim: "size_t") -> "sgpp::base::HashGridIterator::level_t":
        r"""


        Returns the the maximal level of the grid in the given dimension.  

        Parameters
        ----------
        * `dim` :  
            the dimension  

        """
        return _pysgpp_swig.HashGridIterator_getGridDepth(self, dim)

    def toString(self) -> "std::string":
        r"""


        Generates a string with level and index of the gridpoint.  

        Returns
        -------
        string into which the gridpoint is written  

        """
        return _pysgpp_swig.HashGridIterator_toString(self)

# Register HashGridIterator in _pysgpp_swig:
_pysgpp_swig.HashGridIterator_swigregister(HashGridIterator)

class RefinementFunctor(object):
    r"""

    `RefinementFunctor()`  

    Abstract class that defines the interface that refinement functors have to
    provide.  

    Constructors
    ------------
    * `RefinementFunctor()`  

        Constructor.  

    C++ includes: RefinementFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_RefinementFunctor

    def __call__(self, storage: "HashGridStorage", seq: "size_t") -> "double":
        return _pysgpp_swig.RefinementFunctor___call__(self, storage, seq)

    def start(self) -> "double":
        r"""


        Returns the lower bound of refinement criterion (e.g., alpha or error) (lower
        bound).  

        The refinement value of grid points to be refined have to be larger than this
        value  

        Returns
        -------
        lower bound  

        """
        return _pysgpp_swig.RefinementFunctor_start(self)

    def getRefinementsNum(self) -> "size_t":
        r"""


        Returns the maximal number of points that should be refined.  

        The maximal number of points to refine is set in the constructor of the
        implementing class.  

        Returns
        -------
        number of points that should refined. Default value: 1.  

        """
        return _pysgpp_swig.RefinementFunctor_getRefinementsNum(self)

    def getRefinementThreshold(self) -> "double":
        r"""


        Returns the threshold for refinement.  

        Only the grid points with absolute value of refinement criterion (e.g., alpha or
        error) greater or equal to this threshold will be refined.  

        Returns
        -------
        threshold value for refinement. Default value: 0.  

        """
        return _pysgpp_swig.RefinementFunctor_getRefinementThreshold(self)

    def getTotalRefinementValue(self, storage: "HashGridStorage") -> "double":
        r"""


        Returns the total sum of local (error) indicators used for refinement.  

        Parameters
        ----------
        * `storage` :  
            pointer to the grids storage object  

        Returns
        -------
        total sum of local (error) indicators used for refinement  

        """
        return _pysgpp_swig.RefinementFunctor_getTotalRefinementValue(self, storage)

# Register RefinementFunctor in _pysgpp_swig:
_pysgpp_swig.RefinementFunctor_swigregister(RefinementFunctor)

class SurplusRefinementFunctor(RefinementFunctor):
    r"""

    `SurplusRefinementFunctor(alpha, refinements_num=1, threshold=0.0)`  

    A refinement functor, refining according to the maximal absolute values in a
    DataVector provided.  

    Constructors
    ------------
    * `SurplusRefinementFunctor(alpha, refinements_num=1, threshold=0.0)`  

        Constructor.  

        Parameters:  
        * `alpha` :  
            DataVector that is basis for refinement decisions. The i-th entry
            corresponds to the i-th grid point.  
        * `refinements_num` :  
            Number of grid points which should be refined (if possible - there could
            be less refinable grid points)  
        * `threshold` :  
            The absolute value of the entries have to be greater or equal than the
            threshold  

    C++ includes: SurplusRefinementFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, alpha: "DataVector", refinements_num: "size_t"=1, threshold: "double"=0.0):
        r"""


        Constructor.  

        Parameters
        ----------
        * `alpha` :  
            DataVector that is basis for refinement decisions. The i-th entry
            corresponds to the i-th grid point.  
        * `refinements_num` :  
            Number of grid points which should be refined (if possible - there could be
            less refinable grid points)  
        * `threshold` :  
            The absolute value of the entries have to be greater or equal than the
            threshold  

        """
        _pysgpp_swig.SurplusRefinementFunctor_swiginit(self, _pysgpp_swig.new_SurplusRefinementFunctor(alpha, refinements_num, threshold))
    __swig_destroy__ = _pysgpp_swig.delete_SurplusRefinementFunctor

# Register SurplusRefinementFunctor in _pysgpp_swig:
_pysgpp_swig.SurplusRefinementFunctor_swigregister(SurplusRefinementFunctor)

class CoarseningFunctor(object):
    r"""

    `CoarseningFunctor()`  

    Abstract class that defines the interfaces that coarsening functors have to
    provide.  

    Constructors
    ------------
    * `CoarseningFunctor()`  

        Constructor.  

    C++ includes: CoarseningFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_CoarseningFunctor

    def __call__(self, storage: "HashGridStorage", seq: "size_t") -> "double":
        return _pysgpp_swig.CoarseningFunctor___call__(self, storage, seq)

    def start(self) -> "double":
        r"""


        This should return the initial value of coarsening criterion (e.g.  

        alpha or error).  

        Returns
        -------
        the initial value  

        """
        return _pysgpp_swig.CoarseningFunctor_start(self)

    def getRemovementsNum(self) -> "size_t":
        r"""


        Returns the maximal number of points that should be removed.  

        The maximal number of points to removed is set in the constructor of
        implementation class.  

        Returns
        -------
        number of points that should removed. Default value: 1.  

        """
        return _pysgpp_swig.CoarseningFunctor_getRemovementsNum(self)

    def getCoarseningThreshold(self) -> "double":
        r"""


        Returns the threshold value.  

        Only the grid points with absolute value of coarsening criterion (e.g. alpha)
        less or equal to this threshold will be removed  

        Returns
        -------
        threshold value for refinement. Default value: 0.  

        """
        return _pysgpp_swig.CoarseningFunctor_getCoarseningThreshold(self)

# Register CoarseningFunctor in _pysgpp_swig:
_pysgpp_swig.CoarseningFunctor_swigregister(CoarseningFunctor)

class GridGenerator(object):
    r"""

    `GridGenerator()`  

    Abstract class that defines the interfaces for the different grid's
    GridGenerators.  

    Constructors
    ------------
    * `GridGenerator()`  

        Constructor.  

    C++ includes: GridGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_GridGenerator

    def regular(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `regular(level)`  

            Creates a regular sparse grid for a certain level $ n $, i.e., $ *V_n^{(1)}
            = *\bigoplus_{|\vec{l}|_1 \leq n+d-1} W_{\vec{l}}$.  

            Parameters:  
            * `level` :  
                Grid level  

        * `regular(level, T)`  

            Creates a regular sparse grid for a certain level $ n $, i.e., $ *V_n^{(1)}
            = *\bigoplus_{|\vec{l}|_1 \leq n+d-1} W_{\vec{l}}$.  

            If the used grid doesn't support the parameter t, t = 0 is used instead.  

            Parameters:  
            * `level` :  
                Grid level  
            * `T` :  
                modifier for subgrid selection, T = 0 implies standard sparse grid. For
                further information see Griebel and Knapek's paper optimized tensor-
                product approximation spaces  

        """
        return _pysgpp_swig.GridGenerator_regular(self, *args)

    def regularInter(self, level: "size_t", terms: "std::set< std::set< size_t > > const &", T: "double") -> "void":
        r"""


        Creates a regular sparse grid for a certain level $ n $, i.e., $ *V_n^{(1)} =
        *\bigoplus_{|\vec{l}|_1 \leq n+d-1} W_{\vec{l}}$.  

        If the used grid doesn't support the parameter t, t = 0 is used instead. This
        grid generator allows the creation of regular grids that only contain some
        interaction terms.  

        Parameters
        ----------
        * `level` :  
            Grid level  
        * `T` :  
            modifier for subgrid selection, T = 0 implies standard sparse grid. For
            further information see Griebel and Knapek's paper optimized tensor-product
            approximation spaces  
        * `terms` :  
            determines the included interaction terms.  

        """
        return _pysgpp_swig.GridGenerator_regularInter(self, level, terms, T)

    def cliques(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `cliques(level, clique_size)`  

            Creates a sparse grid with fully connected cliques.  

            Parameters:  
            * `level` :  
                Grid level  
            * `clique_size` :  
                clique size  

        * `cliques(level, clique_size, T)`  

            Creates a sparse grid with fully connected cliques.  

            Parameters:  
            * `level` :  
                Grid level  
            * `clique_size` :  
                clique size  
            * `T` :  
                modifier for subgrid selection, T = 0 implies standard sparse grid. For
                further information see Griebel and Knapek's paper optimized tensor-
                product approximation spaces  

        """
        return _pysgpp_swig.GridGenerator_cliques(self, *args)

    def full(self, level: "size_t") -> "void":
        r"""


        Creates a full grid for a certain level $ n $, i.e., $ V_n =
        *\bigoplus_{|\vec{l}|_\infty *\leq n} W_{\vec{l}}$.  

        Parameters
        ----------
        * `level` :  
            Grid level  

        """
        return _pysgpp_swig.GridGenerator_full(self, level)

    def anisotropicFull(self, dimlevels: "SizeVector") -> "void":
        r"""


        Creates an anisotropicFull Grid for certain level vector, for example [2,3,1]
        results in a 3x7x1 grid.  

        """
        return _pysgpp_swig.GridGenerator_anisotropicFull(self, dimlevels)

    def truncated(self, level: "size_t", l_user: "size_t") -> "void":
        r"""


        Creates a grid which doesn't contain the fullgrids with li<l_user, for any li
        level_t.  

        """
        return _pysgpp_swig.GridGenerator_truncated(self, level, l_user)

    def refine(self, func: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to the settings of the RefinementFunctor func.  

        Parameters
        ----------
        * `func` :  
            reference to refinement functor  
        * `addedPoints` :  
            pointer to vector to add newly created grid points to  

        """
        return _pysgpp_swig.GridGenerator_refine(self, func, addedPoints)

    def refineInter(self, func: "RefinementFunctor", interactions: "std::set< std::set< size_t > > const &") -> "void":
        r"""


        Refines a grid according to the settings of the RefinementFunctor func.  

        Does not create any interactions, that are not in the list of allowed
        interactions.  

        Refines the grid, but only adds interactions that are contained in the set
        interactions, i.e. only desired interactions. Each desired interaction is
        encoded as a vector which contains all desired interactions. For example, if we
        want to include grid points that model an interaction between the first and the
        second predictor, we would include the vector [1,2] in interactions.  

        Parameters
        ----------
        * `func` :  
            pointer to refinement functor  
        * `interactions` :  
            allowed interactions  

        """
        return _pysgpp_swig.GridGenerator_refineInter(self, func, interactions)

    def coarsen(self, func: "CoarseningFunctor", removedSeq: "SizeVector") -> "void":
        r"""


        Coarsens a grid according to the settings of the CoarseningFunctor func.  

        Parameters
        ----------
        * `func` :  
            pointer to coarsening functor  
        * `removedSeq` :  
            pointer to vector to append the seq numbers of coarsened grid points to.  

        """
        return _pysgpp_swig.GridGenerator_coarsen(self, func, removedSeq)

    def coarsenNFirstOnly(self, func: "CoarseningFunctor", numFirstOnly: "size_t", removedSeq: "SizeVector", minIndexConsidered: "size_t") -> "void":
        r"""


        Coarsens a grid according to the settings of the CoarseningFunctor func.  

        Only numFirstOnly first grid points are checked for coarsening.  

        Parameters
        ----------
        * `func` :  
            pointer to coarsening functor  
        * `numFirstOnly` :  
            max. number grid points to be coarsened  
        * `removedSeq` :  
            pointer to vector to append the seq numbers of coarsened grid points to.  
        * `minIndexConsidered` :  
            Minimum index of grid points that will be coarsened  

        """
        return _pysgpp_swig.GridGenerator_coarsenNFirstOnly(self, func, numFirstOnly, removedSeq, minIndexConsidered)

    def getNumberOfRefinablePoints(self) -> "size_t":
        r"""


        Returns the number of points on the grid that can be refined in the next
        iteration.  

        Returns
        -------
        the number of points on the grid that can be refined  

        """
        return _pysgpp_swig.GridGenerator_getNumberOfRefinablePoints(self)

    def getNumberOfRemovablePoints(self) -> "size_t":
        r"""


        Returns the number of points on the grid that can be removed in the next
        iteration.  

        Returns
        -------
        the number of points on the grid that can be removed  

        """
        return _pysgpp_swig.GridGenerator_getNumberOfRemovablePoints(self)

    def refineMaxLevel(self, func: "RefinementFunctor", maxLevel: "size_t") -> "void":
        r"""


        Refines a grid according to the settings of the RefinementFunctor func.  

        additionally a maximum level for refinement is taken into account  

        Parameters
        ----------
        * `func` :  
            pointer to refinement functor  
        * `maxLevel` :  
            no points on higher levels than maxLevel will be created  

        """
        return _pysgpp_swig.GridGenerator_refineMaxLevel(self, func, maxLevel)

    def getNumberOfRefinablePointsToMaxLevel(self, maxLevel: "size_t") -> "size_t":
        r"""


        Returns the number of points on the grid that can be refined in the next
        iteration additionally a maximum level for refinement is taken into account.  

        Parameters
        ----------
        * `maxLevel` :  
            no points on higher levels than maxLevel will be created  

        Returns
        -------
        the number of points on the grid that can be refined  

        """
        return _pysgpp_swig.GridGenerator_getNumberOfRefinablePointsToMaxLevel(self, maxLevel)

# Register GridGenerator in _pysgpp_swig:
_pysgpp_swig.GridGenerator_swigregister(GridGenerator)

class OperationMultipleEval(object):
    r"""

    `OperationMultipleEval(grid, dataset)`  

    Interface for multiplication with Matrices $B$ and $B^T$.  

    If there are $N$ basis functions, $\{\varphi(\vec{x})\}_{i=1,\ldots,N}$ and
    $m$ data points  

    Constructors
    ------------
    * `OperationMultipleEval(grid, dataset)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            the sparse grid used for this operation  
        * `dataset` :  
            data set that should be evaluated on the sparse grid, a operation may
            create a copy of the dataset  

    C++ includes: OperationMultipleEval.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationMultipleEval

    def mult(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `mult(alpha, result)`  

            Multiplication of $B^T$ with vector $\alpha$.  

            Parameters:  
            * `alpha` :  
                vector, to which $B$ is applied. Typically the coefficient vector  
            * `result` :  
                the result vector of the matrix vector multiplication  

        * `mult(alpha, result, startIndexData, endIndexData)`  

            Multiplication of $B^T$ with vector $\alpha$.  

            This implementation variant produces a partial result passed on the start
            and end index provided. Not every MultiEval operation implements this
            method, as it only useful for distributed algorithms.  

            Parameters:  
            * `alpha` :  
                vector, to which $B$ is applied. Typically the coefficient vector  
            * `result` :  
                the result vector of the matrix vector multiplication  
            * `startIndexData` :  
                begin of the fragment of the dataset to be evaluated  
            * `endIndexData` :  
                end of the fragment of the dataset to be evaluated  

            Returns:
            The results of the evaluation for the specified range of the dataset  

        """
        return _pysgpp_swig.OperationMultipleEval_mult(self, *args)

    def multTranspose(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `multTranspose(source, result)`  

            Multiplication of $B$ with vector $\alpha$.  

            Parameters:  
            * `source` :  
                vector, to which $B^T$ is applied. Typically the coefficient vector  
            * `result` :  
                the result vector of the matrix vector multiplication  

        * `multTranspose(source, result, startIndexGrid, endIndexGrid)`  

            Multiplication of $B$ with vector $\alpha$.  

            This implementation variant produces a partial result passed on the start
            and end index provided. Not every MultiEval operation implements this
            method, as it only useful for distributed algorithms.  

            Parameters:  
            * `source` :  
                vector, to which $B^T$ is applied. Typically the coefficient vector  
            * `result` :  
                the result vector of the matrix vector multiplication  
            * `startIndexGrid` :  
                begin of the fragment of the grid to apply the operator to  
            * `endIndexGrid` :  
                end of the fragment of the grid to be apply the operator to  

            Returns:
            The results of the evaluation for the specified range of the dataset  

        """
        return _pysgpp_swig.OperationMultipleEval_multTranspose(self, *args)

    def eval(self, alpha: "DataVector", result: "DataVector") -> "void":
        r"""


        Evaluate multiple datapoints with the specified grid.  

        Parameters
        ----------
        * `alpha` :  
            surplus vector of the grid  
        * `result` :  
            result of the evaluations  

        """
        return _pysgpp_swig.OperationMultipleEval_eval(self, alpha, result)

    def prepare(self) -> "void":
        r"""


        Used for kernel-specific setup like special data structures that are defined
        from the current state of the grid.  

        This function is by default called with each "mult()", "multTranspose()" or
        evaluation operation and can be ignored from an external perspective. This is
        not overridden by every kernel.  

        """
        return _pysgpp_swig.OperationMultipleEval_prepare(self)

    def getDuration(self) -> "double":
        r"""


        """
        return _pysgpp_swig.OperationMultipleEval_getDuration(self)

    def getImplementationName(self) -> "std::string":
        r"""


        Name of this implementation of the operation.  

        """
        return _pysgpp_swig.OperationMultipleEval_getImplementationName(self)

# Register OperationMultipleEval in _pysgpp_swig:
_pysgpp_swig.OperationMultipleEval_swigregister(OperationMultipleEval)

class OperationMatrix(object):
    r"""

    `OperationMatrix()`  

    Abstract definition of a matrix operator interface.  

    Every time you need to apply a matrix to the ansatzfunction's coefficients
    derive a class from OperationMatrix  

    Constructors
    ------------
    * `OperationMatrix()`  

        Constructor.  

    C++ includes: OperationMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationMatrix

    def mult(self, alpha: "DataVector", result: "DataVector") -> "void":
        r"""


        starts the Multiplication with the matrix  

        Parameters
        ----------
        * `alpha` :  
            DataVector that contains the ansatzfunctions' coefficients  
        * `result` :  
            DataVector into which the result of the Laplace operation is stored  

        """
        return _pysgpp_swig.OperationMatrix_mult(self, alpha, result)

# Register OperationMatrix in _pysgpp_swig:
_pysgpp_swig.OperationMatrix_swigregister(OperationMatrix)

class OperationIdentity(OperationMatrix):
    r"""

    `OperationIdentity()`  

    Implementation of identity Operation for all kinds of grids.  

    Constructors
    ------------
    * `OperationIdentity()`  

        Constructor of OperationIdentity.  

    C++ includes: OperationIdentity.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor of OperationIdentity.  

        """
        _pysgpp_swig.OperationIdentity_swiginit(self, _pysgpp_swig.new_OperationIdentity())
    __swig_destroy__ = _pysgpp_swig.delete_OperationIdentity

# Register OperationIdentity in _pysgpp_swig:
_pysgpp_swig.OperationIdentity_swigregister(OperationIdentity)

class OperationConvert(object):
    r"""

    `OperationConvert()`  

    Operation that cpnverts a given basis into the normal, linear hat basis and vice
    versa.  

    Constructors
    ------------
    * `OperationConvert()`  

        Constructor.  

    C++ includes: OperationConvert.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationConvert

    def doConvertToLinear(self, alpha: "DataVector") -> "void":
        r"""


        Convert given basis into linear hat basis.  

        """
        return _pysgpp_swig.OperationConvert_doConvertToLinear(self, alpha)

    def doConvertFromLinear(self, alpha: "DataVector") -> "void":
        r"""


        Convert from a linear coefficient vector into given basis.  

        """
        return _pysgpp_swig.OperationConvert_doConvertFromLinear(self, alpha)

# Register OperationConvert in _pysgpp_swig:
_pysgpp_swig.OperationConvert_swigregister(OperationConvert)

class OperationEval(object):
    r"""

    `OperationEval()`  

    Operation that evaluates the current sparse grid function defined by the
    coefficient vector *alpha* at a given point.  

    Constructors
    ------------
    * `OperationEval()`  

        Default constructor.  

    C++ includes: OperationEval.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationEval

    def eval(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `eval(alpha, point, value)`  

            Parameters:  
            * `alpha` :  
                coefficient matrix (each column is a coefficient vector)  
            * `point` :  
                evaluation point  
            * `value` :  
                values of the linear combination  

        * `eval(alpha, point) -> double`  

            Evaluates the sparse grid function at a given point.  

            Parameters:  
            * `alpha` :  
                The coefficients of the sparse grid's basis functions  
            * `point` :  
                The coordinates of the evaluation point  

        """
        return _pysgpp_swig.OperationEval_eval(self, *args)

# Register OperationEval in _pysgpp_swig:
_pysgpp_swig.OperationEval_swigregister(OperationEval)

class OperationEvalGradient(object):
    r"""

    `OperationEvalGradient()`  

    Abstract operation for evaluating a linear combination of basis functions and
    its gradient.  

    Constructors
    ------------
    * `OperationEvalGradient()`  

        Constructor.  

    C++ includes: OperationEvalGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationEvalGradient

    def evalGradient(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `evalGradient(alpha, point, value, gradient)`  

            Parameters:  
            * `alpha` :  
                coefficient matrix (each column is a coefficient vector)  
            * `point` :  
                evaluation point  
            * `value` :  
                values of the linear combination  
            * `gradient` :  
                Jacobian of the linear combination (each row is a gradient vector)  

        * `evalGradient(alpha, point, gradient) -> double`  

            Parameters:  
            * `alpha` :  
                coefficient vector  
            * `point` :  
                evaluation point  
            * `gradient` :  
                gradient vector of the linear combination  

            Returns:
            value of the linear combination  

        """
        return _pysgpp_swig.OperationEvalGradient_evalGradient(self, *args)
    pointInUnitCube = property(_pysgpp_swig.OperationEvalGradient_pointInUnitCube_get, _pysgpp_swig.OperationEvalGradient_pointInUnitCube_set)

# Register OperationEvalGradient in _pysgpp_swig:
_pysgpp_swig.OperationEvalGradient_swigregister(OperationEvalGradient)

class OperationEvalHessian(object):
    r"""

    `OperationEvalHessian()`  

    Abstract operation for evaluating a linear combination of basis functions, its
    gradient and its Hessian.  

    Constructors
    ------------
    * `OperationEvalHessian()`  

        Constructor.  

    C++ includes: OperationEvalHessian.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationEvalHessian

    def evalHessian(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `evalHessian(alpha, point, value, gradient, hessian)`  

            Parameters:  
            * `alpha` :  
                coefficient matrix (each column is a coefficient vector)  
            * `point` :  
                evaluation point  
            * `value` :  
                values of the linear combination  
            * `gradient` :  
                Jacobian of the linear combination (each row is a gradient vector)  
            * `hessian` :  
                vector of Hessians of the linear combination  

        * `evalHessian(alpha, point, gradient, hessian) -> double`  

            Parameters:  
            * `alpha` :  
                coefficient vector  
            * `point` :  
                evaluation point  
            * `gradient` :  
                gradient vector of the linear combination  
            * `hessian` :  
                Hessian matrix of the linear combination  

            Returns:
            value of the linear combination  

        """
        return _pysgpp_swig.OperationEvalHessian_evalHessian(self, *args)
    pointInUnitCube = property(_pysgpp_swig.OperationEvalHessian_pointInUnitCube_get, _pysgpp_swig.OperationEvalHessian_pointInUnitCube_set)

# Register OperationEvalHessian in _pysgpp_swig:
_pysgpp_swig.OperationEvalHessian_swigregister(OperationEvalHessian)

class OperationEvalPartialDerivative(object):
    r"""

    `OperationEvalPartialDerivative()`  

    Abstract operation for evaluating a partial derivative of a linear combination
    of basis functions.  

    The "naive" is indicating that classes implementing this operation should use
    a "naive" approach, e.g. by evaluating all basis functions by brute force.  

    Constructors
    ------------
    * `OperationEvalPartialDerivative()`  

        Constructor.  

    C++ includes: OperationEvalPartialDerivative.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationEvalPartialDerivative

    def evalPartialDerivative(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `evalPartialDerivative(alpha, point, derivDim, value, partialDerivative)`  

            Parameters:  
            * `alpha` :  
                coefficient matrix (each column is a coefficient vector)  
            * `point` :  
                evaluation point  
            * `derivDim` :  
                dimension in which the partial derivative should be taken (0, ..., d-1)  
            * `value` :  
                values of the linear combination  
            * `partialDerivative` :  
                values of the partial derivatives of the linear combination (the j-th
                entry corresponds to the j-th column of alpha)  

        * `evalPartialDerivative(alpha, point, derivDim, partialDerivative) -> double`  

            Parameters:  
            * `alpha` :  
                coefficient vector  
            * `point` :  
                evaluation point  
            * `derivDim` :  
                dimension in which the partial derivative should be taken (0, ..., d-1)  
            * `partialDerivative` :  
                value of the partial derivative of the linear combination  

            Returns:
            value of the linear combination  

        """
        return _pysgpp_swig.OperationEvalPartialDerivative_evalPartialDerivative(self, *args)
    pointInUnitCube = property(_pysgpp_swig.OperationEvalPartialDerivative_pointInUnitCube_get, _pysgpp_swig.OperationEvalPartialDerivative_pointInUnitCube_set)

# Register OperationEvalPartialDerivative in _pysgpp_swig:
_pysgpp_swig.OperationEvalPartialDerivative_swigregister(OperationEvalPartialDerivative)

class OperationHierarchisation(object):
    r"""

    `OperationHierarchisation()`  

    This class implements the hierarchisation and dehierarchisation on the sparse
    grid.  

    Constructors
    ------------
    * `OperationHierarchisation()`  

        Constructor.  

    C++ includes: OperationHierarchisation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationHierarchisation

    def doHierarchisation(self, node_values: "DataVector") -> "void":
        r"""


        Implements the hierarchisation on a sparse grid.  

        Parameters
        ----------
        * `node_values` :  
            the function's values in the nodal basis  

        """
        return _pysgpp_swig.OperationHierarchisation_doHierarchisation(self, node_values)

    def doDehierarchisation(self, alpha: "DataVector") -> "void":
        r"""


        Implements the dehierarchisation on a sparse grid.  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the sparse grid's basis functions  

        """
        return _pysgpp_swig.OperationHierarchisation_doDehierarchisation(self, alpha)

# Register OperationHierarchisation in _pysgpp_swig:
_pysgpp_swig.OperationHierarchisation_swigregister(OperationHierarchisation)

class OperationQuadrature(object):
    r"""

    `OperationQuadrature()`  

    This class provides the quadrature of a sparse grid function.  

    Constructors
    ------------
    * `OperationQuadrature()`  

        Constructor.  

    C++ includes: OperationQuadrature.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationQuadrature

    def doQuadrature(self, alpha: "DataVector") -> "double":
        r"""


        Integrate the sparse grid function.  

        Parameters
        ----------
        * `alpha` :  
            the function's values in the nodal basis  

        """
        return _pysgpp_swig.OperationQuadrature_doQuadrature(self, alpha)

# Register OperationQuadrature in _pysgpp_swig:
_pysgpp_swig.OperationQuadrature_swigregister(OperationQuadrature)

class OperationQuadratureMC(OperationQuadrature):
    r"""

    `OperationQuadratureMC(grid, mcPaths)`  

    Quadrature on any sparse grid (that has OperationMultipleEval implemented) using
    Monte Carlo.  

    Constructors
    ------------
    * `OperationQuadratureMC(grid, mcPaths)`  

        Constructor of OperationQuadratureMC, specifying a grid object and the
        number of samples to use.  

        Parameters:  
        * `grid` :  
            Reference to the grid object  
        * `mcPaths` :  
            Number of Monte Carlo samples  

    C++ includes: OperationQuadratureMC.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", mcPaths: "int"):
        r"""


        Constructor of OperationQuadratureMC, specifying a grid object and the number of
        samples to use.  

        Parameters
        ----------
        * `grid` :  
            Reference to the grid object  
        * `mcPaths` :  
            Number of Monte Carlo samples  

        """
        _pysgpp_swig.OperationQuadratureMC_swiginit(self, _pysgpp_swig.new_OperationQuadratureMC(grid, mcPaths))
    __swig_destroy__ = _pysgpp_swig.delete_OperationQuadratureMC

    def doQuadratureFunc(self, *args) -> "double":
        r"""


        Quadrature of an arbitrary function using simple MC in $\Omega=[0,1]^d$.  

        Parameters
        ----------
        * `func` :  
            The function to integrate  
        * `clientdata` :  
            Optional data to pass to FUNC  

        """
        return _pysgpp_swig.OperationQuadratureMC_doQuadratureFunc(self, *args)

    def doQuadratureL2Error(self, *args) -> "double":
        r"""


        Quadrature of the $L^2$-norm of the error, $ ||f(x)-u(x)||_{L^2} $, between a
        given function and the current sparse grid function using simple MC in
        $\Omega=[0,1]^d$.  

        Parameters
        ----------
        * `func` :  
            The function $f(x)$  
        * `clientdata` :  
            Optional data to pass to FUNC  
        * `alpha` :  
            Coefficient vector for current grid  

        """
        return _pysgpp_swig.OperationQuadratureMC_doQuadratureL2Error(self, *args)

# Register OperationQuadratureMC in _pysgpp_swig:
_pysgpp_swig.OperationQuadratureMC_swigregister(OperationQuadratureMC)

class DirichletUpdateVector(object):
    r"""

    `DirichletUpdateVector(storage)`  

    This class is useful if you do some PDE calculations with Dirichlet Boundary
    Conditions.  

    Doing this, e.g. you might wish to add some solution from a timestep to the
    current coefficients of the sparse grid. If you are using Dirichlet conditions
    you mustn't overwrite the values on the boundaries in your coefficient vector.  

    This class implements a functor that uses the Bounding Box of the grid to
    determine, if a boundary has to implement Dirichlet boundary conditions. In that
    case, simply use this to replace all values in the update vector on these
    boundaries with zero, so you can safely add the resulting vector to your
    solution.  

    Constructors
    ------------
    * `DirichletUpdateVector(storage)`  

        Std-Constructor.  

        Parameters:  
        * `storage` :  
            the grid's storage object; needed to determine the bounding box and to
            iterate of the entries in the coefficient vector  

    C++ includes: DirichletUpdateVector.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        Std-Constructor.  

        Parameters
        ----------
        * `storage` :  
            the grid's storage object; needed to determine the bounding box and to
            iterate of the entries in the coefficient vector  

        """
        _pysgpp_swig.DirichletUpdateVector_swiginit(self, _pysgpp_swig.new_DirichletUpdateVector(storage))
    __swig_destroy__ = _pysgpp_swig.delete_DirichletUpdateVector

    def applyDirichletConditions(self, updateVector: "DataVector", sourceVector: "DataVector") -> "void":
        r"""


        Replace the boundary entries in updateVector with the one from sourceVector only
        in that dimension, for which Dirichlet Boundary Conditions were specified.  

        Parameters
        ----------
        * `updateVector` :  
            the vector that should be updated  
        * `sourceVector` :  
            the vector that contains the correct boundary values  

        """
        return _pysgpp_swig.DirichletUpdateVector_applyDirichletConditions(self, updateVector, sourceVector)

    def setBoundariesToZero(self, updateVector: "DataVector") -> "void":
        r"""


        Replace the boundary entries in updateVector with Zero only in that dimension,
        for which Dirichlet Boundary Conditions were specified.  

        Parameters
        ----------
        * `updateVector` :  
            the vector that should be updated  

        """
        return _pysgpp_swig.DirichletUpdateVector_setBoundariesToZero(self, updateVector)

    def setInnerPointsToZero(self, updateVector: "DataVector") -> "void":
        r"""


        Replace the inner entries in updateVector with Zero only in that dimension, for
        which Dirichlet Boundary Conditions were specified.  

        Parameters
        ----------
        * `updateVector` :  
            the vector that should be updated  

        """
        return _pysgpp_swig.DirichletUpdateVector_setInnerPointsToZero(self, updateVector)

    def multiplyBoundaryVector(self, updateVector: "DataVector", factor: "DataVector") -> "void":
        r"""


        Multiplies the values on the boundary with vector.  

        Parameters
        ----------
        * `updateVector` :  
            the vector that should be updated  
        * `factor` :  
            the vector contains corresponding values  

        """
        return _pysgpp_swig.DirichletUpdateVector_multiplyBoundaryVector(self, updateVector, factor)

    def multiplyBoundary(self, updateVector: "DataVector", value: "double") -> "void":
        r"""


        Multiplies the values on the boundary with a constant value.  

        Parameters
        ----------
        * `updateVector` :  
            the vector that should be updated  
        * `value` :  
            the value that is multiplied with the value on the boundaries  

        """
        return _pysgpp_swig.DirichletUpdateVector_multiplyBoundary(self, updateVector, value)

    def multiply(self, updateVector: "DataVector", value: "double", predicate: "bool (*)(sgpp::base::GridPoint *,sgpp::base::GridStorage &)") -> "void":
        r"""


        Multiplies the values of the points in the vector that meet the predicate
        condition by the constant value.  

        Calling this method with a function pointer that returns true if
        point->isInnerPoint() and false otherwise gives the same result as the
        multiplyBoundary method.  

        """
        return _pysgpp_swig.DirichletUpdateVector_multiply(self, updateVector, value, predicate)

# Register DirichletUpdateVector in _pysgpp_swig:
_pysgpp_swig.DirichletUpdateVector_swigregister(DirichletUpdateVector)

class HashGenerator(object):
    r"""


    This class provides the generation functionality of sparse grids based on
    hashmaps.  

    Grids with and without boundaries are supported.  

    For boundary grids two cases are supported:  

    1.  the classic sparse grid with level 0 and a diagonal cut through the sub
        space scheme.  
    2.  a modified boundary grid with level 0 and a pentagon cut trough the sub
        space scheme.  

    Furthermore, the creation of full grids (in the hierarchical basis) is
    supported.  

    C++ includes: HashGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def regular(self, storage: "HashGridStorage", level: "sgpp::base::level_t", T: "double"=0) -> "void":
        r"""


        Generates a regular sparse grid of level levels, without boundaries.  

        Parameters
        ----------
        * `storage` :  
            Hashmap that stores the grid points  
        * `level` :  
            Grid level (non-negative value)  
        * `T` :  
            modifier for subgrid selection, T = 0 implies standard sparse grid. For
            further information see Griebel and Knapek's paper optimized tensor-product
            approximation spaces. The effect of T can be seen in:  

        """
        return _pysgpp_swig.HashGenerator_regular(self, storage, level, T)

    def regularInter(self, storage: "HashGridStorage", level: "sgpp::base::level_t", terms: "std::set< std::set< size_t > > const &", T: "double"=0) -> "void":
        r"""


        Generates a regular sparse grid of level level, without boundaries.  

        The resulting grid only contains interactions that are in the vector terms.  

        Parameters
        ----------
        * `storage` :  
            Hashmap that stores the grid points  
        * `level` :  
            Grid level (non-negative value)  
        * `terms` :  
            controls the desired interaction terms. For example, if we want to include
            grid points that model an interaction between the first and the second
            predictor, we would include the vector [1,2] in terms.  
        * `T` :  
            modifier for subgrid selection, T = 0 implies standard sparse grid. For
            further information see Griebel and Knapek's paper optimized tensor-product
            approximation spaces.  

        """
        return _pysgpp_swig.HashGenerator_regularInter(self, storage, level, terms, T)

    def regular_inter(self, storage: "HashGridStorage", level: "sgpp::base::level_t", terms: "std::unordered_set< std::vector< bool,std::allocator< bool > > > const &", T: "double"=0) -> "void":
        r"""


        """
        return _pysgpp_swig.HashGenerator_regular_inter(self, storage, level, terms, T)

    def cliques(self, storage: "HashGridStorage", level: "sgpp::base::level_t", clique_size: "size_t", T: "double"=0) -> "void":
        r"""


        Generates a regular sparse grid of level levels, without boundaries where
        dimensions are splitted into a groups with only certain number of dimensions
        completely connected in a clique.  

        Parameters
        ----------
        * `storage` :  
            Hashmap that stores the grid points  
        * `level` :  
            Grid level (non-negative value)  
        * `clique_size` :  
            number of dimensions in a clique  
        * `T` :  
            modifier for subgrid selection, T = 0 implies standard sparse grid. For
            further information see Griebel and Knapek's paper optimized tensor-product
            approximation spaces  

        """
        return _pysgpp_swig.HashGenerator_cliques(self, storage, level, clique_size, T)

    def full(self, storage: "HashGridStorage", level: "sgpp::base::level_t") -> "void":
        r"""


        Generates a full grid of level `level`, without boundaries.  

        Parameters
        ----------
        * `storage` :  
            Hashmap that stores the grid points  
        * `level` :  
            Grid level (non-negative value)  

        """
        return _pysgpp_swig.HashGenerator_full(self, storage, level)

    def anisotropicFull(self, storage: "HashGridStorage", dimlevels: "SizeVector") -> "void":
        r"""


        Generates an anisotropic full grid of the level vector.  

        Parameters
        ----------
        * `storage` :  
            Hashmap that stores the grid points  
        * `dimlevels` :  
            grid level vector (vector of non-negative values)  

        """
        return _pysgpp_swig.HashGenerator_anisotropicFull(self, storage, dimlevels)

    def fullWithBoundary(self, storage: "HashGridStorage", level: "sgpp::base::level_t") -> "void":
        r"""


        Generates a full grid of level `level`, with boundary grid points.  

        Parameters
        ----------
        * `storage` :  
            Hashmap that stores the grid points  
        * `level` :  
            Grid level (non-negative value)  

        """
        return _pysgpp_swig.HashGenerator_fullWithBoundary(self, storage, level)

    def regularWithBoundaries(self, storage: "HashGridStorage", level: "sgpp::base::level_t", boundaryLevel: "sgpp::base::level_t"=1) -> "void":
        r"""


        Generates a regular sparse grid of level levels with boundaries.  

        Parameters
        ----------
        * `storage` :  
            Hashmap, that stores the grid points  
        * `level` :  
            maximum level of the sparse grid (non-negative value)  
        * `boundaryLevel` :  
            level at which the boundary points should be inserted  

        """
        return _pysgpp_swig.HashGenerator_regularWithBoundaries(self, storage, level, boundaryLevel)

    def regularWithPeriodicBoundaries(self, storage: "HashGridStorage", level: "sgpp::base::level_t", T: "double"=0) -> "void":
        r"""


        Generates a regular sparse grid of level levels with boundaries.  

        Parameters
        ----------
        * `storage` :  
            Hashmap, that stores the grid points  
        * `level` :  
            maximum level of the sparse grid (non-negative value)  
        * `T` :  
            modifier for subgrid selection, T = 0 implies standard sparse grid. For
            further information see Griebel and Knapek's paper optimized tensor-product
            approximation spaces  

        """
        return _pysgpp_swig.HashGenerator_regularWithPeriodicBoundaries(self, storage, level, T)

    def squareRoot(self, storage: "HashGridStorage", level: "sgpp::base::level_t") -> "void":
        r"""


        Generates a regular square root grid of level level with boundaries.  

        Parameters
        ----------
        * `storage` :  
            Hashmap, that stores the grid points  
        * `level` :  
            maximum level of the square root grid (non-negative value)  

        Change here to the following code to take the [n/2]+1 grid as small level for
        odd numbers(and also change FullGridSet getSquare method) int
        small_level=ceil(level/2); if (level%2==0) level--;  

        """
        return _pysgpp_swig.HashGenerator_squareRoot(self, storage, level)

    def truncated(self, storage: "HashGridStorage", level: "sgpp::base::level_t", k: "sgpp::base::level_t") -> "void":
        r"""


        Generates a truncated boundary grid containing all gridpoints with li<l-k and
        |l|<l+(dim-1)*k.  

        Parameters
        ----------
        * `storage` :  
            Hashmap, that stores the grid points  
        * `level` :  
            maximum level of the square root grid (non-negative value)  
        * `k` :  
            the parameter which determines the maximum level of the gridpoints for every
            dimension  

        """
        return _pysgpp_swig.HashGenerator_truncated(self, storage, level, k)

    def __init__(self):
        _pysgpp_swig.HashGenerator_swiginit(self, _pysgpp_swig.new_HashGenerator())
    __swig_destroy__ = _pysgpp_swig.delete_HashGenerator

# Register HashGenerator in _pysgpp_swig:
_pysgpp_swig.HashGenerator_swigregister(HashGenerator)

class AbstractRefinement_refinement_key(object):
    r"""

    `AbstractRefinement_refinement_key(point, seq)`  

    Constructors
    ------------
    * `AbstractRefinement_refinement_key(point, seq)`  

    C++ includes: AbstractRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, point: "HashGridPoint", seq: "size_t"):
        r"""


        """
        _pysgpp_swig.AbstractRefinement_refinement_key_swiginit(self, _pysgpp_swig.new_AbstractRefinement_refinement_key(point, seq))
    __swig_destroy__ = _pysgpp_swig.delete_AbstractRefinement_refinement_key

    def getLevelVector(self) -> "std::vector< sgpp::base::level_t,std::allocator< sgpp::base::level_t > > const":
        r"""


        """
        return _pysgpp_swig.AbstractRefinement_refinement_key_getLevelVector(self)

    def getPoint(self) -> "sgpp::base::GridPoint &":
        r"""


        """
        return _pysgpp_swig.AbstractRefinement_refinement_key_getPoint(self)

    def getSeq(self) -> "size_t":
        r"""


        """
        return _pysgpp_swig.AbstractRefinement_refinement_key_getSeq(self)

# Register AbstractRefinement_refinement_key in _pysgpp_swig:
_pysgpp_swig.AbstractRefinement_refinement_key_swigregister(AbstractRefinement_refinement_key)

class AbstractRefinement(object):
    r"""


    Abstract refinement class for sparse grids.  

    C++ includes: AbstractRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def compare_pairs(lhs: "sgpp::base::AbstractRefinement::refinement_pair_type const &", rhs: "sgpp::base::AbstractRefinement::refinement_pair_type const &") -> "bool":
        r"""


        Comparison of the refinement_pair_type.  

        This way the priority queue has the elements with the smallest
        refinement_value_type on top  

        """
        return _pysgpp_swig.AbstractRefinement_compare_pairs(lhs, rhs)

    def free_refine(self, storage: "HashGridStorage", functor: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to a RefinementFunctor provided.  

        Refines up to RefinementFunctor::getRefinementsNum() grid points if possible,
        and if their refinement value is larger than RefinementFunctor::start() and
        their absolute value is larger or equal than
        RefinementFunctor::getRefinementThreshold() If addedPoints is supplied and not a
        zero pointer, then newly created grid points are appended to this vector.  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  
        * `functor` :  
            a RefinementFunctor specifying the refinement criteria  
        * `addedPoints` :  
            pointer to vector to append newly created grid points to  

        """
        return _pysgpp_swig.AbstractRefinement_free_refine(self, storage, functor, addedPoints)

    def getNumberOfRefinablePoints(self, storage: "HashGridStorage") -> "size_t":
        r"""


        Computes and returns the number of grid points, which can be refined.  

        This is the number of grid points that have at least one child missing.  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  

        Returns
        -------
        The number of grid points that can be refined  

        """
        return _pysgpp_swig.AbstractRefinement_getNumberOfRefinablePoints(self, storage)

    def refineGridpoint1D(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `refineGridpoint1D(storage, point, d)`  

            Refine one grid point along a single direction.  

            Parameters:  
            * `storage` :  
                hashmap that stores the grid points  
            * `point` :  
                point to refine  
            * `d` :  
                direction  

        * `refineGridpoint1D(storage, seq, d)`  

            Refine one grid point along a single direction.  

            Parameters:  
            * `storage` :  
                hashmap that stores the grid points  
            * `seq` :  
                sequential number of the grid point  
            * `d` :  
                direction  

        """
        return _pysgpp_swig.AbstractRefinement_refineGridpoint1D(self, *args)

    def isRefinable(self, storage: "HashGridStorage", point: "HashGridPoint") -> "bool":
        r"""


        Check if the grid point is refinable.  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  
        * `point` :  
            grid point  

        """
        return _pysgpp_swig.AbstractRefinement_isRefinable(self, storage, point)
    __swig_destroy__ = _pysgpp_swig.delete_AbstractRefinement

    def getIndexOfMin(self, array: "sgpp::base::RefinementFunctor::value_type *", length: "size_t") -> "size_t":
        r"""


        Returns the index of the first occurrence of minimal element in array.  

        Used to find which entry is to be replaced next searching the maximum ones.  

        Parameters
        ----------
        * `array` :  
            array with values  
        * `length` :  
            length of array  

        Returns
        -------
        index of the first occurrence of minimal element in array  

        """
        return _pysgpp_swig.AbstractRefinement_getIndexOfMin(self, array, length)

    def refineGridpoint(self, storage: "HashGridStorage", refine_index: "size_t") -> "void":
        return _pysgpp_swig.AbstractRefinement_refineGridpoint(self, storage, refine_index)

    def createGridpoint(self, storage: "HashGridStorage", point: "HashGridPoint") -> "void":
        return _pysgpp_swig.AbstractRefinement_createGridpoint(self, storage, point)

    def createGridpointSubroutine(self, storage: "HashGridStorage", point: "HashGridPoint") -> "void":
        return _pysgpp_swig.AbstractRefinement_createGridpointSubroutine(self, storage, point)

    def createGridpoint1D(self, point: "HashGridPoint", d: "size_t", storage: "HashGridStorage", source_index: "sgpp::base::index_t &", source_level: "sgpp::base::level_t &") -> "void":
        return _pysgpp_swig.AbstractRefinement_createGridpoint1D(self, point, d, storage, source_index, source_level)

    def collectRefinablePoints(self, storage: "HashGridStorage", functor: "RefinementFunctor", collection: "sgpp::base::AbstractRefinement::refinement_container_type &") -> "void":
        return _pysgpp_swig.AbstractRefinement_collectRefinablePoints(self, storage, functor, collection)

    def refineGridpointsCollection(self, storage: "HashGridStorage", functor: "RefinementFunctor", collection: "sgpp::base::AbstractRefinement::refinement_container_type &") -> "void":
        return _pysgpp_swig.AbstractRefinement_refineGridpointsCollection(self, storage, functor, collection)

    def getIndicator(self, storage: "HashGridStorage", iter: "sgpp::base::GridStorage::grid_map_iterator const &", functor: "RefinementFunctor") -> "sgpp::base::AbstractRefinement::refinement_list_type":
        return _pysgpp_swig.AbstractRefinement_getIndicator(self, storage, iter, functor)

    def __init__(self):
        if self.__class__ == AbstractRefinement:
            _self = None
        else:
            _self = self
        _pysgpp_swig.AbstractRefinement_swiginit(self, _pysgpp_swig.new_AbstractRefinement(_self, ))
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_AbstractRefinement(self)
        return weakref.proxy(self)

# Register AbstractRefinement in _pysgpp_swig:
_pysgpp_swig.AbstractRefinement_swigregister(AbstractRefinement)

def AbstractRefinement_compare_pairs(lhs: "sgpp::base::AbstractRefinement::refinement_pair_type const &", rhs: "sgpp::base::AbstractRefinement::refinement_pair_type const &") -> "bool":
    r"""


    Comparison of the refinement_pair_type.  

    This way the priority queue has the elements with the smallest
    refinement_value_type on top  

    """
    return _pysgpp_swig.AbstractRefinement_compare_pairs(lhs, rhs)

class RefinementDecorator(AbstractRefinement):
    r"""

    `RefinementDecorator(refinement)`  

    RefinementDecorator enhances the behavior of underlying Refinement objects using
    Decorator design pattern .  

    Although not abstract, this class is thought to be a base class as it simply
    delegates the function calls to the decorated object. Subclasses will implement
    more sophisticated behavior.  

    Constructors
    ------------
    * `RefinementDecorator(refinement)`  

        Constructor.  

        Parameters:  
        * `refinement` :  
            object implementing the core functionality (e.g. refinement with or
            without boundaries).  

    C++ includes: RefinementDecorator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, refinement: "AbstractRefinement"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `refinement` :  
            object implementing the core functionality (e.g. refinement with or without
            boundaries).  

        """
        if self.__class__ == RefinementDecorator:
            _self = None
        else:
            _self = self
        _pysgpp_swig.RefinementDecorator_swiginit(self, _pysgpp_swig.new_RefinementDecorator(_self, refinement))
    __swig_destroy__ = _pysgpp_swig.delete_RefinementDecorator

    def free_refine(self, storage: "HashGridStorage", functor: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to a RefinementFunctor provided.  

        Refines up to RefinementFunctor::getRefinementsNum() grid points if possible,
        and if their refinement value is larger than RefinementFunctor::start() and
        their absolute value is larger or equal than
        RefinementFunctor::getRefinementThreshold()  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  
        * `functor` :  
            a RefinementFunctor specifying the refinement criteria  
        * `addedPoints` :  
            pointer to vector to append newly created grid points to  

        """
        return _pysgpp_swig.RefinementDecorator_free_refine(self, storage, functor, addedPoints)

    def getNumberOfRefinablePoints(self, storage: "HashGridStorage") -> "size_t":
        r"""


        Computes and returns the number of grid points, which can be refined.  

        This is the number of grid points that have at least one child missing.  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  

        Returns
        -------
        The number of grid points that can be refined  

        """
        return _pysgpp_swig.RefinementDecorator_getNumberOfRefinablePoints(self, storage)

    def refineGridpoint1D(self, storage: "HashGridStorage", point: "HashGridPoint", d: "size_t") -> "void":
        r"""


        Refine one grid point along a single direction.  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  
        * `point` :  
            point to refine  
        * `d` :  
            direction  

        """
        return _pysgpp_swig.RefinementDecorator_refineGridpoint1D(self, storage, point, d)

    def checkAdmissibility(self, storage: "HashGridStorage", subspace: "HashGridPoint") -> "bool":
        r"""


        """
        return _pysgpp_swig.RefinementDecorator_checkAdmissibility(self, storage, subspace)

    def refineGridpoint(self, storage: "HashGridStorage", refine_index: "size_t") -> "void":
        return _pysgpp_swig.RefinementDecorator_refineGridpoint(self, storage, refine_index)

    def createGridpoint(self, storage: "HashGridStorage", point: "HashGridPoint") -> "void":
        return _pysgpp_swig.RefinementDecorator_createGridpoint(self, storage, point)

    def collectRefinablePoints(self, storage: "HashGridStorage", functor: "RefinementFunctor", collection: "sgpp::base::AbstractRefinement::refinement_container_type &") -> "void":
        return _pysgpp_swig.RefinementDecorator_collectRefinablePoints(self, storage, functor, collection)

    def refineGridpointsCollection(self, storage: "HashGridStorage", functor: "RefinementFunctor", collection: "sgpp::base::AbstractRefinement::refinement_container_type &") -> "void":
        return _pysgpp_swig.RefinementDecorator_refineGridpointsCollection(self, storage, functor, collection)

    def getIndicator(self, storage: "HashGridStorage", iter: "sgpp::base::GridStorage::grid_map_iterator const &", functor: "RefinementFunctor") -> "sgpp::base::AbstractRefinement::refinement_list_type":
        return _pysgpp_swig.RefinementDecorator_getIndicator(self, storage, iter, functor)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_RefinementDecorator(self)
        return weakref.proxy(self)

    def createGridpointSubroutine(self, storage: "HashGridStorage", point: "HashGridPoint") -> "void":
        return _pysgpp_swig.RefinementDecorator_createGridpointSubroutine(self, storage, point)

    def createGridpoint1D(self, point: "HashGridPoint", d: "size_t", storage: "HashGridStorage", source_index: "sgpp::base::index_t &", source_level: "sgpp::base::level_t &") -> "void":
        return _pysgpp_swig.RefinementDecorator_createGridpoint1D(self, point, d, storage, source_index, source_level)

# Register RefinementDecorator in _pysgpp_swig:
_pysgpp_swig.RefinementDecorator_swigregister(RefinementDecorator)

class HashRefinement(AbstractRefinement):
    r"""


    Free refinement class for sparse grids.  

    C++ includes: HashRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def free_refine(self, storage: "HashGridStorage", functor: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to a RefinementFunctor provided.  

        Refines up to RefinementFunctor::getRefinementsNum() grid points if possible,
        and if their refinement value is larger than RefinementFunctor::start() and
        their absolute value is larger or equal than
        RefinementFunctor::getRefinementThreshold() If addedPoints is supplied and not a
        zero pointer, then newly created grid points are appended to this vector.  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  
        * `functor` :  
            a RefinementFunctor specifying the refinement criteria  
        * `addedPoints` :  
            pointer to vector to append newly created grid points to  

        Assumption: during the refinement process the only change made to the storage is
        the following: New (if any) gridpoints are appended (to the end) of the storage  

        """
        return _pysgpp_swig.HashRefinement_free_refine(self, storage, functor, addedPoints)

    def getNumberOfRefinablePoints(self, storage: "HashGridStorage") -> "size_t":
        r"""


        Computes and returns the number of grid points, which can be refined.  

        This is the number of grid points that have at least one child missing.  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  

        Returns
        -------
        The number of grid points that can be refined  

        """
        return _pysgpp_swig.HashRefinement_getNumberOfRefinablePoints(self, storage)

    def refineGridpoint1D(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `refineGridpoint1D(storage, point, d)`  

            Refine one grid point along a single direction.  

            Parameters:  
            * `storage` :  
                hashmap that stores the grid points  
            * `point` :  
                point to refine  
            * `d` :  
                direction  

        * `refineGridpoint1D(storage, seq, d)`  

            Refine one grid point along a single direction.  

            Parameters:  
            * `storage` :  
                hashmap that stores the grid points  
            * `seq` :  
                sequential number of the grid point  
            * `d` :  
                direction  

        """
        return _pysgpp_swig.HashRefinement_refineGridpoint1D(self, *args)
    __swig_destroy__ = _pysgpp_swig.delete_HashRefinement

    def refineGridpoint(self, storage: "HashGridStorage", refine_index: "size_t") -> "void":
        return _pysgpp_swig.HashRefinement_refineGridpoint(self, storage, refine_index)

    def createGridpoint(self, storage: "HashGridStorage", point: "HashGridPoint") -> "void":
        return _pysgpp_swig.HashRefinement_createGridpoint(self, storage, point)

    def collectRefinablePoints(self, storage: "HashGridStorage", functor: "RefinementFunctor", collection: "sgpp::base::AbstractRefinement::refinement_container_type &") -> "void":
        return _pysgpp_swig.HashRefinement_collectRefinablePoints(self, storage, functor, collection)

    def refineGridpointsCollection(self, storage: "HashGridStorage", functor: "RefinementFunctor", collection: "sgpp::base::AbstractRefinement::refinement_container_type &") -> "void":
        return _pysgpp_swig.HashRefinement_refineGridpointsCollection(self, storage, functor, collection)

    def addElementToCollection(self, iter: "sgpp::base::GridStorage::grid_map_iterator const &", current_value_list: "sgpp::base::AbstractRefinement::refinement_list_type", refinements_num: "size_t", collection: "sgpp::base::AbstractRefinement::refinement_container_type &") -> "void":
        return _pysgpp_swig.HashRefinement_addElementToCollection(self, iter, current_value_list, refinements_num, collection)

    def getIndicator(self, storage: "HashGridStorage", iter: "sgpp::base::GridStorage::grid_map_iterator const &", functor: "RefinementFunctor") -> "sgpp::base::AbstractRefinement::refinement_list_type":
        return _pysgpp_swig.HashRefinement_getIndicator(self, storage, iter, functor)

    def __init__(self):
        if self.__class__ == HashRefinement:
            _self = None
        else:
            _self = self
        _pysgpp_swig.HashRefinement_swiginit(self, _pysgpp_swig.new_HashRefinement(_self, ))
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_HashRefinement(self)
        return weakref.proxy(self)

    def createGridpointSubroutine(self, storage: "HashGridStorage", point: "HashGridPoint") -> "void":
        return _pysgpp_swig.HashRefinement_createGridpointSubroutine(self, storage, point)

    def createGridpoint1D(self, point: "HashGridPoint", d: "size_t", storage: "HashGridStorage", source_index: "sgpp::base::index_t &", source_level: "sgpp::base::level_t &") -> "void":
        return _pysgpp_swig.HashRefinement_createGridpoint1D(self, point, d, storage, source_index, source_level)

# Register HashRefinement in _pysgpp_swig:
_pysgpp_swig.HashRefinement_swigregister(HashRefinement)

class HashCoarsening(object):
    r"""


    Standard free coarsening class for sparse grids, only inner grid points can be
    removed.  

    C++ includes: HashCoarsening.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def free_coarsen_NFirstOnly(self, storage: "HashGridStorage", functor: "CoarseningFunctor", numFirstPoints: "size_t", minIndexConsidered: "size_t"=0, removedPoints: "std::vector< sgpp::base::HashGridPoint,std::allocator< sgpp::base::HashGridPoint > > *"=None, removedSeq: "SizeVector"=None) -> "void":
        r"""


        Performs coarsening on grid.  

        It's possible to remove a certain number of gridpoints in one coarsening step.
        This number is specified within the declaration of the coarsening functor. Also
        the coarsening threshold is specified in the coarsening functor. ONLY INNER GRID
        POINTS WILL BE REMOVED!  

        Here only the numFirstPoints are regarded for coarsening, later points are
        skipped.  

        Note that seq numbers in  

        Parameters
        ----------
        * `removedSeq` :  
            are invalid to use with the resulting grid after coarsening since the seq
            numbers get recomputed after removal. Use  
        * `removedPoints` :  
            unless outdated seq numbers are explicitly required.  
        * `storage` :  
            hashmap that stores the grid points  
        * `functor` :  
            a function used to determine if refinement is needed  
        * `numFirstPoints` :  
            number of grid points that are regarded to be coarsened  
        * `minIndexConsidered` :  
            indices of coarsen point candidates must be higher than this parameter to be
            allowed to get coarsened  
        * `removedPoints` :  
            pointer to vector to append coarsened (removed) grid points to  
        * `removedSeq` :  
            pointer to vector to append the seq numbers of coarsened grid points to  

        """
        return _pysgpp_swig.HashCoarsening_free_coarsen_NFirstOnly(self, storage, functor, numFirstPoints, minIndexConsidered, removedPoints, removedSeq)

    def free_coarsen(self, storage: "HashGridStorage", functor: "CoarseningFunctor", removedPoints: "std::vector< sgpp::base::HashGridPoint,std::allocator< sgpp::base::HashGridPoint > > *"=None, removedSeq: "SizeVector"=None) -> "void":
        r"""


        Performs coarsening on grid.  

        It's possible to remove a certain number of gridpoints in one coarsening step.
        This number is specified within the declaration of the coarsening functor. Also
        the coarsening threshold is specified in the coarsening functor. ONLY INNER GRID
        POINTS WILL BE REMOVED!  

        This function calls free_coarsen_NFirstOnly with numFirstPoints equal to the
        grid's size.  

        Note that seq numbers in  

        Parameters
        ----------
        * `removedSeq` :  
            are invalid to use with the resulting grid after coarsening since the seq
            numbers get recomputed after removal. Use  
        * `removedPoints` :  
            unless outdated seq numbers are explicitly required.  
        * `storage` :  
            hashmap that stores the grid points  
        * `functor` :  
            a function used to determine if refinement is needed  
        * `removedPoints` :  
            pointer to vector to append coarsened (removed) grid points to  
        * `removedSeq` :  
            pointer to vector to append the seq numbers of coarsened grid points to.  

        """
        return _pysgpp_swig.HashCoarsening_free_coarsen(self, storage, functor, removedPoints, removedSeq)

    def getNumberOfRemovablePoints(self, storage: "HashGridStorage") -> "size_t":
        r"""


        Calculates the number of points, which can be refined.  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  

        """
        return _pysgpp_swig.HashCoarsening_getNumberOfRemovablePoints(self, storage)

    def __init__(self):
        _pysgpp_swig.HashCoarsening_swiginit(self, _pysgpp_swig.new_HashCoarsening())
    __swig_destroy__ = _pysgpp_swig.delete_HashCoarsening

# Register HashCoarsening in _pysgpp_swig:
_pysgpp_swig.HashCoarsening_swigregister(HashCoarsening)

class HashRefinementBoundaries(AbstractRefinement):
    r"""


    Standard free refinement class for sparse grids with boundaries.  

    C++ includes: HashRefinementBoundaries.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def free_refine(self, storage: "HashGridStorage", functor: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Performs the refinement on grid.  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  
        * `functor` :  
            a function used to determine if refinement is needed  
        * `addedPoints` :  
            pointer to vector to append newly created grid points to  

        Assumption: during the refinement process the only change made to the storage is
        the following: New (if any) gridpoints are appended (to the end) of the storage  

        """
        return _pysgpp_swig.HashRefinementBoundaries_free_refine(self, storage, functor, addedPoints)

    def __init__(self):
        _pysgpp_swig.HashRefinementBoundaries_swiginit(self, _pysgpp_swig.new_HashRefinementBoundaries())
    __swig_destroy__ = _pysgpp_swig.delete_HashRefinementBoundaries

# Register HashRefinementBoundaries in _pysgpp_swig:
_pysgpp_swig.HashRefinementBoundaries_swigregister(HashRefinementBoundaries)

class ANOVAHashRefinement(HashRefinement):
    r"""


    C++ includes: ANOVAHashRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def refineGridpoint(self, storage: "HashGridStorage", refine_index: "size_t") -> "void":
        r"""


        This method refines a grid point by generating the children in every dimension
        of the grid where the level is greater than 1 and all their missing ancestors by
        calling create_gridpoint().  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the gridpoints  
        * `refine_index` :  
            The index in the hashmap of the point that should be refined  

        """
        return _pysgpp_swig.ANOVAHashRefinement_refineGridpoint(self, storage, refine_index)

    def __init__(self):
        _pysgpp_swig.ANOVAHashRefinement_swiginit(self, _pysgpp_swig.new_ANOVAHashRefinement())
    __swig_destroy__ = _pysgpp_swig.delete_ANOVAHashRefinement

# Register ANOVAHashRefinement in _pysgpp_swig:
_pysgpp_swig.ANOVAHashRefinement_swigregister(ANOVAHashRefinement)

class SubspaceRefinement(RefinementDecorator):
    r"""

    `SubspaceRefinement(refinement)`  

    Constructors
    ------------
    * `SubspaceRefinement(refinement)`  

        Constructor.  

        Parameters:  
        * `refinement` :  
            decorated refinement object  

    C++ includes: SubspaceRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, refinement: "AbstractRefinement"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `refinement` :  
            decorated refinement object  

        """
        if self.__class__ == SubspaceRefinement:
            _self = None
        else:
            _self = self
        _pysgpp_swig.SubspaceRefinement_swiginit(self, _pysgpp_swig.new_SubspaceRefinement(_self, refinement))

    def free_refine(self, storage: "HashGridStorage", functor: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to a RefinementFunctor provided.  

        Refines up to RefinementFunctor::getRefinementsNum() grid points if possible,
        and if their refinement value is larger than RefinementFunctor::start() and
        their absolute value is larger or equal than
        RefinementFunctor::getRefinementThreshold()  

        Parameters
        ----------
        * `storage` :  
            hashmap that stores the grid points  
        * `functor` :  
            a RefinementFunctor specifying the refinement criteria  
        * `addedPoints` :  
            pointer to vector to append newly created grid points to  

        Assumption: during the refinement process the only change made to the storage is
        the following: New (if any) gridpoints are appended (to the end) of the storage  

        """
        return _pysgpp_swig.SubspaceRefinement_free_refine(self, storage, functor, addedPoints)
    __swig_destroy__ = _pysgpp_swig.delete_SubspaceRefinement

    def collectRefinablePoints(self, storage: "HashGridStorage", functor: "RefinementFunctor", collection: "sgpp::base::AbstractRefinement::refinement_container_type &") -> "void":
        return _pysgpp_swig.SubspaceRefinement_collectRefinablePoints(self, storage, functor, collection)

    def refineGridpointsCollection(self, storage: "HashGridStorage", functor: "RefinementFunctor", collection: "sgpp::base::AbstractRefinement::refinement_container_type &") -> "void":
        return _pysgpp_swig.SubspaceRefinement_refineGridpointsCollection(self, storage, functor, collection)

    def addElementToCollection(self, iter: "sgpp::base::GridStorage::grid_map_iterator const &", current_value_list: "sgpp::base::AbstractRefinement::refinement_list_type", refinement_num: "size_t", collection: "sgpp::base::AbstractRefinement::refinement_container_type &") -> "void":
        return _pysgpp_swig.SubspaceRefinement_addElementToCollection(self, iter, current_value_list, refinement_num, collection)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_SubspaceRefinement(self)
        return weakref.proxy(self)

    def refineGridpoint(self, storage: "HashGridStorage", refine_index: "size_t") -> "void":
        return _pysgpp_swig.SubspaceRefinement_refineGridpoint(self, storage, refine_index)

    def createGridpoint(self, storage: "HashGridStorage", point: "HashGridPoint") -> "void":
        return _pysgpp_swig.SubspaceRefinement_createGridpoint(self, storage, point)

    def createGridpointSubroutine(self, storage: "HashGridStorage", point: "HashGridPoint") -> "void":
        return _pysgpp_swig.SubspaceRefinement_createGridpointSubroutine(self, storage, point)

    def createGridpoint1D(self, point: "HashGridPoint", d: "size_t", storage: "HashGridStorage", source_index: "sgpp::base::index_t &", source_level: "sgpp::base::level_t &") -> "void":
        return _pysgpp_swig.SubspaceRefinement_createGridpoint1D(self, point, d, storage, source_index, source_level)

    def getIndicator(self, storage: "HashGridStorage", iter: "sgpp::base::GridStorage::grid_map_iterator const &", functor: "RefinementFunctor") -> "sgpp::base::AbstractRefinement::refinement_list_type":
        return _pysgpp_swig.SubspaceRefinement_getIndicator(self, storage, iter, functor)

# Register SubspaceRefinement in _pysgpp_swig:
_pysgpp_swig.SubspaceRefinement_swigregister(SubspaceRefinement)

class PredictiveRefinementIndicator(RefinementFunctor):
    r"""

    `PredictiveRefinementIndicator(grid, dataSet, errorVector, refinements_num=1,
        threshold=0.0, minSupportPoints=0)`  

    A refinement error indicator for regression problems based on the residuals of
    the datasets.  

    It calculates an error messure based on the information from the data set: For a
    new grid point g on level l and index i, it calculates the indicator as a sum of
    squared residuals ( (value of sample from dataset - grid evaluated at the
    sample's coordinates), squared), weighted with the underlying basis function of
    the grid point.  

    Constructors
    ------------
    * `PredictiveRefinementIndicator(grid, dataSet, errorVector, refinements_num=1,
        threshold=0.0, minSupportPoints=0)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            DataVector that is basis for refinement decisions. The i-th entry
            corresponds to the i-th grid point.  
        * `dataSet` :  
            contains all points of the source data set. Each row contains
            coordinates of a single grid point, without the function evaluation
            (meaning only data from omega).  
        * `errorVector` :  
            a DataVector containing the squared absolute error (given value of data
            point - evaluation of sparse grid at the data point position) for each
            grid point in dataSet.  
        * `refinements_num` :  
            the amount of grid points to maximally be refined or created, depending
            on refinement strategy.  
        * `threshold` :  
            The absolute value of the entries have to be greater or equal than the
            threshold  
        * `minSupportPoints` :  
            The minimal number of data points that have to be within the support of
            a basis function for refinement.  

    C++ includes: PredictiveRefinementIndicator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", dataSet: "DataMatrix", errorVector: "DataVector", refinements_num: "size_t"=1, threshold: "double"=0.0, minSupportPoints: "uint64_t"=0):
        r"""


        Constructor.  

        Parameters
        ----------
        * `grid` :  
            DataVector that is basis for refinement decisions. The i-th entry
            corresponds to the i-th grid point.  
        * `dataSet` :  
            contains all points of the source data set. Each row contains coordinates of
            a single grid point, without the function evaluation (meaning only data from
            omega).  
        * `errorVector` :  
            a DataVector containing the squared absolute error (given value of data
            point - evaluation of sparse grid at the data point position) for each grid
            point in dataSet.  
        * `refinements_num` :  
            the amount of grid points to maximally be refined or created, depending on
            refinement strategy.  
        * `threshold` :  
            The absolute value of the entries have to be greater or equal than the
            threshold  
        * `minSupportPoints` :  
            The minimal number of data points that have to be within the support of a
            basis function for refinement.  

        """
        _pysgpp_swig.PredictiveRefinementIndicator_swiginit(self, _pysgpp_swig.new_PredictiveRefinementIndicator(grid, dataSet, errorVector, refinements_num, threshold, minSupportPoints))
    __swig_destroy__ = _pysgpp_swig.delete_PredictiveRefinementIndicator

    def runOperator(self, storage: "HashGridStorage", seq: "size_t") -> "double":
        r"""


        """
        return _pysgpp_swig.PredictiveRefinementIndicator_runOperator(self, storage, seq)

    def getMinSupportPoints(self) -> "uint64_t":
        r"""


        Returns the lower bound of refinement criterion (e.g., alpha or error.  

        """
        return _pysgpp_swig.PredictiveRefinementIndicator_getMinSupportPoints(self)

    def setMinSupportPoints(self, minSupportPoints: "uint64_t") -> "void":
        r"""


        """
        return _pysgpp_swig.PredictiveRefinementIndicator_setMinSupportPoints(self, minSupportPoints)

    def __call__(self, *args) -> "double":
        return _pysgpp_swig.PredictiveRefinementIndicator___call__(self, *args)

# Register PredictiveRefinementIndicator in _pysgpp_swig:
_pysgpp_swig.PredictiveRefinementIndicator_swigregister(PredictiveRefinementIndicator)

class PredictiveRefinement_refinement_key(AbstractRefinement_refinement_key):
    r"""

    `PredictiveRefinement_refinement_key(point, seq, dim)`  

    Container type for predictive refinement collection.  

    Constructors
    ------------
    * `PredictiveRefinement_refinement_key(point, seq, dim)`  

        Constructor.  

        Parameters:  
        * `point` :  
            grid point  
        * `seq` :  
            sequence number in the hash grid storage  
        * `dim` :  
            dimensionality  

    C++ includes: PredictiveRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, point: "HashGridPoint", seq: "size_t", dim: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `point` :  
            grid point  
        * `seq` :  
            sequence number in the hash grid storage  
        * `dim` :  
            dimensionality  

        """
        _pysgpp_swig.PredictiveRefinement_refinement_key_swiginit(self, _pysgpp_swig.new_PredictiveRefinement_refinement_key(point, seq, dim))

    def getDim(self) -> "size_t":
        r"""


        Returns dimensionality.  

        Returns
        -------
        dimensionality  

        """
        return _pysgpp_swig.PredictiveRefinement_refinement_key_getDim(self)
    __swig_destroy__ = _pysgpp_swig.delete_PredictiveRefinement_refinement_key

# Register PredictiveRefinement_refinement_key in _pysgpp_swig:
_pysgpp_swig.PredictiveRefinement_refinement_key_swigregister(PredictiveRefinement_refinement_key)

class PredictiveRefinement(RefinementDecorator):
    r"""

    `PredictiveRefinement(refinement)`  

    Constructors
    ------------
    * `PredictiveRefinement(refinement)`  

    C++ includes: PredictiveRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, refinement: "AbstractRefinement"):
        r"""


        """
        _pysgpp_swig.PredictiveRefinement_swiginit(self, _pysgpp_swig.new_PredictiveRefinement(refinement))

    def free_refine(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `free_refine(storage, functor, addedPoints=nullptr)`  

            Refines a grid according to a RefinementFunctor provided.  

            Refines up to RefinementFunctor::getRefinementsNum() grid points if
            possible, and if their refinement value is larger than
            RefinementFunctor::start() and their absolute value is larger or equal than
            RefinementFunctor::getRefinementThreshold()  

            Parameters:  
            * `storage` :  
                hashmap that stores the grid points  
            * `functor` :  
                a RefinementFunctor specifying the refinement criteria  
            * `addedPoints` :  
                pointer to vector to append newly created grid points to  

            Assumption: during the refinement process the only change made to the
            storage is the following: New (if any) gridpoints are appended (to the end)
            of the storage  

        * `free_refine(storage, functor, addedPoints=nullptr)`  

            Refines a grid according to a RefinementFunctor provided.  

            Refines up to RefinementFunctor::getRefinementsNum() grid points if
            possible, and if their refinement value is larger than
            RefinementFunctor::start() and their absolute value is larger or equal than
            RefinementFunctor::getRefinementThreshold()  

            Parameters:  
            * `storage` :  
                hashmap that stores the grid points  
            * `functor` :  
                a RefinementFunctor specifying the refinement criteria  
            * `addedPoints` :  
                pointer to vector to append newly created grid points to  

        """
        return _pysgpp_swig.PredictiveRefinement_free_refine(self, *args)

    def setAlpha(self, alpha: "DataVector") -> "void":
        r"""


        Setter for the alpha vector.  

        Parameters
        ----------
        * `alpha` :  

        """
        return _pysgpp_swig.PredictiveRefinement_setAlpha(self, alpha)
    __swig_destroy__ = _pysgpp_swig.delete_PredictiveRefinement

# Register PredictiveRefinement in _pysgpp_swig:
_pysgpp_swig.PredictiveRefinement_swigregister(PredictiveRefinement)

class ForwardSelectorRefinementIndicator(RefinementFunctor):
    r"""

    `ForwardSelectorRefinementIndicator(grid, svs, alphas, w1, w2, beta,
        threshold=0.0, refinementsNum=1, performUpdate=true)`  

    A refinement indicator for support vector classification using sparse grids
    (according to Knig BA).  

    Constructors
    ------------
    * `ForwardSelectorRefinementIndicator(grid, svs, alphas, w1, w2, beta,
        threshold=0.0, refinementsNum=1, performUpdate=true)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            The sparse grid  
        * `svs` :  
            Contains all currently stored support vectors  
        * `alphas` :  
            The weights corresponding to the support vectors  
        * `w1` :  
            The normal vector  
        * `w2` :  
            The normal vector computted with abs weights  
        * `beta` :  
            Specifies relevance of grid points (default: equal relevance for all
            grid points)  
        * `threshold` :  
            The refinement threshold; Only grid points with indicator values greater
            than this threshold will be refined  
        * `refinementsNum` :  
            The max amount of grid points to be refined  
        * `performUpdate` :  
            Specifies if normal vector should be updated after refinement  

    C++ includes: ForwardSelectorRefinementIndicator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", svs: "DataMatrix", alphas: "DataVector", w1: "DataVector", w2: "DataVector", beta: "double", threshold: "double"=0.0, refinementsNum: "size_t"=1, performUpdate: "bool"=True):
        r"""


        Constructor.  

        Parameters
        ----------
        * `grid` :  
            The sparse grid  
        * `svs` :  
            Contains all currently stored support vectors  
        * `alphas` :  
            The weights corresponding to the support vectors  
        * `w1` :  
            The normal vector  
        * `w2` :  
            The normal vector computted with abs weights  
        * `beta` :  
            Specifies relevance of grid points (default: equal relevance for all grid
            points)  
        * `threshold` :  
            The refinement threshold; Only grid points with indicator values greater
            than this threshold will be refined  
        * `refinementsNum` :  
            The max amount of grid points to be refined  
        * `performUpdate` :  
            Specifies if normal vector should be updated after refinement  

        """
        _pysgpp_swig.ForwardSelectorRefinementIndicator_swiginit(self, _pysgpp_swig.new_ForwardSelectorRefinementIndicator(grid, svs, alphas, w1, w2, beta, threshold, refinementsNum, performUpdate))

    def runOperator(self, storage: "HashGridStorage", seq: "size_t") -> "double":
        r"""


        """
        return _pysgpp_swig.ForwardSelectorRefinementIndicator_runOperator(self, storage, seq)

    def __call__(self, *args) -> "double":
        return _pysgpp_swig.ForwardSelectorRefinementIndicator___call__(self, *args)

    def update(self, point: "HashGridPoint") -> "void":
        r"""


        Update normal vector of SVM.  

        For each new grid point the normal vector has to be extended by one component.  

        Parameters
        ----------
        * `point` :  
            The new grid point  

        """
        return _pysgpp_swig.ForwardSelectorRefinementIndicator_update(self, point)
    __swig_destroy__ = _pysgpp_swig.delete_ForwardSelectorRefinementIndicator

# Register ForwardSelectorRefinementIndicator in _pysgpp_swig:
_pysgpp_swig.ForwardSelectorRefinementIndicator_swigregister(ForwardSelectorRefinementIndicator)

class ForwardSelectorRefinement_refinement_key(AbstractRefinement_refinement_key):
    r"""

    `ForwardSelectorRefinement_refinement_key(point, seq, dim)`  

    Container type for forward selector (combined-measure) refinement collection.  

    Constructors
    ------------
    * `ForwardSelectorRefinement_refinement_key(point, seq, dim)`  

        Constructor.  

        Parameters:  
        * `point` :  
            grid point  
        * `seq` :  
            sequence number in the hash grid storage  
        * `dim` :  
            dimensionality  

    C++ includes: ForwardSelectorRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, point: "HashGridPoint", seq: "size_t", dim: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `point` :  
            grid point  
        * `seq` :  
            sequence number in the hash grid storage  
        * `dim` :  
            dimensionality  

        """
        _pysgpp_swig.ForwardSelectorRefinement_refinement_key_swiginit(self, _pysgpp_swig.new_ForwardSelectorRefinement_refinement_key(point, seq, dim))

    def getDim(self) -> "size_t":
        r"""


        Returns dimensionality.  

        Returns
        -------
        dimensionality  

        """
        return _pysgpp_swig.ForwardSelectorRefinement_refinement_key_getDim(self)
    __swig_destroy__ = _pysgpp_swig.delete_ForwardSelectorRefinement_refinement_key

# Register ForwardSelectorRefinement_refinement_key in _pysgpp_swig:
_pysgpp_swig.ForwardSelectorRefinement_refinement_key_swigregister(ForwardSelectorRefinement_refinement_key)

class ForwardSelectorRefinement(RefinementDecorator):
    r"""

    `ForwardSelectorRefinement(refinement)`  

    Constructors
    ------------
    * `ForwardSelectorRefinement(refinement)`  

    C++ includes: ForwardSelectorRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, refinement: "AbstractRefinement"):
        r"""


        """
        _pysgpp_swig.ForwardSelectorRefinement_swiginit(self, _pysgpp_swig.new_ForwardSelectorRefinement(refinement))

    def free_refine(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `free_refine(storage, functor)`  

            Refines a grid according to the ForwardSelectorRefinementIndicator provided.  

            Parameters:  
            * `storage` :  
                Hashmap that stores the grid points  
            * `functor` :  
                A RefinementFunctor specifying the refinement criteria  

        * `free_refine(storage, functor, addedPoints=nullptr)`  

            Refines a grid according to a RefinementFunctor provided.  

            Refines up to RefinementFunctor::getRefinementsNum() grid points if
            possible, and if their refinement value is larger than
            RefinementFunctor::start() and their absolute value is larger or equal than
            RefinementFunctor::getRefinementThreshold()  

            Parameters:  
            * `storage` :  
                hashmap that stores the grid points  
            * `functor` :  
                a RefinementFunctor specifying the refinement criteria  
            * `addedPoints` :  
                pointer to vector to append newly created grid points to  

        """
        return _pysgpp_swig.ForwardSelectorRefinement_free_refine(self, *args)
    __swig_destroy__ = _pysgpp_swig.delete_ForwardSelectorRefinement

# Register ForwardSelectorRefinement in _pysgpp_swig:
_pysgpp_swig.ForwardSelectorRefinement_swigregister(ForwardSelectorRefinement)

class ImpurityRefinementIndicator(RefinementFunctor):
    r"""

    `ImpurityRefinementIndicator(grid, dataset, alphas, w1, w2, classesComputed,
        threshold=0.0, refinementsNum=1)`  

    A refinement indicator for classification problems based on impurity measures
    (e.g.  

    gini impurity, entropy impurity,...). It calculates local impurities based on
    the information from the provided data set. If the indicator is applied within
    the SVM learner, the normal vector needs to be extended after each refinement.  

    Constructors
    ------------
    * `ImpurityRefinementIndicator(grid, dataset, alphas, w1, w2, classesComputed,
        threshold=0.0, refinementsNum=1)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            The grid to refine.  
        * `dataset` :  
            The set of data points used to compute impurities  
        * `alphas` :  
            The weights corresponding to the support vectors (only required for SVM
            learner)  
        * `w1` :  
            Normal vector (only required for SVM learner)  
        * `w2` :  
            Normal vector computed with abs values (only required for SVM learner)  
        * `classesComputed` :  
            The predicted labels for the data points from dataset  
        * `threshold` :  
            The refinement threshold; Only grid points with indicator values greater
            than this threshold will be refined  
        * `refinementsNum` :  
            The max amount of grid points to be refined  

    C++ includes: ImpurityRefinementIndicator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", dataset: "DataMatrix", alphas: "DataVector", w1: "DataVector", w2: "DataVector", classesComputed: "DataVector", threshold: "double"=0.0, refinementsNum: "size_t"=1):
        r"""


        Constructor.  

        Parameters
        ----------
        * `grid` :  
            The grid to refine.  
        * `dataset` :  
            The set of data points used to compute impurities  
        * `alphas` :  
            The weights corresponding to the support vectors (only required for SVM
            learner)  
        * `w1` :  
            Normal vector (only required for SVM learner)  
        * `w2` :  
            Normal vector computed with abs values (only required for SVM learner)  
        * `classesComputed` :  
            The predicted labels for the data points from dataset  
        * `threshold` :  
            The refinement threshold; Only grid points with indicator values greater
            than this threshold will be refined  
        * `refinementsNum` :  
            The max amount of grid points to be refined  

        """
        _pysgpp_swig.ImpurityRefinementIndicator_swiginit(self, _pysgpp_swig.new_ImpurityRefinementIndicator(grid, dataset, alphas, w1, w2, classesComputed, threshold, refinementsNum))

    def __call__(self, *args) -> "double":
        return _pysgpp_swig.ImpurityRefinementIndicator___call__(self, *args)

    def update(self, point: "HashGridPoint") -> "void":
        r"""


        Update normal vector of SVM.  

        For each new grid point the normal vector has to be extended by one component.
        Only required for SVMLearner!  

        Parameters
        ----------
        * `point` :  
            The new grid point  

        """
        return _pysgpp_swig.ImpurityRefinementIndicator_update(self, point)
    alphas = property(_pysgpp_swig.ImpurityRefinementIndicator_alphas_get, _pysgpp_swig.ImpurityRefinementIndicator_alphas_set)
    w1 = property(_pysgpp_swig.ImpurityRefinementIndicator_w1_get, _pysgpp_swig.ImpurityRefinementIndicator_w1_set)
    w2 = property(_pysgpp_swig.ImpurityRefinementIndicator_w2_get, _pysgpp_swig.ImpurityRefinementIndicator_w2_set)
    __swig_destroy__ = _pysgpp_swig.delete_ImpurityRefinementIndicator

# Register ImpurityRefinementIndicator in _pysgpp_swig:
_pysgpp_swig.ImpurityRefinementIndicator_swigregister(ImpurityRefinementIndicator)

class ImpurityRefinement_refinement_key(AbstractRefinement_refinement_key):
    r"""

    `ImpurityRefinement_refinement_key(point, seq, dim)`  

    Container type for impurity refinement collection.  

    Constructors
    ------------
    * `ImpurityRefinement_refinement_key(point, seq, dim)`  

        Constructor.  

        Parameters:  
        * `point` :  
            grid point  
        * `seq` :  
            sequence number in the hash grid storage  
        * `dim` :  
            dimensionality  

    C++ includes: ImpurityRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, point: "HashGridPoint", seq: "size_t", dim: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `point` :  
            grid point  
        * `seq` :  
            sequence number in the hash grid storage  
        * `dim` :  
            dimensionality  

        """
        _pysgpp_swig.ImpurityRefinement_refinement_key_swiginit(self, _pysgpp_swig.new_ImpurityRefinement_refinement_key(point, seq, dim))

    def getDim(self) -> "size_t":
        r"""


        Returns dimensionality.  

        Returns
        -------
        dimensionality  

        """
        return _pysgpp_swig.ImpurityRefinement_refinement_key_getDim(self)
    __swig_destroy__ = _pysgpp_swig.delete_ImpurityRefinement_refinement_key

# Register ImpurityRefinement_refinement_key in _pysgpp_swig:
_pysgpp_swig.ImpurityRefinement_refinement_key_swigregister(ImpurityRefinement_refinement_key)

class ImpurityRefinement(RefinementDecorator):
    r"""

    `ImpurityRefinement(refinement)`  

    Constructors
    ------------
    * `ImpurityRefinement(refinement)`  

    C++ includes: ImpurityRefinement.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, refinement: "AbstractRefinement"):
        r"""


        """
        _pysgpp_swig.ImpurityRefinement_swiginit(self, _pysgpp_swig.new_ImpurityRefinement(refinement))

    def free_refine(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `free_refine(storage, functor)`  

            Refines a grid according to the impurity refinement indicator provided.  

            Parameters:  
            * `storage` :  
                Hashmap that stores the grid points  
            * `functor` :  
                A RefinementFunctor specifying the refinement criteria  

        * `free_refine(storage, functor, addedPoints=nullptr)`  

            Refines a grid according to a RefinementFunctor provided.  

            Refines up to RefinementFunctor::getRefinementsNum() grid points if
            possible, and if their refinement value is larger than
            RefinementFunctor::start() and their absolute value is larger or equal than
            RefinementFunctor::getRefinementThreshold()  

            Parameters:  
            * `storage` :  
                hashmap that stores the grid points  
            * `functor` :  
                a RefinementFunctor specifying the refinement criteria  
            * `addedPoints` :  
                pointer to vector to append newly created grid points to  

        """
        return _pysgpp_swig.ImpurityRefinement_free_refine(self, *args)
    __swig_destroy__ = _pysgpp_swig.delete_ImpurityRefinement

# Register ImpurityRefinement in _pysgpp_swig:
_pysgpp_swig.ImpurityRefinement_swigregister(ImpurityRefinement)

class StandardGridGenerator(GridGenerator):
    r"""

    `StandardGridGenerator(storage)`  

    GridGenerator for standard grids without boundaries.  

    Constructors
    ------------
    * `StandardGridGenerator(storage)`  

        Constructor.  

        Parameters:  
        * `storage` :  
            the grid's storage object  

    C++ includes: StandardGridGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `storage` :  
            the grid's storage object  

        """
        _pysgpp_swig.StandardGridGenerator_swiginit(self, _pysgpp_swig.new_StandardGridGenerator(storage))
    __swig_destroy__ = _pysgpp_swig.delete_StandardGridGenerator

    def regular(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `regular(level)`  

            Creates a regular sparse grid for a certain level $ n $, i.e., $ *V_n^{(1)}
            = *\bigoplus_{|\vec{l}|_1 \leq n+d-1} W_{\vec{l}}$.  

            Parameters:  
            * `level` :  
                Grid level  

        * `regular(level, T)`  

            Creates a regular sparse grid for a certain level $ n $, i.e., $ *V_n^{(1)}
            = *\bigoplus_{|\vec{l}|_1 \leq n+d-1} W_{\vec{l}}$.  

            If the used grid doesn't support the parameter t, t = 0 is used instead.  

            Parameters:  
            * `level` :  
                Grid level  
            * `T` :  
                modifier for subgrid selection, T = 0 implies standard sparse grid. For
                further information see Griebel and Knapek's paper optimized tensor-
                product approximation spaces  

        """
        return _pysgpp_swig.StandardGridGenerator_regular(self, *args)

    def cliques(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `cliques(level, clique_size)`  

            Creates a sparse grid with fully connected cliques.  

            Parameters:  
            * `level` :  
                Grid level  
            * `clique_size` :  
                clique size  

        * `cliques(level, clique_size, T)`  

            Creates a sparse grid with fully connected cliques.  

            Parameters:  
            * `level` :  
                Grid level  
            * `clique_size` :  
                clique size  
            * `T` :  
                modifier for subgrid selection, T = 0 implies standard sparse grid. For
                further information see Griebel and Knapek's paper optimized tensor-
                product approximation spaces  

        """
        return _pysgpp_swig.StandardGridGenerator_cliques(self, *args)

    def refine(self, func: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to the settings of the RefinementFunctor func.  

        Parameters
        ----------
        * `func` :  
            reference to refinement functor  
        * `addedPoints` :  
            pointer to vector to add newly created grid points to  

        """
        return _pysgpp_swig.StandardGridGenerator_refine(self, func, addedPoints)

    def refineInter(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `refineInter(func, interactions)`  

            Refines a grid according to the settings of the RefinementFunctor func.  

            Does not create any interactions, that are not in the list of allowed
            interactions.  

            Refines the grid, but only adds interactions that are contained in the set
            interactions, i.e. only desired interactions. Each desired interaction is
            encoded as a vector which contains all desired interactions. For example, if
            we want to include grid points that model an interaction between the first
            and the second predictor, we would include the vector [1,2] in interactions.  

            Parameters:  
            * `func` :  
                pointer to refinement functor  
            * `interactions` :  
                allowed interactions  

        * `refineInter(func, interactions)`  

        """
        return _pysgpp_swig.StandardGridGenerator_refineInter(self, *args)

# Register StandardGridGenerator in _pysgpp_swig:
_pysgpp_swig.StandardGridGenerator_swigregister(StandardGridGenerator)

class L0BoundaryGridGenerator(GridGenerator):
    r"""

    `L0BoundaryGridGenerator(storage)`  

    This class provides the interface for the grid generation for grids with
    boundaries, diagonal cut through sub space scheme.  

    Constructors
    ------------
    * `L0BoundaryGridGenerator(storage)`  

        Constructor.  

        Parameters:  
        * `storage` :  
            template type that holds the grid points  

    C++ includes: L0BoundaryGridGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `storage` :  
            template type that holds the grid points  

        """
        _pysgpp_swig.L0BoundaryGridGenerator_swiginit(self, _pysgpp_swig.new_L0BoundaryGridGenerator(storage))
    __swig_destroy__ = _pysgpp_swig.delete_L0BoundaryGridGenerator

    def refine(self, func: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to the settings of the RefinementFunctor func.  

        Parameters
        ----------
        * `func` :  
            reference to refinement functor  
        * `addedPoints` :  
            pointer to vector to add newly created grid points to  

        """
        return _pysgpp_swig.L0BoundaryGridGenerator_refine(self, func, addedPoints)

# Register L0BoundaryGridGenerator in _pysgpp_swig:
_pysgpp_swig.L0BoundaryGridGenerator_swigregister(L0BoundaryGridGenerator)

class PrewaveletGridGenerator(GridGenerator):
    r"""

    `PrewaveletGridGenerator(storage, shadowstorage)`  

    GridGenerator for prewavelet grids without boundaries.  

    Constructors
    ------------
    * `PrewaveletGridGenerator(storage, shadowstorage)`  

        Constructor An adaptive grid with prewavelet ansatz functions requires for
        operations using the up-down algorithm shadow points.  

        These shadow points a needed just for data transport, thus they do not have
        an influence on the final function. Please refer to
        sgpp::pde::UpDownOneOpDimWithShadow for more information.  

        Parameters:  
        * `storage` :  
            the grid storage object of the the grid, on which the hierarchisation
            should be executed  
        * `shadowstorage` :  
            shadow points (see detailed description)  

    C++ includes: PrewaveletGridGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage", shadowstorage: "HashGridStorage"):
        r"""


        Constructor An adaptive grid with prewavelet ansatz functions requires for
        operations using the up-down algorithm shadow points.  

        These shadow points a needed just for data transport, thus they do not have an
        influence on the final function. Please refer to
        sgpp::pde::UpDownOneOpDimWithShadow for more information.  

        Parameters
        ----------
        * `storage` :  
            the grid storage object of the the grid, on which the hierarchisation should
            be executed  
        * `shadowstorage` :  
            shadow points (see detailed description)  

        """
        _pysgpp_swig.PrewaveletGridGenerator_swiginit(self, _pysgpp_swig.new_PrewaveletGridGenerator(storage, shadowstorage))
    __swig_destroy__ = _pysgpp_swig.delete_PrewaveletGridGenerator

    def regular(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `regular(level)`  

            Creates a regular sparse grid for a certain level $ n $, i.e., $ *V_n^{(1)}
            = *\bigoplus_{|\vec{l}|_1 \leq n+d-1} W_{\vec{l}}$.  

            Parameters:  
            * `level` :  
                Grid level  

        * `regular(level, T)`  

            Creates a regular sparse grid for a certain level $ n $, i.e., $ *V_n^{(1)}
            = *\bigoplus_{|\vec{l}|_1 \leq n+d-1} W_{\vec{l}}$.  

            If the used grid doesn't support the parameter t, t = 0 is used instead.  

            Parameters:  
            * `level` :  
                Grid level  
            * `T` :  
                modifier for subgrid selection, T = 0 implies standard sparse grid. For
                further information see Griebel and Knapek's paper optimized tensor-
                product approximation spaces  

        """
        return _pysgpp_swig.PrewaveletGridGenerator_regular(self, *args)

    def cliques(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `cliques(level, clique_size)`  

            Creates a sparse grid with fully connected cliques.  

            Parameters:  
            * `level` :  
                Grid level  
            * `clique_size` :  
                clique size  

        * `cliques(level, clique_size, T)`  

            Creates a sparse grid with fully connected cliques.  

            Parameters:  
            * `level` :  
                Grid level  
            * `clique_size` :  
                clique size  
            * `T` :  
                modifier for subgrid selection, T = 0 implies standard sparse grid. For
                further information see Griebel and Knapek's paper optimized tensor-
                product approximation spaces  

        """
        return _pysgpp_swig.PrewaveletGridGenerator_cliques(self, *args)

    def refine(self, func: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines the grid and updates the shadow storage.  

        """
        return _pysgpp_swig.PrewaveletGridGenerator_refine(self, func, addedPoints)

# Register PrewaveletGridGenerator in _pysgpp_swig:
_pysgpp_swig.PrewaveletGridGenerator_swigregister(PrewaveletGridGenerator)

class PeriodicGridGenerator(GridGenerator):
    r"""

    `PeriodicGridGenerator(storage)`  

    GridGenerator for periodic grids with boundaries.  

    Constructors
    ------------
    * `PeriodicGridGenerator(storage)`  

        Constructor.  

        Parameters:  
        * `storage` :  
            the grid's storage object  

    C++ includes: PeriodicGridGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `storage` :  
            the grid's storage object  

        """
        _pysgpp_swig.PeriodicGridGenerator_swiginit(self, _pysgpp_swig.new_PeriodicGridGenerator(storage))
    __swig_destroy__ = _pysgpp_swig.delete_PeriodicGridGenerator

    def regular(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `regular(level)`  

            Creates a regular sparse grid for a certain level $ n $, i.e., $ *V_n^{(1)}
            = *\bigoplus_{|\vec{l}|_1 \leq n+d-1} W_{\vec{l}}$.  

            Parameters:  
            * `level` :  
                Grid level  

        * `regular(level, T)`  

            Creates a regular sparse grid for a certain level $ n $, i.e., $ *V_n^{(1)}
            = *\bigoplus_{|\vec{l}|_1 \leq n+d-1} W_{\vec{l}}$.  

            If the used grid doesn't support the parameter t, t = 0 is used instead.  

            Parameters:  
            * `level` :  
                Grid level  
            * `T` :  
                modifier for subgrid selection, T = 0 implies standard sparse grid. For
                further information see Griebel and Knapek's paper optimized tensor-
                product approximation spaces  

        """
        return _pysgpp_swig.PeriodicGridGenerator_regular(self, *args)

    def refine(self, func: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to the settings of the RefinementFunctor func.  

        Parameters
        ----------
        * `func` :  
            reference to refinement functor  
        * `addedPoints` :  
            pointer to vector to add newly created grid points to  

        """
        return _pysgpp_swig.PeriodicGridGenerator_refine(self, func, addedPoints)

    def cliques(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `cliques(level, clique_size)`  

            Creates a sparse grid with fully connected cliques.  

            Parameters:  
            * `level` :  
                Grid level  
            * `clique_size` :  
                clique size  

        * `cliques(level, clique_size, T)`  

            Creates a sparse grid with fully connected cliques.  

            Parameters:  
            * `level` :  
                Grid level  
            * `clique_size` :  
                clique size  
            * `T` :  
                modifier for subgrid selection, T = 0 implies standard sparse grid. For
                further information see Griebel and Knapek's paper optimized tensor-
                product approximation spaces  

        """
        return _pysgpp_swig.PeriodicGridGenerator_cliques(self, *args)

# Register PeriodicGridGenerator in _pysgpp_swig:
_pysgpp_swig.PeriodicGridGenerator_swigregister(PeriodicGridGenerator)

class StretchedBoundaryGridGenerator(GridGenerator):
    r"""

    `StretchedBoundaryGridGenerator(storage)`  

    TODOTEXT.  

    Constructors
    ------------
    * `StretchedBoundaryGridGenerator(storage)`  

        Constructor.  

        Parameters:  
        * `storage` :  
            template type that holds the grid points  

    C++ includes: StretchedBoundaryGridGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `storage` :  
            template type that holds the grid points  

        """
        _pysgpp_swig.StretchedBoundaryGridGenerator_swiginit(self, _pysgpp_swig.new_StretchedBoundaryGridGenerator(storage))
    __swig_destroy__ = _pysgpp_swig.delete_StretchedBoundaryGridGenerator

    def refine(self, func: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to the settings of the RefinementFunctor func.  

        Parameters
        ----------
        * `func` :  
            reference to refinement functor  
        * `addedPoints` :  
            pointer to vector to add newly created grid points to  

        """
        return _pysgpp_swig.StretchedBoundaryGridGenerator_refine(self, func, addedPoints)

# Register StretchedBoundaryGridGenerator in _pysgpp_swig:
_pysgpp_swig.StretchedBoundaryGridGenerator_swigregister(StretchedBoundaryGridGenerator)

class BoundaryGridGenerator(GridGenerator):
    r"""

    `BoundaryGridGenerator(storage, boundaryLevel=1)`  

    This class provides the interface for the grid generation for grids with
    boundaries, pentagon cut through sub space scheme.  

    Constructors
    ------------
    * `BoundaryGridGenerator(storage, boundaryLevel=1)`  

        Constructor.  

        Parameters:  
        * `storage` :  
            template type that holds the grid points  
        * `boundaryLevel` :  
            1 + how much levels the boundary is coarser than the main axes, 0 means
            one level finer, 1 means same level, 2 means one level coarser, etc.  

    C++ includes: BoundaryGridGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage", boundaryLevel: "sgpp::base::level_t"=1):
        r"""


        Constructor.  

        Parameters
        ----------
        * `storage` :  
            template type that holds the grid points  
        * `boundaryLevel` :  
            1 + how much levels the boundary is coarser than the main axes, 0 means one
            level finer, 1 means same level, 2 means one level coarser, etc.  

        """
        _pysgpp_swig.BoundaryGridGenerator_swiginit(self, _pysgpp_swig.new_BoundaryGridGenerator(storage, boundaryLevel))
    __swig_destroy__ = _pysgpp_swig.delete_BoundaryGridGenerator

    def getBoundaryLevel(self) -> "sgpp::base::level_t":
        r"""


        """
        return _pysgpp_swig.BoundaryGridGenerator_getBoundaryLevel(self)

    def setBoundaryLevel(self, boundaryLevel: "sgpp::base::level_t") -> "void":
        r"""


        """
        return _pysgpp_swig.BoundaryGridGenerator_setBoundaryLevel(self, boundaryLevel)

    def refine(self, func: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to the settings of the RefinementFunctor func.  

        Parameters
        ----------
        * `func` :  
            reference to refinement functor  
        * `addedPoints` :  
            pointer to vector to add newly created grid points to  

        """
        return _pysgpp_swig.BoundaryGridGenerator_refine(self, func, addedPoints)

# Register BoundaryGridGenerator in _pysgpp_swig:
_pysgpp_swig.BoundaryGridGenerator_swigregister(BoundaryGridGenerator)

class SquareRootGridGenerator(GridGenerator):
    r"""

    `SquareRootGridGenerator(storage)`  

    This class provides the interface for the grid generation for grids with
    boundaries, pentagon cut through sub space scheme.  

    Constructors
    ------------
    * `SquareRootGridGenerator(storage)`  

        Constructor.  

        Parameters:  
        * `storage` :  
            template type that holds the grid points  

    C++ includes: SquareRootGridGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `storage` :  
            template type that holds the grid points  

        """
        _pysgpp_swig.SquareRootGridGenerator_swiginit(self, _pysgpp_swig.new_SquareRootGridGenerator(storage))
    __swig_destroy__ = _pysgpp_swig.delete_SquareRootGridGenerator

    def refine(self, func: "RefinementFunctor", addedPoints: "SizeVector"=None) -> "void":
        r"""


        Refines a grid according to the settings of the RefinementFunctor func.  

        Parameters
        ----------
        * `func` :  
            reference to refinement functor  
        * `addedPoints` :  
            pointer to vector to add newly created grid points to  

        """
        return _pysgpp_swig.SquareRootGridGenerator_refine(self, func, addedPoints)

# Register SquareRootGridGenerator in _pysgpp_swig:
_pysgpp_swig.SquareRootGridGenerator_swigregister(SquareRootGridGenerator)

class SurplusVolumeRefinementFunctor(RefinementFunctor):
    r"""

    `SurplusVolumeRefinementFunctor(alpha, refinements_num=1, threshold=0.0)`  

    A refinement functor, refining according to the maximal absolute values in a
    DataVector provided, weighted with the corresponding basis function's surplus,
    i.e., with $2^{-|\vec{l}|_1} = 2^{\sum_{k=1}^d l_d}$.  

    Constructors
    ------------
    * `SurplusVolumeRefinementFunctor(alpha, refinements_num=1, threshold=0.0)`  

        Constructor.  

        Parameters:  
        * `alpha` :  
            DataVector that is basis for refinement decisions. The i-th entry
            corresponds to the i-th grid point.  
        * `refinements_num` :  
            Number of grid points which should be refined (if possible - there could
            be less refinable grid points), default: 1  
        * `threshold` :  
            The absolute value of the entries have to be greater or equal than the
            threshold, default: 0.0  

    C++ includes: SurplusVolumeRefinementFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, alpha: "DataVector", refinements_num: "size_t"=1, threshold: "double"=0.0):
        r"""


        Constructor.  

        Parameters
        ----------
        * `alpha` :  
            DataVector that is basis for refinement decisions. The i-th entry
            corresponds to the i-th grid point.  
        * `refinements_num` :  
            Number of grid points which should be refined (if possible - there could be
            less refinable grid points), default: 1  
        * `threshold` :  
            The absolute value of the entries have to be greater or equal than the
            threshold, default: 0.0  

        """
        _pysgpp_swig.SurplusVolumeRefinementFunctor_swiginit(self, _pysgpp_swig.new_SurplusVolumeRefinementFunctor(alpha, refinements_num, threshold))
    __swig_destroy__ = _pysgpp_swig.delete_SurplusVolumeRefinementFunctor

# Register SurplusVolumeRefinementFunctor in _pysgpp_swig:
_pysgpp_swig.SurplusVolumeRefinementFunctor_swigregister(SurplusVolumeRefinementFunctor)

class GridDataBase(object):
    r"""

    `GridDataBase(filename)`  
    `GridDataBase(grid, values)`  
    `GridDataBase(dim)`  

    Class that allows to keep a storage of arbitrary grid points.  

    It has the functionality of a dictionary that is used for storing and retrieving
    grid points. Internally, a hash_map is used.  

    Note: GridDataBase currently supports only to store pairs of (grid point ->
    double).  

    Constructors
    ------------
    * `GridDataBase(filename)`  

        Constructor, reading from existing database.  

        Parameters:  
        * `filename` :  
            filename of database file  

    * `GridDataBase(grid, values)`  

        Constructor, copying from existing grid and values.  

        Parameters:  
        * `grid` :  
            the grid to copy from  
        * `values` :  
            the initial values  

    * `GridDataBase(dim)`  

        Standard Constructor, creating an empty database with dimensionality dim.  

        Parameters:  
        * `dim` :  
            the dimensionality of the grid points  

    C++ includes: GridDataBase.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ascii = _pysgpp_swig.GridDataBase_ascii
    binary = _pysgpp_swig.GridDataBase_binary

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `GridDataBase(filename)`  

            Constructor, reading from existing database.  

            Parameters:  
            * `filename` :  
                filename of database file  

        * `GridDataBase(grid, values)`  

            Constructor, copying from existing grid and values.  

            Parameters:  
            * `grid` :  
                the grid to copy from  
            * `values` :  
                the initial values  

        * `GridDataBase(dim)`  

            Standard Constructor, creating an empty database with dimensionality dim.  

            Parameters:  
            * `dim` :  
                the dimensionality of the grid points  

        """
        _pysgpp_swig.GridDataBase_swiginit(self, _pysgpp_swig.new_GridDataBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_GridDataBase

    def clear(self) -> "void":
        r"""


        Clears database, removing all entries.  

        Dimensionality is maintained.  

        """
        return _pysgpp_swig.GridDataBase_clear(self)

    def toString(self) -> "std::string":
        r"""


        Returns std::string representation of database.  

        Returns
        -------
        string representation  

        """
        return _pysgpp_swig.GridDataBase_toString(self)

    def hasKey(self, gi: "HashGridPoint") -> "bool":
        r"""


        Test, whether database already contains a grid point.  

        Parameters
        ----------
        * `gi` :  
            a grid point  

        Returns
        -------
        false, if grid point not in database  

        """
        return _pysgpp_swig.GridDataBase_hasKey(self, gi)

    def set(self, gi: "HashGridPoint", value: "double") -> "void":
        r"""


        Store (grid point - value) pair in database.  

        Parameters
        ----------
        * `gi` :  
            a grid point  
        * `value` :  
            the value to store  

        """
        return _pysgpp_swig.GridDataBase_set(self, gi, value)

    def setValuesFor(self, grid: "Grid", values: "DataVector") -> "void":
        r"""


        Set values for given grid from stored ones in database.  

        Parameters
        ----------
        * `grid` :  
            a grid  
        * `values` :  
            the corresponding coefficient vector  

        """
        return _pysgpp_swig.GridDataBase_setValuesFor(self, grid, values)

    def size(self) -> "size_t":
        r"""


        Returns the number of grid points that are currently stored in the database.  

        Returns
        -------
        the size of the database  

        """
        return _pysgpp_swig.GridDataBase_size(self)

    def dim(self) -> "size_t":
        r"""


        Returns the dimensionality of the grid points.  

        Returns
        -------
        the dimensionality of the grid points  

        """
        return _pysgpp_swig.GridDataBase_dim(self)

    def get(self, gi: "HashGridPoint") -> "double":
        r"""


        Get value for grid point from database.  

        Return nullptr if not existant.  

        Parameters
        ----------
        * `gi` :  
            a grid point  

        Returns
        -------
        value  

        """
        return _pysgpp_swig.GridDataBase_get(self, gi)

    def remove(self, gi: "HashGridPoint") -> "void":
        r"""


        Remove grid point from database.  

        Do nothing, if not in database.  

        Parameters
        ----------
        * `gi` :  
            grid point  

        """
        return _pysgpp_swig.GridDataBase_remove(self, gi)

    def save(self, *args) -> "void":
        r"""


        Save database to file.  

        Overwrites existing files without warning! Writes either ASCII (default) or
        binary format.  

        Parameters
        ----------
        * `filename` :  
            name of file  
        * `ftype` :  
            filetype (either ASCII, GridDataBase::asc (default), or binary,
            GridDataBase::bin)  

        """
        return _pysgpp_swig.GridDataBase_save(self, *args)

    def load(self, filename: "std::string const") -> "void":
        r"""


        Loads database in ASCII or binary format.  

        Adds (grid point - value) mappings to current database. Overwrites existing
        entries. To load a new database, use GridDataBase::GridDataBase(std::string
        filename).  

        Parameters
        ----------
        * `filename` :  
            name of file  

        """
        return _pysgpp_swig.GridDataBase_load(self, filename)

    def begin(self) -> "sgpp::base::GridDataBase::grid_map_iterator":
        r"""


        Return iterator to beginning.  

        Entries are of type pair<GridPoint, double>.  

        Returns
        -------
        iterator to beginning.  

        """
        return _pysgpp_swig.GridDataBase_begin(self)

    def end(self) -> "sgpp::base::GridDataBase::grid_map_iterator":
        r"""


        Return iterator to end.  

        Returns
        -------
        iterator to end.  

        """
        return _pysgpp_swig.GridDataBase_end(self)

# Register GridDataBase in _pysgpp_swig:
_pysgpp_swig.GridDataBase_swigregister(GridDataBase)

class GridTypeParser(object):
    r"""


    C++ includes: GridTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::base::GridType":
        r"""


        Convert strings to values sgpp::base::GridType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a sgpp::base::GridType.  

        Returns
        -------
        the corresponding sgpp::base::GridType.  

        """
        return _pysgpp_swig.GridTypeParser_parse(input)

    @staticmethod
    def toString(type: "sgpp::base::GridType") -> "std::string const &":
        r"""


        generate string representations for values of sgpp::base::GridType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::base::GridType.  

        """
        return _pysgpp_swig.GridTypeParser_toString(type)

    def __init__(self):
        _pysgpp_swig.GridTypeParser_swiginit(self, _pysgpp_swig.new_GridTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_GridTypeParser

# Register GridTypeParser in _pysgpp_swig:
_pysgpp_swig.GridTypeParser_swigregister(GridTypeParser)

def GridTypeParser_parse(input: "std::string const &") -> "sgpp::base::GridType":
    r"""


    Convert strings to values sgpp::base::GridType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a sgpp::base::GridType.  

    Returns
    -------
    the corresponding sgpp::base::GridType.  

    """
    return _pysgpp_swig.GridTypeParser_parse(input)

def GridTypeParser_toString(type: "sgpp::base::GridType") -> "std::string const &":
    r"""


    generate string representations for values of sgpp::base::GridType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::base::GridType.  

    """
    return _pysgpp_swig.GridTypeParser_toString(type)

class GeneralGridTypeParser(object):
    r"""


    Parser class to parse a general grid type into a GeneralGridType enum type and
    vice versa.  

    C++ includes: GeneralGridTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::base::GeneralGridType":
        r"""


        Parses an input string and returns the corresponding sgpp::base::GeneralGridType
        type.  

        Throws an exception if the string has no representation  

        Parameters
        ----------
        * `input` :  
            the grid type to parse  

        Returns
        -------
        the parsed grid type  

        """
        return _pysgpp_swig.GeneralGridTypeParser_parse(input)

    @staticmethod
    def toString(type: "sgpp::base::GeneralGridType") -> "std::string const &":
        r"""


        Returns the string representation of a sgpp::base::GeneralGridType type.  

        Parameters
        ----------
        * `type` :  
            the grid type to retrieve the string representation from  

        Returns
        -------
        the string representation of the the grid type  

        """
        return _pysgpp_swig.GeneralGridTypeParser_toString(type)

    def __init__(self):
        _pysgpp_swig.GeneralGridTypeParser_swiginit(self, _pysgpp_swig.new_GeneralGridTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_GeneralGridTypeParser

# Register GeneralGridTypeParser in _pysgpp_swig:
_pysgpp_swig.GeneralGridTypeParser_swigregister(GeneralGridTypeParser)

def GeneralGridTypeParser_parse(input: "std::string const &") -> "sgpp::base::GeneralGridType":
    r"""


    Parses an input string and returns the corresponding sgpp::base::GeneralGridType
    type.  

    Throws an exception if the string has no representation  

    Parameters
    ----------
    * `input` :  
        the grid type to parse  

    Returns
    -------
    the parsed grid type  

    """
    return _pysgpp_swig.GeneralGridTypeParser_parse(input)

def GeneralGridTypeParser_toString(type: "sgpp::base::GeneralGridType") -> "std::string const &":
    r"""


    Returns the string representation of a sgpp::base::GeneralGridType type.  

    Parameters
    ----------
    * `type` :  
        the grid type to retrieve the string representation from  

    Returns
    -------
    the string representation of the the grid type  

    """
    return _pysgpp_swig.GeneralGridTypeParser_toString(type)

RefinementFunctorType_Surplus = _pysgpp_swig.RefinementFunctorType_Surplus
RefinementFunctorType_SurplusVolume = _pysgpp_swig.RefinementFunctorType_SurplusVolume
RefinementFunctorType_DataBased = _pysgpp_swig.RefinementFunctorType_DataBased
RefinementFunctorType_ZeroCrossing = _pysgpp_swig.RefinementFunctorType_ZeroCrossing
RefinementFunctorType_GridPointBased = _pysgpp_swig.RefinementFunctorType_GridPointBased
RefinementFunctorType_MultipleClass = _pysgpp_swig.RefinementFunctorType_MultipleClass
RefinementFunctorType_Classification = _pysgpp_swig.RefinementFunctorType_Classification
class RefinementFunctorTypeParser(object):
    r"""


    C++ includes: RefinementFunctorTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::base::RefinementFunctorType":
        r"""


        Convert strings to values sgpp::base::RefinementFunctorType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a
            sgpp::base::RefinementFunctorType.  

        Returns
        -------
        the corresponding sgpp::base::RefinementFunctorType.  

        """
        return _pysgpp_swig.RefinementFunctorTypeParser_parse(input)

    @staticmethod
    def toString(type: "sgpp::base::RefinementFunctorType") -> "std::string const &":
        r"""


        generate string representations for values of sgpp::base::RefinementFunctorType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::base::RefinementFunctorType.  

        """
        return _pysgpp_swig.RefinementFunctorTypeParser_toString(type)

    def __init__(self):
        _pysgpp_swig.RefinementFunctorTypeParser_swiginit(self, _pysgpp_swig.new_RefinementFunctorTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_RefinementFunctorTypeParser

# Register RefinementFunctorTypeParser in _pysgpp_swig:
_pysgpp_swig.RefinementFunctorTypeParser_swigregister(RefinementFunctorTypeParser)

def RefinementFunctorTypeParser_parse(input: "std::string const &") -> "sgpp::base::RefinementFunctorType":
    r"""


    Convert strings to values sgpp::base::RefinementFunctorType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a
        sgpp::base::RefinementFunctorType.  

    Returns
    -------
    the corresponding sgpp::base::RefinementFunctorType.  

    """
    return _pysgpp_swig.RefinementFunctorTypeParser_parse(input)

def RefinementFunctorTypeParser_toString(type: "sgpp::base::RefinementFunctorType") -> "std::string const &":
    r"""


    generate string representations for values of sgpp::base::RefinementFunctorType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::base::RefinementFunctorType.  

    """
    return _pysgpp_swig.RefinementFunctorTypeParser_toString(type)

class ScreenOutput(object):
    r"""

    `ScreenOutput()`  

    This is used to implement the output on the command line.  

    Constructors
    ------------
    * `ScreenOutput()`  

        Standard constructor.  

    C++ includes: ScreenOutput.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Standard constructor.  

        """
        _pysgpp_swig.ScreenOutput_swiginit(self, _pysgpp_swig.new_ScreenOutput())
    __swig_destroy__ = _pysgpp_swig.delete_ScreenOutput

    def update(self, progress: "size_t", status: "std::string") -> "void":
        r"""


        update function running windows  

        Parameters
        ----------
        * `progress` :  
            percentage value  
        * `status` :  
            status in words  

        """
        return _pysgpp_swig.ScreenOutput_update(self, progress, status)

    def writeTitle(self, appTitle: "std::string", appAuthor: "std::string") -> "void":
        r"""


        writes the header of the screen output  

        Parameters
        ----------
        * `appTitle` :  
            the application's title  
        * `appAuthor` :  
            the application's author  

        """
        return _pysgpp_swig.ScreenOutput_writeTitle(self, appTitle, appAuthor)

    def writeHelp(self, helpText: "std::string") -> "void":
        r"""


        writes some help information to the console  

        Parameters
        ----------
        * `helpText` :  
            the helptext to be displayed  

        """
        return _pysgpp_swig.ScreenOutput_writeHelp(self, helpText)

    def writeStartSolve(self, text: "std::string") -> "void":
        r"""


        start the screen output  

        Parameters
        ----------
        * `text` :  
            the start text to be displayed  

        """
        return _pysgpp_swig.ScreenOutput_writeStartSolve(self, text)

    def writeEmptyLines(self, numLines: "size_t") -> "void":
        r"""


        writes empty lines  

        Parameters
        ----------
        * `numLines` :  
            number of empty lines to display  

        """
        return _pysgpp_swig.ScreenOutput_writeEmptyLines(self, numLines)

# Register ScreenOutput in _pysgpp_swig:
_pysgpp_swig.ScreenOutput_swigregister(ScreenOutput)

class OperationEvalPeriodic(OperationEval):
    r"""

    `OperationEvalPeriodic(storage)`  

    This class implements OperationEval for a grids with periodic linear basis
    ansatzfunctions with.  

    Constructors
    ------------
    * `OperationEvalPeriodic(storage)`  

        Constructor.  

        Parameters:  
        * `storage` :  
            the grid's GridStorage object  

    C++ includes: OperationEvalPeriodic.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `storage` :  
            the grid's GridStorage object  

        """
        _pysgpp_swig.OperationEvalPeriodic_swiginit(self, _pysgpp_swig.new_OperationEvalPeriodic(storage))
    __swig_destroy__ = _pysgpp_swig.delete_OperationEvalPeriodic

# Register OperationEvalPeriodic in _pysgpp_swig:
_pysgpp_swig.OperationEvalPeriodic_swigregister(OperationEvalPeriodic)

class OperationMultipleEvalPeriodic(OperationMultipleEval):
    r"""

    `OperationMultipleEvalPeriodic(grid, dataset)`  

    This class implements OperationMultipleEval for a grids with periodic linear
    basis ansatzfunctions.  

    Constructors
    ------------
    * `OperationMultipleEvalPeriodic(grid, dataset)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            grid  
        * `dataset` :  
            the dataset that should be evaluated  

    C++ includes: OperationMultipleEvalPeriodic.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", dataset: "DataMatrix"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `grid` :  
            grid  
        * `dataset` :  
            the dataset that should be evaluated  

        """
        _pysgpp_swig.OperationMultipleEvalPeriodic_swiginit(self, _pysgpp_swig.new_OperationMultipleEvalPeriodic(grid, dataset))
    __swig_destroy__ = _pysgpp_swig.delete_OperationMultipleEvalPeriodic

# Register OperationMultipleEvalPeriodic in _pysgpp_swig:
_pysgpp_swig.OperationMultipleEvalPeriodic_swigregister(OperationMultipleEvalPeriodic)

class QuadRule1D(object):
    r"""

    `QuadRule1D()`  

    Constructors
    ------------
    * `QuadRule1D()`  

    C++ includes: QuadRule1D.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        """
        _pysgpp_swig.QuadRule1D_swiginit(self, _pysgpp_swig.new_QuadRule1D())
    __swig_destroy__ = _pysgpp_swig.delete_QuadRule1D

    def getMaxSupportedLevel(self) -> "size_t":
        r"""


        """
        return _pysgpp_swig.QuadRule1D_getMaxSupportedLevel(self)

    def getLevelPointsAndWeights(self, level: "size_t", coordinates: "DataVector", weights: "DataVector") -> "void":
        r"""


        """
        return _pysgpp_swig.QuadRule1D_getLevelPointsAndWeights(self, level, coordinates, weights)
    coordinatesWeights = property(_pysgpp_swig.QuadRule1D_coordinatesWeights_get, _pysgpp_swig.QuadRule1D_coordinatesWeights_set)

# Register QuadRule1D in _pysgpp_swig:
_pysgpp_swig.QuadRule1D_swigregister(QuadRule1D)

class GaussLegendreQuadRule1D(QuadRule1D):
    r"""

    `GaussLegendreQuadRule1D()`  
    `GaussLegendreQuadRule1D(that)`  

    Constructors
    ------------
    * `GaussLegendreQuadRule1D()`  

        load gauss quadrature points for uniform weight function.  

        The points and the weights are generated with
        numpy.polynomial.legendre.leggauss. the weights are additionally normalized
        to 1.  

    * `GaussLegendreQuadRule1D(that)`  

    C++ includes: GaussLegendreQuadRule1D.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Overloaded function
        -------------------
        * `GaussLegendreQuadRule1D()`  

            load gauss quadrature points for uniform weight function.  

            The points and the weights are generated with
            numpy.polynomial.legendre.leggauss. the weights are additionally normalized
            to 1.  

        * `GaussLegendreQuadRule1D(that)`  

        """
        _pysgpp_swig.GaussLegendreQuadRule1D_swiginit(self, _pysgpp_swig.new_GaussLegendreQuadRule1D())
    __swig_destroy__ = _pysgpp_swig.delete_GaussLegendreQuadRule1D

    def getLevelPointsAndWeightsNormalized(self, level: "size_t", coordinates: "DataVector", weights: "DataVector") -> "void":
        r"""


        the coordinates are normalized to [0, 1].  

        Parameters
        ----------
        * `level` :  
            level of quadrature, is equal to the number of quadrature points  
        * `coordinates` :  
            returns the x-coordinates in [0, 1]  
        * `weights` :  
            returns the corresponding weights (scaled by 0.5)  

        """
        return _pysgpp_swig.GaussLegendreQuadRule1D_getLevelPointsAndWeightsNormalized(self, level, coordinates, weights)

    @staticmethod
    def getInstance() -> "sgpp::base::GaussLegendreQuadRule1D &":
        r"""


        """
        return _pysgpp_swig.GaussLegendreQuadRule1D_getInstance()

# Register GaussLegendreQuadRule1D in _pysgpp_swig:
_pysgpp_swig.GaussLegendreQuadRule1D_swigregister(GaussLegendreQuadRule1D)

def GaussLegendreQuadRule1D_getInstance() -> "sgpp::base::GaussLegendreQuadRule1D &":
    r"""


    """
    return _pysgpp_swig.GaussLegendreQuadRule1D_getInstance()

class GaussHermiteQuadRule1D(QuadRule1D):
    r"""

    `GaussHermiteQuadRule1D()`  
    `GaussHermiteQuadRule1D(that)`  

    load gauss quadrature points for standard normal weight function.  

    The points and the weights are generated with
    numpy.polynomial.hermite.hermgauss, the coordinates are scaled by sqrt(2), the
    weights are normalized to 1.  

    Constructors
    ------------
    * `GaussHermiteQuadRule1D()`  

    * `GaussHermiteQuadRule1D(that)`  

    C++ includes: GaussHermiteQuadRule1D.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Overloaded function
        -------------------
        * `GaussHermiteQuadRule1D()`  

        * `GaussHermiteQuadRule1D(that)`  

        """
        _pysgpp_swig.GaussHermiteQuadRule1D_swiginit(self, _pysgpp_swig.new_GaussHermiteQuadRule1D())
    __swig_destroy__ = _pysgpp_swig.delete_GaussHermiteQuadRule1D

    def getLevelPointsAndWeightsNormalized(self, level: "size_t", coordinates: "DataVector", weights: "DataVector", mean: "double"=0.0, stdd: "double"=1.0) -> "void":
        r"""


        the coordinates are scaled by sqrt(2) and then normalized with respect to a
        given mean and standard deviation.  

        The weights are normalized to 1.  

        Parameters
        ----------
        * `level` :  
            level of quadrature, is equal to the number of quadrature points  
        * `coordinates` :  
            returns the x-coordinates in [-infty, infty]  
        * `weights` :  
            returns the corresponding weights (scaled by sqrt(2))  
        * `mean` :  
            mean of the normal distribution the coordinates should be transformed to  
        * `stdd` :  
            standard deviation of the normal distribution the coordinates should be
            transformed to  

        """
        return _pysgpp_swig.GaussHermiteQuadRule1D_getLevelPointsAndWeightsNormalized(self, level, coordinates, weights, mean, stdd)

    @staticmethod
    def getInstance() -> "sgpp::base::GaussHermiteQuadRule1D &":
        r"""


        """
        return _pysgpp_swig.GaussHermiteQuadRule1D_getInstance()

# Register GaussHermiteQuadRule1D in _pysgpp_swig:
_pysgpp_swig.GaussHermiteQuadRule1D_swigregister(GaussHermiteQuadRule1D)

def GaussHermiteQuadRule1D_getInstance() -> "sgpp::base::GaussHermiteQuadRule1D &":
    r"""


    """
    return _pysgpp_swig.GaussHermiteQuadRule1D_getInstance()

class OperationFirstMoment(object):
    r"""

    `OperationFirstMoment()`  

    This class provides the first moment of a sparse grid function.  

    Constructors
    ------------
    * `OperationFirstMoment()`  

        Constructor.  

    C++ includes: OperationFirstMoment.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationFirstMoment

    def doQuadrature(self, alpha: "DataVector", bounds: "DataMatrix"=None) -> "double":
        r"""


        Integrate the sparse grid function.  

        Parameters
        ----------
        * `alpha` :  
            the function's values in the nodal basis  
        * `bounds` :  
            describes the boundaries of the hypercube of the original function  

        """
        return _pysgpp_swig.OperationFirstMoment_doQuadrature(self, alpha, bounds)

# Register OperationFirstMoment in _pysgpp_swig:
_pysgpp_swig.OperationFirstMoment_swigregister(OperationFirstMoment)

class OperationSecondMoment(object):
    r"""

    `OperationSecondMoment()`  

    This class provides the second moment of a sparse grid function.  

    Constructors
    ------------
    * `OperationSecondMoment()`  

        Constructor.  

    C++ includes: OperationSecondMoment.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationSecondMoment

    def doQuadrature(self, alpha: "DataVector", bounds: "DataMatrix"=None) -> "double":
        r"""


        Integrate the sparse grid function.  

        Parameters
        ----------
        * `alpha` :  
            the function's values in the nodal basis  
        * `bounds` :  
            describes the boundaries of the hypercube of the original function  

        """
        return _pysgpp_swig.OperationSecondMoment_doQuadrature(self, alpha, bounds)

# Register OperationSecondMoment in _pysgpp_swig:
_pysgpp_swig.OperationSecondMoment_swigregister(OperationSecondMoment)

class RandomNumberGenerator(object):
    r"""


    Singleton class for generating pseudo-random numbers (wrapper around
    std::mt19937 from <random>).  

    C++ includes: RandomNumberGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def getInstance() -> "sgpp::base::RandomNumberGenerator &":
        r"""


        Returns
        -------
        singleton instance  

        """
        return _pysgpp_swig.RandomNumberGenerator_getInstance()

    def getUniformRN(self, a: "double"=0.0, b: "double"=1.0) -> "double":
        r"""


        Generate a uniform pseudo-random number.  

        Parameters
        ----------
        * `a` :  
            lower bound  
        * `b` :  
            upper bound  

        Returns
        -------
        uniform pseudo-random number in $[a, b]$  

        """
        return _pysgpp_swig.RandomNumberGenerator_getUniformRN(self, a, b)

    def getUniformRV(self, vector: "DataVector", a: "double"=0.0, b: "double"=1.0) -> "void":
        r"""


        Fills vector with uniform pseudo-random numbers.  

        Parameters
        ----------
        * `vector` :  
            vector to be filled, has to have desired size beforehand  
        * `a` :  
            lower bound  
        * `b` :  
            upper bound  

        """
        return _pysgpp_swig.RandomNumberGenerator_getUniformRV(self, vector, a, b)

    def getUniformIndexRN(self, size: "size_t") -> "size_t":
        r"""


        Generate a uniform pseudo-random array index.  

        Parameters
        ----------
        * `size` :  
            size of the array  

        Returns
        -------
        discrete uniform pseudo-random number in $\{0, \dotsc, \text{\texttt{size}}
        - 1\}$  

        """
        return _pysgpp_swig.RandomNumberGenerator_getUniformIndexRN(self, size)

    def getGaussianRN(self, mean: "double"=0.0, stdDev: "double"=1.0) -> "double":
        r"""


        Generate a Gaussian pseudo-random number.  

        Parameters
        ----------
        * `mean` :  
            mean of the Gaussian distribution  
        * `stdDev` :  
            standard deviation of the Gaussian distribution  

        Returns
        -------
        Gaussian pseudo-random number  

        """
        return _pysgpp_swig.RandomNumberGenerator_getGaussianRN(self, mean, stdDev)

    def getGaussianRV(self, vector: "DataVector", mean: "double"=0.0, stdDev: "double"=1.0) -> "void":
        r"""


        Fills vector with Gaussian pseudo-random numbers.  

        Parameters
        ----------
        * `vector` :  
            vector to be filled, has to have desired size beforehand  
        * `mean` :  
            mean of the Gaussian distribution  
        * `stdDev` :  
            standard deviation of the Gaussian distribution  

        """
        return _pysgpp_swig.RandomNumberGenerator_getGaussianRV(self, vector, mean, stdDev)

    def getSeed(self) -> "sgpp::base::RandomNumberGenerator::SeedType":
        r"""


        Returns
        -------
        seed  

        """
        return _pysgpp_swig.RandomNumberGenerator_getSeed(self)

    def setSeed(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `setSeed()`  

            Reseeds with time-dependent seed.  

        * `setSeed(seed)`  

            Reseeds.  

            Parameters:  
            * `seed` :  
                seed to be used  

        """
        return _pysgpp_swig.RandomNumberGenerator_setSeed(self, *args)
    __swig_destroy__ = _pysgpp_swig.delete_RandomNumberGenerator

# Register RandomNumberGenerator in _pysgpp_swig:
_pysgpp_swig.RandomNumberGenerator_swigregister(RandomNumberGenerator)

def RandomNumberGenerator_getInstance() -> "sgpp::base::RandomNumberGenerator &":
    r"""


    Returns
    -------
    singleton instance  

    """
    return _pysgpp_swig.RandomNumberGenerator_getInstance()

class SLE(object):
    r"""

    `SLE()`  

    Abstract class representing a system of linear equations.  

    All row and column indices are zero based.  

    Constructors
    ------------
    * `SLE()`  

        Constructor.  

    C++ includes: SLE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SLE

    def isMatrixEntryNonZero(self, i: "size_t", j: "size_t") -> "bool":
        r"""


        Pure virtual method for checking if a matrix entry vanishes or not.  

        Parameters
        ----------
        * `i` :  
            row index  
        * `j` :  
            column index  

        Returns
        -------
        whether the (i,j)-th entry of the matrix is non-zero  

        """
        return _pysgpp_swig.SLE_isMatrixEntryNonZero(self, i, j)

    def getMatrixEntry(self, i: "size_t", j: "size_t") -> "double":
        r"""


        Pure virtual method for retrieving a matrix entry.  

        Parameters
        ----------
        * `i` :  
            row index  
        * `j` :  
            column index  

        Returns
        -------
        (i,j)-th entry of the matrix  

        """
        return _pysgpp_swig.SLE_getMatrixEntry(self, i, j)

    def matrixVectorMultiplication(self, x: "DataVector", y: "DataVector") -> "void":
        r"""


        Multiply the matrix with a vector.  

        Standard implementation with $\mathcal{O}(n^2)$ scalar multiplications.  

        Parameters
        ----------
        * `x` :  
            vector to be multiplied  
        * `y` :  
            $y = Ax$  

        """
        return _pysgpp_swig.SLE_matrixVectorMultiplication(self, x, y)

    def countNNZ(self) -> "size_t":
        r"""


        Count all non-zero entries.  

        Standard implementation with $\mathcal{O}(n^2)$ checks.  

        Returns
        -------
        number of non-zero entries  

        """
        return _pysgpp_swig.SLE_countNNZ(self)

    def getDimension(self) -> "size_t":
        r"""


        Pure virtual method returning the dimension (number of rows/columns) of the
        system.  

        Returns
        -------
        system dimension  

        """
        return _pysgpp_swig.SLE_getDimension(self)

    def isCloneable(self) -> "bool":
        r"""


        Returns
        -------
        whether this system derives from CloneableSLE or not (standard: false)  

        """
        return _pysgpp_swig.SLE_isCloneable(self)

# Register SLE in _pysgpp_swig:
_pysgpp_swig.SLE_swigregister(SLE)
cvar = _pysgpp_swig.cvar
ARMADILLO_ENABLED = cvar.ARMADILLO_ENABLED
EIGEN_ENABLED = cvar.EIGEN_ENABLED
GMMPP_ENABLED = cvar.GMMPP_ENABLED
UMFPACK_ENABLED = cvar.UMFPACK_ENABLED

class CloneableSLE(SLE):
    r"""

    `CloneableSLE()`  

    Abstract class for "cloneable" linear systems.  

    This class is needed in the case that matrix entry lookups are not possible
    concurrently (e.g. for hierarchization systems with Clenshaw-Curtis grids).  

    Constructors
    ------------
    * `CloneableSLE()`  

        Constructor.  

    C++ includes: CloneableSLE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_CloneableSLE

    def clone(self, clone: "std::unique_ptr< sgpp::base::CloneableSLE > &") -> "void":
        r"""


        Pure virtual method for cloning the linear system.  

        It should generate a pointer to the cloned object and it's used for parallel
        computations (e.g. the getMatrixEntry() method might not be thread-safe).  

        Parameters
        ----------
        * `clone` :  
            pointer to cloned object  

        """
        return _pysgpp_swig.CloneableSLE_clone(self, clone)

# Register CloneableSLE in _pysgpp_swig:
_pysgpp_swig.CloneableSLE_swigregister(CloneableSLE)

class FullSLE(CloneableSLE):
    r"""

    `FullSLE(A)`  

    Full linear system, essentially a wrapper around DataMatrix.  

    Constructors
    ------------
    * `FullSLE(A)`  

        Constructor.  

        Do not destruct the matrix A before this object!  

        Parameters:  
        * `A` :  
            coefficient matrix  

    C++ includes: FullSLE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, A: "DataMatrix"):
        r"""


        Constructor.  

        Do not destruct the matrix A before this object!  

        Parameters
        ----------
        * `A` :  
            coefficient matrix  

        """
        _pysgpp_swig.FullSLE_swiginit(self, _pysgpp_swig.new_FullSLE(A))
    __swig_destroy__ = _pysgpp_swig.delete_FullSLE

    def getA(self) -> "sgpp::base::DataMatrix &":
        r"""


        Returns
        -------
        coefficient matrix  

        """
        return _pysgpp_swig.FullSLE_getA(self)

# Register FullSLE in _pysgpp_swig:
_pysgpp_swig.FullSLE_swigregister(FullSLE)

class HierarchisationSLE(CloneableSLE):
    r"""

    `HierarchisationSLE(grid)`  
    `HierarchisationSLE(grid, gridStorage)`  

    Linear system of the hierarchization in a sparse grid.  

    Constructors
    ------------
    * `HierarchisationSLE(grid)`  

        Constructor.  

        Do not destruct the grid before this object!  

        Parameters:  
        * `grid` :  
            sparse grid  

    * `HierarchisationSLE(grid, gridStorage)`  

        Constructor.  

        Do not destruct the grid before this object!  

        Parameters:  
        * `grid` :  
            sparse grid  
        * `gridStorage` :  
            custom grid storage (use basis function according to grid, but use
            another set of grid points according to gridStorage)  

    C++ includes: HierarchisationSLE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `HierarchisationSLE(grid)`  

            Constructor.  

            Do not destruct the grid before this object!  

            Parameters:  
            * `grid` :  
                sparse grid  

        * `HierarchisationSLE(grid, gridStorage)`  

            Constructor.  

            Do not destruct the grid before this object!  

            Parameters:  
            * `grid` :  
                sparse grid  
            * `gridStorage` :  
                custom grid storage (use basis function according to grid, but use
                another set of grid points according to gridStorage)  

        """
        _pysgpp_swig.HierarchisationSLE_swiginit(self, _pysgpp_swig.new_HierarchisationSLE(*args))

    def getGrid(self) -> "sgpp::base::Grid &":
        r"""


        Returns
        -------
        sparse grid  

        """
        return _pysgpp_swig.HierarchisationSLE_getGrid(self)

    def getGridStorage(self) -> "sgpp::base::GridStorage &":
        r"""


        Returns
        -------
        grid storage  

        """
        return _pysgpp_swig.HierarchisationSLE_getGridStorage(self)
    __swig_destroy__ = _pysgpp_swig.delete_HierarchisationSLE

# Register HierarchisationSLE in _pysgpp_swig:
_pysgpp_swig.HierarchisationSLE_swigregister(HierarchisationSLE)

class SLESolver(object):
    r"""

    `SLESolver()`  

    Abstract class for solving systems of linear equations.  

    Constructors
    ------------
    * `SLESolver()`  

        Constructor.  

    C++ includes: SLESolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SLESolver

    def solve(self, *args) -> "bool":
        r"""


        Overloaded function
        -------------------
        * `solve(system, B, X) -> bool`  

            Virtual method for solving multiple linear systems with different right-hand
            sides.  

            Defaults to calling the solve() method for a single right-hand side multiple
            times.  

            Parameters:  
            * `system` :  
                system to be solved  
            * `B` :  
                matrix of right-hand sides  
            * `X` :  
                matrix of solutions to the systems  

            Returns:
            whether all went well (false if errors occurred)  

        * `solve(system, b, x) -> bool`  

            Pure virtual method for a solving linear system.  

            Parameters:  
            * `system` :  
                system to be solved  
            * `b` :  
                right-hand side  
            * `x` :  
                solution to the system  

            Returns:
            whether all went well (false if errors occurred)  

        """
        return _pysgpp_swig.SLESolver_solve(self, *args)

# Register SLESolver in _pysgpp_swig:
_pysgpp_swig.SLESolver_swigregister(SLESolver)

class Armadillo(SLESolver):
    r"""


    Linear system solver using Armadillo (direct full solver).  

    C++ includes: Armadillo.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_Armadillo

    def solve(self, *args) -> "bool":
        r"""


        Overloaded function
        -------------------
        * `solve(system, B, X) -> bool`  

            Parameters:  
            * `system` :  
                system to be solved  
            * `B` :  
                matrix of right-hand sides  
            * `X` :  
                matrix of solutions to the systems  

            Returns:
            whether all went well (false if errors occurred)  

        * `solve(system, b, x) -> bool`  

            Parameters:  
            * `system` :  
                system to be solved  
            * `b` :  
                right-hand side  
            * `x` :  
                solution to the system  

            Returns:
            whether all went well (false if errors occurred)  

        """
        return _pysgpp_swig.Armadillo_solve(self, *args)

    def __init__(self):
        _pysgpp_swig.Armadillo_swiginit(self, _pysgpp_swig.new_Armadillo())

# Register Armadillo in _pysgpp_swig:
_pysgpp_swig.Armadillo_swigregister(Armadillo)

class AutoSLESolver(SLESolver):
    r"""


    Automatic choice of external linear solver.  

    C++ includes: Auto.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MAX_DIM_FOR_FULL = _pysgpp_swig.AutoSLESolver_MAX_DIM_FOR_FULL
    MAX_DIM_FOR_GAUSSIAN = _pysgpp_swig.AutoSLESolver_MAX_DIM_FOR_GAUSSIAN
    MAX_NNZ_RATIO_FOR_SPARSE = _pysgpp_swig.AutoSLESolver_MAX_NNZ_RATIO_FOR_SPARSE
    ESTIMATE_NNZ_ROWS_SAMPLE_SIZE = _pysgpp_swig.AutoSLESolver_ESTIMATE_NNZ_ROWS_SAMPLE_SIZE
    __swig_destroy__ = _pysgpp_swig.delete_AutoSLESolver

    def solve(self, *args) -> "bool":
        r"""


        Overloaded function
        -------------------
        * `solve(system, B, X) -> bool`  

            Parameters:  
            * `system` :  
                system to be solved  
            * `B` :  
                matrix of right-hand sides  
            * `X` :  
                matrix of solutions to the systems  

            Returns:
            whether all went well (false if errors occurred)  

        * `solve(system, b, x) -> bool`  

            Parameters:  
            * `system` :  
                system to be solved  
            * `b` :  
                right-hand side  
            * `x` :  
                solution to the system  

            Returns:
            whether all went well (false if errors occurred)  

        """
        return _pysgpp_swig.AutoSLESolver_solve(self, *args)

    def __init__(self):
        _pysgpp_swig.AutoSLESolver_swiginit(self, _pysgpp_swig.new_AutoSLESolver())

# Register AutoSLESolver in _pysgpp_swig:
_pysgpp_swig.AutoSLESolver_swigregister(AutoSLESolver)

class BiCGStab(SLESolver):
    r"""

    `BiCGStab()`  
    `BiCGStab(maxItCount, tolerance, startingPoint)`  

    Linear system solver implementing the iterative BiCGStab method.  

    Constructors
    ------------
    * `BiCGStab()`  

        Constructor.  

    * `BiCGStab(maxItCount, tolerance, startingPoint)`  

        Parameters:  
        * `maxItCount` :  
            maximal number of iterations  
        * `tolerance` :  
            tolerance  
        * `startingPoint` :  
            starting vector  

    C++ includes: BiCGStab.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_MAX_IT_COUNT = _pysgpp_swig.BiCGStab_DEFAULT_MAX_IT_COUNT
    DEFAULT_TOLERANCE = _pysgpp_swig.BiCGStab_DEFAULT_TOLERANCE

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `BiCGStab()`  

            Constructor.  

        * `BiCGStab(maxItCount, tolerance, startingPoint)`  

            Parameters:  
            * `maxItCount` :  
                maximal number of iterations  
            * `tolerance` :  
                tolerance  
            * `startingPoint` :  
                starting vector  

        """
        _pysgpp_swig.BiCGStab_swiginit(self, _pysgpp_swig.new_BiCGStab(*args))
    __swig_destroy__ = _pysgpp_swig.delete_BiCGStab

    def getMaxItCount(self) -> "size_t":
        r"""


        Returns
        -------
        maximal number of iterations  

        """
        return _pysgpp_swig.BiCGStab_getMaxItCount(self)

    def setMaxItCount(self, maxItCount: "size_t") -> "void":
        r"""


        Parameters
        ----------
        * `maxItCount` :  
            maximal number of iterations  

        """
        return _pysgpp_swig.BiCGStab_setMaxItCount(self, maxItCount)

    def getTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance  

        """
        return _pysgpp_swig.BiCGStab_getTolerance(self)

    def setTolerance(self, tolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `tolerance` :  
            tolerance  

        """
        return _pysgpp_swig.BiCGStab_setTolerance(self, tolerance)

    def getStartingPoint(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        starting vector  

        """
        return _pysgpp_swig.BiCGStab_getStartingPoint(self)

    def setStartingPoint(self, startingPoint: "DataVector") -> "void":
        r"""


        Parameters
        ----------
        * `startingPoint` :  
            starting vector  

        """
        return _pysgpp_swig.BiCGStab_setStartingPoint(self, startingPoint)

# Register BiCGStab in _pysgpp_swig:
_pysgpp_swig.BiCGStab_swigregister(BiCGStab)

class Eigen(SLESolver):
    r"""


    Linear system solver using Eigen (direct full solver).  

    C++ includes: Eigen.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_Eigen

    def solve(self, *args) -> "bool":
        r"""


        Overloaded function
        -------------------
        * `solve(system, B, X) -> bool`  

            Parameters:  
            * `system` :  
                system to be solved  
            * `B` :  
                matrix of right-hand sides  
            * `X` :  
                matrix of solutions to the systems  

            Returns:
            whether all went well (false if errors occurred)  

        * `solve(system, b, x) -> bool`  

            Parameters:  
            * `system` :  
                system to be solved  
            * `b` :  
                right-hand side  
            * `x` :  
                solution to the system  

            Returns:
            whether all went well (false if errors occurred)  

        """
        return _pysgpp_swig.Eigen_solve(self, *args)

    def __init__(self):
        _pysgpp_swig.Eigen_swiginit(self, _pysgpp_swig.new_Eigen())

# Register Eigen in _pysgpp_swig:
_pysgpp_swig.Eigen_swigregister(Eigen)

class GaussianElimination(SLESolver):
    r"""


    Linear system solver implementing the direct Gaussian elimination.  

    C++ includes: GaussianElimination.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_GaussianElimination

    def __init__(self):
        _pysgpp_swig.GaussianElimination_swiginit(self, _pysgpp_swig.new_GaussianElimination())

# Register GaussianElimination in _pysgpp_swig:
_pysgpp_swig.GaussianElimination_swigregister(GaussianElimination)

class Gmmpp(SLESolver):
    r"""


    Linear system solver using Gmm++ (iterative sparse solver).  

    C++ includes: Gmmpp.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_Gmmpp

    def __init__(self):
        _pysgpp_swig.Gmmpp_swiginit(self, _pysgpp_swig.new_Gmmpp())

# Register Gmmpp in _pysgpp_swig:
_pysgpp_swig.Gmmpp_swigregister(Gmmpp)

class UMFPACK(SLESolver):
    r"""


    Linear system solver using UMFPACK (direct sparse solver).  

    C++ includes: UMFPACK.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_UMFPACK

    def solve(self, *args) -> "bool":
        r"""


        Overloaded function
        -------------------
        * `solve(system, B, X) -> bool`  

            Parameters:  
            * `system` :  
                system to be solved  
            * `B` :  
                matrix of right-hand sides  
            * `X` :  
                matrix of solutions to the systems  

            Returns:
            whether all went well (false if errors occurred)  

        * `solve(system, b, x) -> bool`  

            Parameters:  
            * `system` :  
                system to be solved  
            * `b` :  
                right-hand side  
            * `x` :  
                solution to the system  

            Returns:
            whether all went well (false if errors occurred)  

        """
        return _pysgpp_swig.UMFPACK_solve(self, *args)

    def __init__(self):
        _pysgpp_swig.UMFPACK_swiginit(self, _pysgpp_swig.new_UMFPACK())

# Register UMFPACK in _pysgpp_swig:
_pysgpp_swig.UMFPACK_swigregister(UMFPACK)

class MutexType(object):
    r"""

    `MutexType()`  
    `MutexType(other)`  

    Wrapper for OpenMP nested locks.  

    Once locked, other threads block when trying to lock the same MutexType.
    However, the MutexType can be locked multiple times by the same thread without
    blocking. In this case, it has to be unlocked the same number of times to let
    the other threads continuing execution.  

    Adopted from http://bisqwit.iki.fi/story/howto/openmp/#Locks.  

    Constructors
    ------------
    * `MutexType()`  

        Constructor.  

    * `MutexType(other)`  

        Custom copy constructor to prevent copying the lock.  

        Parameters:  
        * `other` :  
            object to be copied  

    C++ includes: MutexType.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def lock(self) -> "void":
        r"""


        Lock the MutexType.  

        """
        return _pysgpp_swig.MutexType_lock(self)

    def unlock(self) -> "void":
        r"""


        Unlock the MutexType.  

        """
        return _pysgpp_swig.MutexType_unlock(self)

    def __init__(self):
        r"""


        Overloaded function
        -------------------
        * `MutexType()`  

            Constructor.  

        * `MutexType(other)`  

            Custom copy constructor to prevent copying the lock.  

            Parameters:  
            * `other` :  
                object to be copied  

        """
        _pysgpp_swig.MutexType_swiginit(self, _pysgpp_swig.new_MutexType())
    __swig_destroy__ = _pysgpp_swig.delete_MutexType

# Register MutexType in _pysgpp_swig:
_pysgpp_swig.MutexType_swigregister(MutexType)


def __lshift__(*args) -> "std::ostream &":
    return _pysgpp_swig.__lshift__(*args)
class Printer(object):
    r"""


    Singleton class to facilitate debugging output.  

    Use with the sgpp::printer instance.  

    The status printing functions won't print anything if  

    *   status printing is disabled with disableStatusPrinting() OR  
    *   the current "indentation level" (calls of printStatusBegin()) exceeds the
        "verbosity".  

    C++ includes: Printer.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DEFAULT_VERBOSITY = _pysgpp_swig.Printer_DEFAULT_VERBOSITY

    @staticmethod
    def getInstance() -> "sgpp::base::Printer &":
        r"""


        Returns
        -------
        singleton instance  

        """
        return _pysgpp_swig.Printer_getInstance()

    def printStatusBegin(self, msg: "std::string const &") -> "void":
        r"""


        Call at the beginning of a time-consuming operation.  

        Locks and unlocks an OpenMP mutex.  

        Parameters
        ----------
        * `msg` :  
            short description of the operation  

        """
        return _pysgpp_swig.Printer_printStatusBegin(self, msg)

    def printStatusUpdate(self, msg: "std::string const &") -> "void":
        r"""


        Call for printing status updates on the operation.  

        The last status is erased, if printStatusNewLine has not been called before.
        Locks and unlocks an OpenMP mutex.  

        Parameters
        ----------
        * `msg` :  
            status message  

        """
        return _pysgpp_swig.Printer_printStatusUpdate(self, msg)

    def printStatusNewLine(self) -> "void":
        r"""


        End the last status update and place the cursor in a newline.  

        """
        return _pysgpp_swig.Printer_printStatusNewLine(self)

    def printStatusIdentation(self) -> "void":
        r"""


        Internal function printing the indentation.  

        """
        return _pysgpp_swig.Printer_printStatusIdentation(self)

    def printStatusEnd(self, *args) -> "void":
        r"""


        Call at the end of a time-consuming operation.  

        Locks and unlocks an OpenMP mutex.  

        Retrieve the running time of the operation with getLastDurationSecs() (also
        works with nested calls of printStatusBegin()).  

        Parameters
        ----------
        * `msg` :  
            short description of the result, e.g. "success" or "error" (optional)  

        """
        return _pysgpp_swig.Printer_printStatusEnd(self, *args)

    def enableStatusPrinting(self) -> "void":
        r"""


        Enable the printStatus...  

        functions. (They're enabled by default.)  

        """
        return _pysgpp_swig.Printer_enableStatusPrinting(self)

    def disableStatusPrinting(self) -> "void":
        r"""


        Disable the printStatus...  

        functions. (They're enabled by default.)  

        """
        return _pysgpp_swig.Printer_disableStatusPrinting(self)

    def isStatusPrintingEnabled(self) -> "bool":
        r"""


        Returns
        -------
        whether status printing is enabled or not  

        """
        return _pysgpp_swig.Printer_isStatusPrintingEnabled(self)

    def getVerbosity(self) -> "int":
        r"""


        Returns
        -------
        current verbosity level  

        """
        return _pysgpp_swig.Printer_getVerbosity(self)

    def setVerbosity(self, level: "int") -> "void":
        r"""


        Parameters
        ----------
        * `level` :  
            new verbosity level  

        """
        return _pysgpp_swig.Printer_setVerbosity(self, level)

    def getLastDurationSecs(self) -> "double":
        r"""


        Returns
        -------
        running-time of the last operation terminated by printStatusEnd()  

        """
        return _pysgpp_swig.Printer_getLastDurationSecs(self)

    def getMutex(self) -> "sgpp::base::MutexType &":
        r"""


        Returns
        -------
        internal mutex  

        """
        return _pysgpp_swig.Printer_getMutex(self)

    def getStream(self) -> "std::ostream *":
        r"""


        Returns
        -------
        stream used for printing (default std::cout)  

        """
        return _pysgpp_swig.Printer_getStream(self)

    def setStream(self, stream: "std::ostream *") -> "void":
        r"""


        Parameters
        ----------
        * `stream` :  
            stream used for printing (default std::cout)  

        """
        return _pysgpp_swig.Printer_setStream(self, stream)

    def getLineLengthLimit(self) -> "size_t":
        r"""


        Returns
        -------
        maximum length of lines, 0 if unbounded  

        """
        return _pysgpp_swig.Printer_getLineLengthLimit(self)

    def setLineLengthLimit(self, lineLengthLimit: "size_t") -> "void":
        r"""


        Parameters
        ----------
        * `lineLengthLimit` :  
            maximum length of lines, 0 if unbounded  

        """
        return _pysgpp_swig.Printer_setLineLengthLimit(self, lineLengthLimit)

    def printSLE(self, system: "SLE") -> "void":
        r"""


        Print a system of linear equations.  

        Parameters
        ----------
        * `system` :  
            system to be printed  

        """
        return _pysgpp_swig.Printer_printSLE(self, system)
    __swig_destroy__ = _pysgpp_swig.delete_Printer

# Register Printer in _pysgpp_swig:
_pysgpp_swig.Printer_swigregister(Printer)

def Printer_getInstance() -> "sgpp::base::Printer &":
    r"""


    Returns
    -------
    singleton instance  

    """
    return _pysgpp_swig.Printer_getInstance()

class SLinearBase(SBasis):
    r"""


    Linear basis on Noboundary grids.  

    C++ includes: LinearBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SLinearBase

    def __init__(self):
        _pysgpp_swig.SLinearBase_swiginit(self, _pysgpp_swig.new_SLinearBase())

# Register SLinearBase in _pysgpp_swig:
_pysgpp_swig.SLinearBase_swigregister(SLinearBase)

class SLinearBoundaryBase(SBasis):
    r"""


    Linear basis on Boundary grids.  

    C++ includes: LinearBoundaryBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SLinearBoundaryBase

    def eval(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `eval(l, i, x) -> double`  

            Parameters:  
            * `l` :  
                level of basis function  
            * `i` :  
                index of basis function  
            * `x` :  
                evaluation point  

            Returns:
            value of boundary linear basis function  

        * `eval(l, i, x, q, t) -> double`  

            Evaluate basis function with offset and scaling factor.  

            Parameters:  
            * `l` :  
                level of basis function  
            * `i` :  
                index of basis function  
            * `x` :  
                evaluation point  
            * `q` :  
                scaling factor of basis function  
            * `t` :  
                offset of basis function  

        """
        return _pysgpp_swig.SLinearBoundaryBase_eval(self, *args)

    def __init__(self):
        _pysgpp_swig.SLinearBoundaryBase_swiginit(self, _pysgpp_swig.new_SLinearBoundaryBase())

# Register SLinearBoundaryBase in _pysgpp_swig:
_pysgpp_swig.SLinearBoundaryBase_swigregister(SLinearBoundaryBase)

class SLinearClenshawCurtisBase(SBasis):
    r"""


    Linear basis on Clenshaw-Curtis grids.  

    C++ includes: LinearClenshawCurtisBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        """
        _pysgpp_swig.SLinearClenshawCurtisBase_swiginit(self, _pysgpp_swig.new_SLinearClenshawCurtisBase())
    __swig_destroy__ = _pysgpp_swig.delete_SLinearClenshawCurtisBase

    def eval(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `eval(l, i, x) -> double`  

            Parameters:  
            * `l` :  
                level of basis function  
            * `i` :  
                index of basis function  
            * `x` :  
                evaluation point  

            Returns:
            value of Clenshaw-Curtis linear basis function  

        * `eval(level, index, p, offset, width) -> double`  

        """
        return _pysgpp_swig.SLinearClenshawCurtisBase_eval(self, *args)

# Register SLinearClenshawCurtisBase in _pysgpp_swig:
_pysgpp_swig.SLinearClenshawCurtisBase_swigregister(SLinearClenshawCurtisBase)

class SLinearClenshawCurtisBoundaryBase(SBasis):
    r"""


    Linear basis on Clenshaw-Curtis grids.  

    C++ includes: LinearClenshawCurtisBoundaryBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        """
        _pysgpp_swig.SLinearClenshawCurtisBoundaryBase_swiginit(self, _pysgpp_swig.new_SLinearClenshawCurtisBoundaryBase())
    __swig_destroy__ = _pysgpp_swig.delete_SLinearClenshawCurtisBoundaryBase

    def eval(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `eval(l, i, x) -> double`  

            Parameters:  
            * `l` :  
                level of basis function  
            * `i` :  
                index of basis function  
            * `x` :  
                evaluation point  

            Returns:
            value of Clenshaw-Curtis linear basis function  

        * `eval(level, index, p, offset, width) -> double`  

        """
        return _pysgpp_swig.SLinearClenshawCurtisBoundaryBase_eval(self, *args)

# Register SLinearClenshawCurtisBoundaryBase in _pysgpp_swig:
_pysgpp_swig.SLinearClenshawCurtisBoundaryBase_swigregister(SLinearClenshawCurtisBoundaryBase)

class SLinearModifiedClenshawCurtisBase(SBasis):
    r"""


    Modified polynomial base functions.  

    Special polynomial functions to cover values unequal 0 at the border.
    Implemented as seen in AWR 2 paper by Prof. Bungartz
    (http://www5.in.tum.de/wiki/index.php/Algorithmen_des_Wissenschaftlichen_Rechnens_II_-
    _Winter_08)  

    C++ includes: LinearModifiedClenshawCurtisBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.SLinearModifiedClenshawCurtisBase_swiginit(self, _pysgpp_swig.new_SLinearModifiedClenshawCurtisBase())
    __swig_destroy__ = _pysgpp_swig.delete_SLinearModifiedClenshawCurtisBase

    def eval(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `eval(level, index, x) -> double`  

            Evaluate the basis function with given level and index.  

            Parameters:  
            * `level` :  
                level of the basis function  
            * `index` :  
                index of the basis function  
            * `x` :  
                evaluation point  

            Returns:
            value of the basis function.  

        * `eval(level, index, p, offset, width) -> double`  

        """
        return _pysgpp_swig.SLinearModifiedClenshawCurtisBase_eval(self, *args)

    def evalHierToTop(self, level: "unsigned int", index: "unsigned int", coeffs: "DataVector", pos: "double") -> "double":
        r"""


        Evaluates all the hierarchical ancestors of the node defined by level and index.  

        NOTE: It does not evaluate the current node itself.  

        Parameters
        ----------
        * `level` :  
        * `index` :  
        * `coeffs` :  
        * `pos` :  

        Returns
        -------  

        """
        return _pysgpp_swig.SLinearModifiedClenshawCurtisBase_evalHierToTop(self, level, index, coeffs, pos)

# Register SLinearModifiedClenshawCurtisBase in _pysgpp_swig:
_pysgpp_swig.SLinearModifiedClenshawCurtisBase_swigregister(SLinearModifiedClenshawCurtisBase)

class SLinearStretchedBase(SLinearBase):
    r"""


    linearstretched base functions.  

    And here we have another implicit dependence on tensor products  

    C++ includes: LinearStretchedBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SLinearStretchedBase

    def stretchedEval(self, p: "double", pos0: "double", pos1: "double") -> "double":
        r"""


        Evaluate a basis function.  

        Has a dependence on the absolute position of grid point and support.  

        double eval(LT level, IT index, double p) { return 1.0 - fabs((1<<level) * p -
        index); }  

        """
        return _pysgpp_swig.SLinearStretchedBase_stretchedEval(self, p, pos0, pos1)

    def __init__(self):
        _pysgpp_swig.SLinearStretchedBase_swiginit(self, _pysgpp_swig.new_SLinearStretchedBase())

# Register SLinearStretchedBase in _pysgpp_swig:
_pysgpp_swig.SLinearStretchedBase_swigregister(SLinearStretchedBase)

class SLinearStretchedBoundaryBase(SLinearBoundaryBase):
    r"""


    linearstretched basis functions with boundaries And here we have another
    implicit dependence on tensor products  

    C++ includes: LinearStretchedBoundaryBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SLinearStretchedBoundaryBase

    def stretchedEval(self, p: "double", pos0: "double", pos1: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.SLinearStretchedBoundaryBase_stretchedEval(self, p, pos0, pos1)

    def __init__(self):
        _pysgpp_swig.SLinearStretchedBoundaryBase_swiginit(self, _pysgpp_swig.new_SLinearStretchedBoundaryBase())

# Register SLinearStretchedBoundaryBase in _pysgpp_swig:
_pysgpp_swig.SLinearStretchedBoundaryBase_swigregister(SLinearStretchedBoundaryBase)

class SLinearModifiedBase(SBasis):
    r"""


    Modified linear basis on Noboundary grids.  

    C++ includes: LinearModifiedBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SLinearModifiedBase

    def __init__(self):
        _pysgpp_swig.SLinearModifiedBase_swiginit(self, _pysgpp_swig.new_SLinearModifiedBase())

# Register SLinearModifiedBase in _pysgpp_swig:
_pysgpp_swig.SLinearModifiedBase_swigregister(SLinearModifiedBase)

class SPolyBase(SBasis):
    r"""


    Polynomial basis functions.  


    C++ includes: PolyBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, degree: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `degree` :  
            the polynom's max. degree  

        """
        _pysgpp_swig.SPolyBase_swiginit(self, _pysgpp_swig.new_SPolyBase(degree))
    __swig_destroy__ = _pysgpp_swig.delete_SPolyBase

    def evalHierToTop(self, level: "unsigned int", index: "unsigned int", coeffs: "DataVector", pos: "double") -> "double":
        r"""


        Evaluates all the hierarchical ancestors of the node defined by level and index.  

        NOTE: It does not evaluate the current node itself.  

        Parameters
        ----------
        * `level` :  
        * `index` :  
        * `coeffs` :  
        * `pos` :  

        Returns
        -------  

        """
        return _pysgpp_swig.SPolyBase_evalHierToTop(self, level, index, coeffs, pos)

    def evalDx(self, level: "unsigned int", index: "unsigned int", x: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.SPolyBase_evalDx(self, level, index, x)

    def evalBasis(self, level: "unsigned int", index: "unsigned int", p: "double") -> "double":
        r"""


        Evaluate a basis function.  

        Has a dependence on the absolute position of grid point and support.  

        We compute the roots in units of h = grid spacing at level l = 2 ** -l.  

        Due to limited polynomial degree, we compute the roots of the Lagrange
        polynomial bottom up.  

        """
        return _pysgpp_swig.SPolyBase_evalBasis(self, level, index, p)

# Register SPolyBase in _pysgpp_swig:
_pysgpp_swig.SPolyBase_swigregister(SPolyBase)

class SPolyBoundaryBase(SBasis):
    r"""


    Polynomial basis functions with boundaries.  


    C++ includes: PolyBoundaryBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, degree: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `degree` :  
            the polynom's max. degree  

        """
        _pysgpp_swig.SPolyBoundaryBase_swiginit(self, _pysgpp_swig.new_SPolyBoundaryBase(degree))
    __swig_destroy__ = _pysgpp_swig.delete_SPolyBoundaryBase

    def evalHierToTop(self, level: "unsigned int", index: "unsigned int", coeffs: "DataVector", pos: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.SPolyBoundaryBase_evalHierToTop(self, level, index, coeffs, pos)

    def eval(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `eval(level, index, x) -> double`  

            Evaluate the basis function with given level and index.  

            Parameters:  
            * `level` :  
                level of the basis function  
            * `index` :  
                index of the basis function  
            * `x` :  
                evaluation point  

            Returns:
            value of the basis function.  

        * `eval(level, index, p, offset, width) -> double`  

        """
        return _pysgpp_swig.SPolyBoundaryBase_eval(self, *args)

    def evalDx(self, level: "unsigned int", index: "unsigned int", x: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.SPolyBoundaryBase_evalDx(self, level, index, x)

# Register SPolyBoundaryBase in _pysgpp_swig:
_pysgpp_swig.SPolyBoundaryBase_swigregister(SPolyBoundaryBase)

class SPolyModifiedBase(SBasis):
    r"""


    Modified polynomial base functions.  

    Special polynomial functions to cover values unequal 0 at the border.
    Implemented as seen in AWR 2 paper by Prof. Bungartz
    (http://www5.in.tum.de/wiki/index.php/Algorithmen_des_Wissenschaftlichen_Rechnens_II_-
    _Winter_08)  

    C++ includes: PolyModifiedBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, degree: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `degree` :  
            the polynom's max. degree  

        """
        _pysgpp_swig.SPolyModifiedBase_swiginit(self, _pysgpp_swig.new_SPolyModifiedBase(degree))
    __swig_destroy__ = _pysgpp_swig.delete_SPolyModifiedBase

    def eval(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `eval(level, index, x) -> double`  

            Evaluate the basis function with given level and index.  

            Parameters:  
            * `level` :  
                level of the basis function  
            * `index` :  
                index of the basis function  
            * `x` :  
                evaluation point  

            Returns:
            value of the basis function.  

        * `eval(level, index, p, offset, width) -> double`  

        """
        return _pysgpp_swig.SPolyModifiedBase_eval(self, *args)

    def evalDx(self, level: "unsigned int", index: "unsigned int", x: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.SPolyModifiedBase_evalDx(self, level, index, x)

    def evalHierToTop(self, level: "unsigned int", index: "unsigned int", coeffs: "DataVector", pos: "double") -> "double":
        r"""


        Evaluates all the hierarchical ancestors of the node defined by level and index.  

        NOTE: It does not evaluate the current node itself.  

        Parameters
        ----------
        * `level` :  
        * `index` :  
        * `coeffs` :  
        * `pos` :  

        Returns
        -------  

        """
        return _pysgpp_swig.SPolyModifiedBase_evalHierToTop(self, level, index, coeffs, pos)

# Register SPolyModifiedBase in _pysgpp_swig:
_pysgpp_swig.SPolyModifiedBase_swigregister(SPolyModifiedBase)

class SPolyClenshawCurtisBase(SBasis):
    r"""


    Polynomial basis functions.  


    C++ includes: PolyClenshawCurtisBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, degree: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `degree` :  
            the polynom's max. degree  

        """
        _pysgpp_swig.SPolyClenshawCurtisBase_swiginit(self, _pysgpp_swig.new_SPolyClenshawCurtisBase(degree))
    __swig_destroy__ = _pysgpp_swig.delete_SPolyClenshawCurtisBase

    def evalHierToTop(self, level: "unsigned int", index: "unsigned int", coeffs: "DataVector", pos: "double") -> "double":
        r"""


        Evaluates all the hierarchical ancestors of the node defined by level and index.  

        NOTE: It does not evaluate the current node itself.  

        Parameters
        ----------
        * `level` :  
        * `index` :  
        * `coeffs` :  
        * `pos` :  

        Returns
        -------  

        """
        return _pysgpp_swig.SPolyClenshawCurtisBase_evalHierToTop(self, level, index, coeffs, pos)

    def evalDx(self, level: "unsigned int", index: "unsigned int", x: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.SPolyClenshawCurtisBase_evalDx(self, level, index, x)

    def evalBasis(self, level: "unsigned int", index: "unsigned int", p: "double") -> "double":
        r"""


        Evaluate a basis function.  

        Has a dependence on the absolute position of grid point and support.  

        We compute the roots in units of h = grid spacing at level l = 2 ** -l.  

        Due to limited polynomial degree, we compute the roots of the Lagrange
        polynomial bottom up.  

        """
        return _pysgpp_swig.SPolyClenshawCurtisBase_evalBasis(self, level, index, p)

# Register SPolyClenshawCurtisBase in _pysgpp_swig:
_pysgpp_swig.SPolyClenshawCurtisBase_swigregister(SPolyClenshawCurtisBase)

class SPolyClenshawCurtisBoundaryBase(SBasis):
    r"""


    Polynomial basis functions.  


    C++ includes: PolyClenshawCurtisBoundaryBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, degree: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `degree` :  
            the polynom's max. degree  

        """
        _pysgpp_swig.SPolyClenshawCurtisBoundaryBase_swiginit(self, _pysgpp_swig.new_SPolyClenshawCurtisBoundaryBase(degree))
    __swig_destroy__ = _pysgpp_swig.delete_SPolyClenshawCurtisBoundaryBase

    def evalHierToTop(self, level: "unsigned int", index: "unsigned int", coeffs: "DataVector", pos: "double") -> "double":
        r"""


        Evaluates all the hierarchical ancestors of the node defined by level and index.  

        NOTE: It does not evaluate the current node itself.  

        Parameters
        ----------
        * `level` :  
        * `index` :  
        * `coeffs` :  
        * `pos` :  

        Returns
        -------  

        """
        return _pysgpp_swig.SPolyClenshawCurtisBoundaryBase_evalHierToTop(self, level, index, coeffs, pos)

    def evalDx(self, level: "unsigned int", index: "unsigned int", x: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.SPolyClenshawCurtisBoundaryBase_evalDx(self, level, index, x)

    def eval(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `eval(level, index, x) -> double`  

            Evaluate the basis function with given level and index.  

            Parameters:  
            * `level` :  
                level of the basis function  
            * `index` :  
                index of the basis function  
            * `x` :  
                evaluation point  

            Returns:
            value of the basis function.  

        * `eval(level, index, p, offset, width) -> double`  

        """
        return _pysgpp_swig.SPolyClenshawCurtisBoundaryBase_eval(self, *args)

# Register SPolyClenshawCurtisBoundaryBase in _pysgpp_swig:
_pysgpp_swig.SPolyClenshawCurtisBoundaryBase_swigregister(SPolyClenshawCurtisBoundaryBase)

class SPolyModifiedClenshawCurtisBase(SBasis):
    r"""


    Modified polynomial base functions.  

    Special polynomial functions to cover values unequal 0 at the border.
    Implemented as seen in AWR 2 paper by Prof. Bungartz
    (http://www5.in.tum.de/wiki/index.php/Algorithmen_des_Wissenschaftlichen_Rechnens_II_-
    _Winter_08)  

    C++ includes: PolyModifiedClenshawCurtisBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, degree: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `degree` :  
            the polynom's max. degree  

        """
        _pysgpp_swig.SPolyModifiedClenshawCurtisBase_swiginit(self, _pysgpp_swig.new_SPolyModifiedClenshawCurtisBase(degree))
    __swig_destroy__ = _pysgpp_swig.delete_SPolyModifiedClenshawCurtisBase

    def eval(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `eval(level, index, x) -> double`  

            Evaluate the basis function with given level and index.  

            Parameters:  
            * `level` :  
                level of the basis function  
            * `index` :  
                index of the basis function  
            * `x` :  
                evaluation point  

            Returns:
            value of the basis function.  

        * `eval(level, index, p, offset, width) -> double`  

        """
        return _pysgpp_swig.SPolyModifiedClenshawCurtisBase_eval(self, *args)

    def evalHierToTop(self, level: "unsigned int", index: "unsigned int", coeffs: "DataVector", pos: "double") -> "double":
        r"""


        Evaluates all the hierarchical ancestors of the node defined by level and index.  

        NOTE: It does not evaluate the current node itself.  

        Parameters
        ----------
        * `level` :  
        * `index` :  
        * `coeffs` :  
        * `pos` :  

        Returns
        -------  

        """
        return _pysgpp_swig.SPolyModifiedClenshawCurtisBase_evalHierToTop(self, level, index, coeffs, pos)

    def evalDx(self, level: "unsigned int", index: "unsigned int", x: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.SPolyModifiedClenshawCurtisBase_evalDx(self, level, index, x)

# Register SPolyModifiedClenshawCurtisBase in _pysgpp_swig:
_pysgpp_swig.SPolyModifiedClenshawCurtisBase_swigregister(SPolyModifiedClenshawCurtisBase)

class SWaveletBase(SBasis):
    r"""


    Wavelet basis on Noboundary grids.  

    C++ includes: WaveletBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SWaveletBase

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of wavelet basis function  

        """
        return _pysgpp_swig.SWaveletBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of wavelet basis function  

        """
        return _pysgpp_swig.SWaveletBase_evalDxDx(self, l, i, x)

    def __init__(self):
        _pysgpp_swig.SWaveletBase_swiginit(self, _pysgpp_swig.new_SWaveletBase())

# Register SWaveletBase in _pysgpp_swig:
_pysgpp_swig.SWaveletBase_swigregister(SWaveletBase)

class SWaveletBoundaryBase(SBasis):
    r"""


    Wavelet basis on Boundary grids.  

    C++ includes: WaveletBoundaryBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SWaveletBoundaryBase

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of boundary wavelet basis function  

        """
        return _pysgpp_swig.SWaveletBoundaryBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of boundary wavelet basis function  

        """
        return _pysgpp_swig.SWaveletBoundaryBase_evalDxDx(self, l, i, x)

    def __init__(self):
        _pysgpp_swig.SWaveletBoundaryBase_swiginit(self, _pysgpp_swig.new_SWaveletBoundaryBase())

# Register SWaveletBoundaryBase in _pysgpp_swig:
_pysgpp_swig.SWaveletBoundaryBase_swigregister(SWaveletBoundaryBase)

class SWaveletModifiedBase(SBasis):
    r"""


    Modified wavelet basis on Noboundary grids.  

    C++ includes: WaveletModifiedBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SWaveletModifiedBase

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of modified wavelet basis function  

        """
        return _pysgpp_swig.SWaveletModifiedBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of modified wavelet basis function  

        """
        return _pysgpp_swig.SWaveletModifiedBase_evalDxDx(self, l, i, x)

    def __init__(self):
        _pysgpp_swig.SWaveletModifiedBase_swiginit(self, _pysgpp_swig.new_SWaveletModifiedBase())

# Register SWaveletModifiedBase in _pysgpp_swig:
_pysgpp_swig.SWaveletModifiedBase_swigregister(SWaveletModifiedBase)

class SBsplineBase(SBasis):
    r"""


    B-spline basis on Noboundary grids.  

    C++ includes: BsplineBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `BsplineBasis()`  

            Default constructor.  

        * `BsplineBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SBsplineBase_swiginit(self, _pysgpp_swig.new_SBsplineBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SBsplineBase

    def uniformBSpline(self, x: "double", p: "size_t") -> "double":
        r"""


        Parameters
        ----------
        * `x` :  
            evaluation point  
        * `p` :  
            B-spline degree  

        Returns
        -------
        value of uniform B-spline (with knots $\{0, 1, ..., p+1\}$)  

        """
        return _pysgpp_swig.SBsplineBase_uniformBSpline(self, x, p)

    def uniformBSplineDx(self, x: "double", p: "size_t") -> "double":
        r"""


        Parameters
        ----------
        * `x` :  
            evaluation point  
        * `p` :  
            B-spline degree  

        Returns
        -------
        value of derivative of uniform B-spline (with knots $\{0, 1, ..., p+1\}$)  

        """
        return _pysgpp_swig.SBsplineBase_uniformBSplineDx(self, x, p)

    def uniformBSplineDxDx(self, x: "double", p: "size_t") -> "double":
        r"""


        Parameters
        ----------
        * `x` :  
            evaluation point  
        * `p` :  
            B-spline degree  

        Returns
        -------
        value of 2nd derivative of uniform B-spline (with knots $\{0, 1, ..., p+1\}$)  

        """
        return _pysgpp_swig.SBsplineBase_uniformBSplineDxDx(self, x, p)

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of B-spline basis function  

        """
        return _pysgpp_swig.SBsplineBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of B-spline basis function  

        """
        return _pysgpp_swig.SBsplineBase_evalDxDx(self, l, i, x)

# Register SBsplineBase in _pysgpp_swig:
_pysgpp_swig.SBsplineBase_swigregister(SBsplineBase)

class SBsplineBoundaryBase(SBasis):
    r"""


    B-spline basis on Boundary grids.  

    C++ includes: BsplineBoundaryBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `BsplineBoundaryBasis()`  

            Default constructor.  

        * `BsplineBoundaryBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SBsplineBoundaryBase_swiginit(self, _pysgpp_swig.new_SBsplineBoundaryBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SBsplineBoundaryBase

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of boundary B-spline basis function  

        """
        return _pysgpp_swig.SBsplineBoundaryBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of boundary B-spline basis function  

        """
        return _pysgpp_swig.SBsplineBoundaryBase_evalDxDx(self, l, i, x)

# Register SBsplineBoundaryBase in _pysgpp_swig:
_pysgpp_swig.SBsplineBoundaryBase_swigregister(SBsplineBoundaryBase)

class SBsplineClenshawCurtisBase(SBasis):
    r"""


    B-spline basis on Clenshaw-Curtis grids.  

    C++ includes: BsplineClenshawCurtisBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `BsplineClenshawCurtisBasis()`  

            Default constructor.  

        * `BsplineClenshawCurtisBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SBsplineClenshawCurtisBase_swiginit(self, _pysgpp_swig.new_SBsplineClenshawCurtisBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SBsplineClenshawCurtisBase

    def nonUniformBSpline(self, x: "double", p: "size_t", k: "size_t") -> "double":
        r"""


        Parameters
        ----------
        * `x` :  
            evaluation point  
        * `p` :  
            B-spline degree  
        * `k` :  
            index of B-spline in the knot sequence  

        Returns
        -------
        value of non-uniform B-spline with knots $\{\xi_k, ... \xi_{k+p+1}\}$  

        """
        return _pysgpp_swig.SBsplineClenshawCurtisBase_nonUniformBSpline(self, x, p, k)

    def nonUniformBSplineDx(self, x: "double", p: "size_t", k: "size_t") -> "double":
        r"""


        Parameters
        ----------
        * `x` :  
            evaluation point  
        * `p` :  
            B-spline degree  
        * `k` :  
            index of B-spline in the knot sequence  

        Returns
        -------
        value of derivative of non-uniform B-spline with knots $\{\xi_k, ...
        \xi_{k+p+1}\}$  

        """
        return _pysgpp_swig.SBsplineClenshawCurtisBase_nonUniformBSplineDx(self, x, p, k)

    def nonUniformBSplineDxDx(self, x: "double", p: "size_t", k: "size_t") -> "double":
        r"""


        Parameters
        ----------
        * `x` :  
            evaluation point  
        * `p` :  
            B-spline degree  
        * `k` :  
            index of B-spline in the knot sequence  

        Returns
        -------
        value of 2nd derivative of non-uniform B-spline with knots $\{\xi_k, ...
        \xi_{k+p+1}\}$  

        """
        return _pysgpp_swig.SBsplineClenshawCurtisBase_nonUniformBSplineDxDx(self, x, p, k)

    def clenshawCurtisPoint(self, l: "unsigned int", i: "unsigned int") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of the grid point  
        * `i` :  
            index of the grid point  

        Returns
        -------
        i-th Clenshaw-Curtis grid point with level l  

        """
        return _pysgpp_swig.SBsplineClenshawCurtisBase_clenshawCurtisPoint(self, l, i)

    def constructKnots(self, l: "unsigned int", i: "unsigned int") -> "void":
        r"""


        Construct the (p+2) Clenshaw-Curtis knots of a B-spline basis function and save
        them in xi.  

        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  

        """
        return _pysgpp_swig.SBsplineClenshawCurtisBase_constructKnots(self, l, i)

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of Clenshaw-Curtis B-spline basis function  

        """
        return _pysgpp_swig.SBsplineClenshawCurtisBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of Clenshaw-Curtis B-spline basis function  

        """
        return _pysgpp_swig.SBsplineClenshawCurtisBase_evalDxDx(self, l, i, x)

# Register SBsplineClenshawCurtisBase in _pysgpp_swig:
_pysgpp_swig.SBsplineClenshawCurtisBase_swigregister(SBsplineClenshawCurtisBase)

class SBsplineModifiedBase(SBasis):
    r"""


    Modified B-spline basis on Noboundary grids.  

    C++ includes: BsplineModifiedBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `BsplineModifiedBasis()`  

            Default constructor.  

        * `BsplineModifiedBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SBsplineModifiedBase_swiginit(self, _pysgpp_swig.new_SBsplineModifiedBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SBsplineModifiedBase

    def modifiedBSpline(self, x: "double", p: "size_t") -> "double":
        r"""


        Parameters
        ----------
        * `x` :  
            evaluation point  
        * `p` :  
            B-spline degree  

        Returns
        -------
        value of modified uniform B-spline (e.g. index == 1)  

        """
        return _pysgpp_swig.SBsplineModifiedBase_modifiedBSpline(self, x, p)

    def modifiedBSplineDx(self, x: "double", p: "size_t") -> "double":
        r"""


        Parameters
        ----------
        * `x` :  
            evaluation point  
        * `p` :  
            B-spline degree  

        Returns
        -------
        value of derivative of modified uniform B-spline (e.g. index == 1)  

        """
        return _pysgpp_swig.SBsplineModifiedBase_modifiedBSplineDx(self, x, p)

    def modifiedBSplineDxDx(self, x: "double", p: "size_t") -> "double":
        r"""


        Parameters
        ----------
        * `x` :  
            evaluation point  
        * `p` :  
            B-spline degree  

        Returns
        -------
        value of 2nd derivative of modified uniform B-spline (e.g. index == 1)  

        """
        return _pysgpp_swig.SBsplineModifiedBase_modifiedBSplineDxDx(self, x, p)

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of modified B-spline basis function  

        """
        return _pysgpp_swig.SBsplineModifiedBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of modified B-spline basis function  

        """
        return _pysgpp_swig.SBsplineModifiedBase_evalDxDx(self, l, i, x)

# Register SBsplineModifiedBase in _pysgpp_swig:
_pysgpp_swig.SBsplineModifiedBase_swigregister(SBsplineModifiedBase)

class SBsplineModifiedClenshawCurtisBase(SBasis):
    r"""


    B-spline basis on Clenshaw-Curtis grids.  

    C++ includes: BsplineModifiedClenshawCurtisBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `BsplineModifiedClenshawCurtisBasis()`  

            Default constructor.  

        * `BsplineModifiedClenshawCurtisBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SBsplineModifiedClenshawCurtisBase_swiginit(self, _pysgpp_swig.new_SBsplineModifiedClenshawCurtisBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SBsplineModifiedClenshawCurtisBase

    def clenshawCurtisPoint(self, l: "unsigned int", i: "unsigned int") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of the grid point  
        * `i` :  
            index of the grid point  

        Returns
        -------
        i-th Clenshaw-Curtis grid point with level l  

        """
        return _pysgpp_swig.SBsplineModifiedClenshawCurtisBase_clenshawCurtisPoint(self, l, i)

    def clenshawCurtisPointNegativeIndex(self, l: "unsigned int", ni: "unsigned int") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of the grid point  
        * `ni` :  
            neagtive index -i of the grid point  

        Returns
        -------
        (-ni)-th Clenshaw-Curtis grid point with level l  

        """
        return _pysgpp_swig.SBsplineModifiedClenshawCurtisBase_clenshawCurtisPointNegativeIndex(self, l, ni)

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of modified Clenshaw-Curtis B-spline basis function  

        """
        return _pysgpp_swig.SBsplineModifiedClenshawCurtisBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of modified Clenshaw-Curtis B-spline basis function  

        """
        return _pysgpp_swig.SBsplineModifiedClenshawCurtisBase_evalDxDx(self, l, i, x)

# Register SBsplineModifiedClenshawCurtisBase in _pysgpp_swig:
_pysgpp_swig.SBsplineModifiedClenshawCurtisBase_swigregister(SBsplineModifiedClenshawCurtisBase)

class SFundamentalNakSplineBase(SBasis):
    r"""


    Fundamental not-a-knot spline basis.  

    C++ includes: FundamentalNakSplineBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `FundamentalNakSplineBasis()`  

            Default constructor.  

        * `FundamentalNakSplineBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SFundamentalNakSplineBase_swiginit(self, _pysgpp_swig.new_SFundamentalNakSplineBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SFundamentalNakSplineBase

    def getCoefficients(self, l: "unsigned int", i: "unsigned int", coefficients: "DoubleVector") -> "int":
        r"""


        """
        return _pysgpp_swig.SFundamentalNakSplineBase_getCoefficients(self, l, i, coefficients)

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of fundamental not-a-knot spline basis function  

        """
        return _pysgpp_swig.SFundamentalNakSplineBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of fundamental not-a-knot spline basis function  

        """
        return _pysgpp_swig.SFundamentalNakSplineBase_evalDxDx(self, l, i, x)

# Register SFundamentalNakSplineBase in _pysgpp_swig:
_pysgpp_swig.SFundamentalNakSplineBase_swigregister(SFundamentalNakSplineBase)

class SFundamentalSplineBase(SBasis):
    r"""


    Fundamental spline basis.  

    C++ includes: FundamentalSplineBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `FundamentalSplineBasis()`  

            Default constructor.  

        * `FundamentalSplineBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SFundamentalSplineBase_swiginit(self, _pysgpp_swig.new_SFundamentalSplineBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SFundamentalSplineBase

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of fundamental spline basis function  

        """
        return _pysgpp_swig.SFundamentalSplineBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of fundamental spline basis function  

        """
        return _pysgpp_swig.SFundamentalSplineBase_evalDxDx(self, l, i, x)

# Register SFundamentalSplineBase in _pysgpp_swig:
_pysgpp_swig.SFundamentalSplineBase_swigregister(SFundamentalSplineBase)

class SFundamentalSplineModifiedBase(SBasis):
    r"""


    Modified fundamental spline basis on Noboundary grids.  

    C++ includes: FundamentalSplineModifiedBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `FundamentalSplineModifiedBasis()`  

            Default constructor.  

        * `FundamentalSplineModifiedBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                fundamental spline degree, must be odd (if it's even, degree - 1 is
                used)  

        """
        _pysgpp_swig.SFundamentalSplineModifiedBase_swiginit(self, _pysgpp_swig.new_SFundamentalSplineModifiedBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SFundamentalSplineModifiedBase

    def evalDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of derivative of modified fundamental spline basis function  

        """
        return _pysgpp_swig.SFundamentalSplineModifiedBase_evalDx(self, l, i, x)

    def evalDxDx(self, l: "unsigned int", i: "unsigned int", x: "double") -> "double":
        r"""


        Parameters
        ----------
        * `l` :  
            level of basis function  
        * `i` :  
            index of basis function  
        * `x` :  
            evaluation point  

        Returns
        -------
        value of 2nd derivative of modified fundamental spline basis function  

        """
        return _pysgpp_swig.SFundamentalSplineModifiedBase_evalDxDx(self, l, i, x)

# Register SFundamentalSplineModifiedBase in _pysgpp_swig:
_pysgpp_swig.SFundamentalSplineModifiedBase_swigregister(SFundamentalSplineModifiedBase)

class SWeaklyFundamentalSplineBase(SBasis):
    r"""


    weakly fundamental spline basis.  

    C++ includes: WeaklyFundamentalSplineBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `WeaklyFundamentalSplineBasis()`  

            Default constructor.  

        * `WeaklyFundamentalSplineBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                Spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SWeaklyFundamentalSplineBase_swiginit(self, _pysgpp_swig.new_SWeaklyFundamentalSplineBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SWeaklyFundamentalSplineBase

# Register SWeaklyFundamentalSplineBase in _pysgpp_swig:
_pysgpp_swig.SWeaklyFundamentalSplineBase_swigregister(SWeaklyFundamentalSplineBase)

class SWeaklyFundamentalSplineBaseDeriv1(SBasis):
    r"""


    weakly fundamental spline basis (1st derivative).  

    C++ includes: WeaklyFundamentalSplineBasisDeriv1.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `WeaklyFundamentalSplineBasisDeriv1()`  

            Default constructor.  

        * `WeaklyFundamentalSplineBasisDeriv1(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                Spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SWeaklyFundamentalSplineBaseDeriv1_swiginit(self, _pysgpp_swig.new_SWeaklyFundamentalSplineBaseDeriv1(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SWeaklyFundamentalSplineBaseDeriv1

# Register SWeaklyFundamentalSplineBaseDeriv1 in _pysgpp_swig:
_pysgpp_swig.SWeaklyFundamentalSplineBaseDeriv1_swigregister(SWeaklyFundamentalSplineBaseDeriv1)

class SWeaklyFundamentalSplineBaseDeriv2(SBasis):
    r"""


    weakly fundamental spline basis (2nd derivative).  

    C++ includes: WeaklyFundamentalSplineBasisDeriv2.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `WeaklyFundamentalSplineBasisDeriv2()`  

            Default constructor.  

        * `WeaklyFundamentalSplineBasisDeriv2(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                Spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SWeaklyFundamentalSplineBaseDeriv2_swiginit(self, _pysgpp_swig.new_SWeaklyFundamentalSplineBaseDeriv2(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SWeaklyFundamentalSplineBaseDeriv2

# Register SWeaklyFundamentalSplineBaseDeriv2 in _pysgpp_swig:
_pysgpp_swig.SWeaklyFundamentalSplineBaseDeriv2_swigregister(SWeaklyFundamentalSplineBaseDeriv2)

class SWeaklyFundamentalNakSplineBase(SBasis):
    r"""


    weakly fundamental not-a-knot spline basis.  

    C++ includes: WeaklyFundamentalNakSplineBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `WeaklyFundamentalNakSplineBasis()`  

            Default constructor.  

        * `WeaklyFundamentalNakSplineBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                Spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SWeaklyFundamentalNakSplineBase_swiginit(self, _pysgpp_swig.new_SWeaklyFundamentalNakSplineBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SWeaklyFundamentalNakSplineBase

# Register SWeaklyFundamentalNakSplineBase in _pysgpp_swig:
_pysgpp_swig.SWeaklyFundamentalNakSplineBase_swigregister(SWeaklyFundamentalNakSplineBase)

class SWeaklyFundamentalNakSplineBaseDeriv1(SBasis):
    r"""


    weakly fundamental not-a-knot spline basis (1st derivative).  

    C++ includes: WeaklyFundamentalNakSplineBasisDeriv1.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `WeaklyFundamentalNakSplineBasisDeriv1()`  

            Default constructor.  

        * `WeaklyFundamentalNakSplineBasisDeriv1(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                Spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SWeaklyFundamentalNakSplineBaseDeriv1_swiginit(self, _pysgpp_swig.new_SWeaklyFundamentalNakSplineBaseDeriv1(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SWeaklyFundamentalNakSplineBaseDeriv1

# Register SWeaklyFundamentalNakSplineBaseDeriv1 in _pysgpp_swig:
_pysgpp_swig.SWeaklyFundamentalNakSplineBaseDeriv1_swigregister(SWeaklyFundamentalNakSplineBaseDeriv1)

class SWeaklyFundamentalNakSplineBaseDeriv2(SBasis):
    r"""


    weakly fundamental not-a-knot spline basis (2nd derivative).  

    C++ includes: WeaklyFundamentalNakSplineBasisDeriv2.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `WeaklyFundamentalNakSplineBasisDeriv2()`  

            Default constructor.  

        * `WeaklyFundamentalNakSplineBasisDeriv2(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                Spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SWeaklyFundamentalNakSplineBaseDeriv2_swiginit(self, _pysgpp_swig.new_SWeaklyFundamentalNakSplineBaseDeriv2(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SWeaklyFundamentalNakSplineBaseDeriv2

# Register SWeaklyFundamentalNakSplineBaseDeriv2 in _pysgpp_swig:
_pysgpp_swig.SWeaklyFundamentalNakSplineBaseDeriv2_swigregister(SWeaklyFundamentalNakSplineBaseDeriv2)

class SNaturalBsplineBase(SBasis):
    r"""


    B-spline basis with natural boundary conditions.  

    C++ includes: NaturalBsplineBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `NaturalBsplineBasis()`  

            Default constructor.  

        * `NaturalBsplineBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SNaturalBsplineBase_swiginit(self, _pysgpp_swig.new_SNaturalBsplineBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SNaturalBsplineBase

# Register SNaturalBsplineBase in _pysgpp_swig:
_pysgpp_swig.SNaturalBsplineBase_swigregister(SNaturalBsplineBase)

class SNakBsplineBase(SBasis):
    r"""


    Not-a-knot B-spline basis.  

    C++ includes: NakBsplineBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `NakBsplineBasis()`  

            Default constructor.  

        * `NakBsplineBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SNakBsplineBase_swiginit(self, _pysgpp_swig.new_SNakBsplineBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SNakBsplineBase

# Register SNakBsplineBase in _pysgpp_swig:
_pysgpp_swig.SNakBsplineBase_swigregister(SNakBsplineBase)

class SNakBsplineBaseDeriv1(SBasis):
    r"""


    Not-a-knot B-spline basis.  

    C++ includes: NakBsplineBasisDeriv1.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `NakBsplineBasisDeriv1()`  

            Default constructor.  

        * `NakBsplineBasisDeriv1(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SNakBsplineBaseDeriv1_swiginit(self, _pysgpp_swig.new_SNakBsplineBaseDeriv1(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SNakBsplineBaseDeriv1

# Register SNakBsplineBaseDeriv1 in _pysgpp_swig:
_pysgpp_swig.SNakBsplineBaseDeriv1_swigregister(SNakBsplineBaseDeriv1)

class SNakBsplineBaseDeriv2(SBasis):
    r"""


    Not-a-knot B-spline basis.  

    C++ includes: NakBsplineBasisDeriv2.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `NakBsplineBasisDeriv2()`  

            Default constructor.  

        * `NakBsplineBasisDeriv2(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SNakBsplineBaseDeriv2_swiginit(self, _pysgpp_swig.new_SNakBsplineBaseDeriv2(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SNakBsplineBaseDeriv2

# Register SNakBsplineBaseDeriv2 in _pysgpp_swig:
_pysgpp_swig.SNakBsplineBaseDeriv2_swigregister(SNakBsplineBaseDeriv2)

class SNakBsplineModifiedBase(SBasis):
    r"""


    Not-a-knot B-spline basis.  

    C++ includes: NakBsplineModifiedBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `NakBsplineModifiedBasis()`  

            Default constructor.  

        * `NakBsplineModifiedBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SNakBsplineModifiedBase_swiginit(self, _pysgpp_swig.new_SNakBsplineModifiedBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SNakBsplineModifiedBase

# Register SNakBsplineModifiedBase in _pysgpp_swig:
_pysgpp_swig.SNakBsplineModifiedBase_swigregister(SNakBsplineModifiedBase)

class SNakBsplineModifiedBaseDeriv1(SBasis):
    r"""


    Not-a-knot B-spline basis.  

    C++ includes: NakBsplineModifiedBasisDeriv1.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `NakBsplineModifiedBasisDeriv1()`  

            Default constructor.  

        * `NakBsplineModifiedBasisDeriv1(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SNakBsplineModifiedBaseDeriv1_swiginit(self, _pysgpp_swig.new_SNakBsplineModifiedBaseDeriv1(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SNakBsplineModifiedBaseDeriv1

# Register SNakBsplineModifiedBaseDeriv1 in _pysgpp_swig:
_pysgpp_swig.SNakBsplineModifiedBaseDeriv1_swigregister(SNakBsplineModifiedBaseDeriv1)

class SNakBsplineModifiedBaseDeriv2(SBasis):
    r"""


    Not-a-knot B-spline basis.  

    C++ includes: NakBsplineModifiedBasisDeriv2.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `NakBsplineModifiedBasisDeriv2()`  

            Default constructor.  

        * `NakBsplineModifiedBasisDeriv2(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SNakBsplineModifiedBaseDeriv2_swiginit(self, _pysgpp_swig.new_SNakBsplineModifiedBaseDeriv2(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SNakBsplineModifiedBaseDeriv2

# Register SNakBsplineModifiedBaseDeriv2 in _pysgpp_swig:
_pysgpp_swig.SNakBsplineModifiedBaseDeriv2_swigregister(SNakBsplineModifiedBaseDeriv2)

class SPrewaveletBase(SBasis):
    r"""


    Class representing a prewavelet base.  

    A prewavelet $\psi$ is a combination of 5 normal hat functions $\phi$ with a
    $\left[\frac{1}{10}, -\frac{6}{10}, 1, -\frac{6}{10}, \frac{1}{10}\right]$
    stamp: \[ \psi_{(l,i)} = \frac{1}{10}\phi_{(l,i-2)} -
    \frac{6}{10}\phi_{(l,i-1)} + \phi_{(l,i)} - \frac{6}{10} \phi_{(l,i+1)} +
    \frac{1}{10}\phi_{(l,i+2)} \] Next to the border: \[ \psi_{(l,1)} =
    \frac{9}{10}\phi_{(l,1)} - \frac{6}{10}\phi_{(l,2)} +
    \frac{1}{10}\phi_{(l,3)} \] For level $ l = 1$ the prewavelet and linear
    basis are equivalent. Normal prewavelet base function and a left border
    prewavelet. The
     bold dots indicate the position of other prewavelet basis functions on the same
    level, the thin dots representing grid points missing in the sparse grid on that
    level. Please note that the left and right TWO neighbors are interfering with a
    specific prewavelet base." The prewavelets form a semi-orthogonal basis. That
    means $<\psi_{(i,l)},\psi_{(j,k)}> = 0$ if $l\neq k$. On the same level, the
    prewavelets are not orthogonal. This property will ease the calculation of some
    specific operations, but on the other hand, this advantage is bought with a
    wider support of the ansatzfunctions.  

    C++ includes: PrewaveletBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SPrewaveletBase

    def __init__(self):
        _pysgpp_swig.SPrewaveletBase_swiginit(self, _pysgpp_swig.new_SPrewaveletBase())

# Register SPrewaveletBase in _pysgpp_swig:
_pysgpp_swig.SPrewaveletBase_swigregister(SPrewaveletBase)

class SNakBsplineBoundaryCombigridBase(SBasis):
    r"""


    Hierarchical Not-a-knot B-spline basis.  

    This basis is designed to represent Bspline boundary interpolants from the
    combigrid module. Therefore it has the following unusual choice of basis
    functions: linear and quadratic terms on level 0 constant term on level 1  

    This means that this basis of level 0 cannot represent constant functions! It is
    therefore not suitabe for any application that cannot guarantee the existence of
    level 1 in every dimension  

    A combigrid interpolant which shall be interpolated with this class needs level
    (1,...,1) otherwise the boundary points cannot match  

    C++ includes: NakBsplineBoundaryCombigridBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `NakBsplineBoundaryCombigridBasis()`  

            Default constructor.  

        * `NakBsplineBoundaryCombigridBasis(degree)`  

            Constructor.  

            Parameters:  
            * `degree` :  
                B-spline degree, must be odd (if it's even, degree - 1 is used)  

        """
        _pysgpp_swig.SNakBsplineBoundaryCombigridBase_swiginit(self, _pysgpp_swig.new_SNakBsplineBoundaryCombigridBase(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SNakBsplineBoundaryCombigridBase

# Register SNakBsplineBoundaryCombigridBase in _pysgpp_swig:
_pysgpp_swig.SNakBsplineBoundaryCombigridBase_swigregister(SNakBsplineBoundaryCombigridBase)

class SGetAffectedBasisFunctions(object):
    r"""


    Basic algorithm for getting all affected basis functions.  

    This implicitly assumes a tensor-product approach and local support. No grid
    points on the border are supported.  

    The main idea behind this algorithm is to spend as few function evaluations as
    possible. Assume a regular sparse grid level 3 in two dimensions with the sparse
    grid basis $\Phi:=\{\phi_i(x), i=1,\ldots,N\}$. Then the tableau of
    subspaces looks as follows: Tableau of subspaces for a regular sparse
     grid level 3" You could evaluate the function $ f_N(x) = \sum_{i=1}^N
    \alpha_i \phi_i(x)$ for all basis functions $\phi_i(x)$, multiply them with
    the surplus and add them up. In $d$ dimensions this would lead to $N$
    evaluations of $d$ one-dimensional basis functions each.  

    A better way is to (recursively) look at each subspace, as only one basis
    function per subspace can be non-zero (partially disjunct supports): Traversal
    of
     subspaces for evaluation" This can be done recursively in both the dimension
    and the level. In each subspace the basis function concerned can be identified
    via a few index calculations and evaluated at the given point in the domain.  

    Even better would be to save further function evaluations and to reuse
    intermediate values obtained by the evaluation of one-dimensional basis
    functions, see the following figure. Minimize
     the number of evaluations" width=10cm Descending recursively in the d-th
    dimension, one can propagate the value of the intermediate function evaluation
    for the first d-1 dimensions that have already been looked at.  

    C++ includes: GetAffectedBasisFunctions.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        """
        _pysgpp_swig.SGetAffectedBasisFunctions_swiginit(self, _pysgpp_swig.new_SGetAffectedBasisFunctions(storage))
    __swig_destroy__ = _pysgpp_swig.delete_SGetAffectedBasisFunctions

    def __call__(self, basis: "SLinearBase", point: "DataVector") -> "void":
        return _pysgpp_swig.SGetAffectedBasisFunctions___call__(self, basis, point)

# Register SGetAffectedBasisFunctions in _pysgpp_swig:
_pysgpp_swig.SGetAffectedBasisFunctions_swigregister(SGetAffectedBasisFunctions)

class SAlgorithmEvaluation(object):
    r"""


    Basic algorithm for getting all affected basis functions.  

    This implicitly assumes a tensor-product approach and local support. No grid
    points on the border are supported.  

    The main idea behind this algorithm is to spend as few function evaluations as
    possible. Assume a regular sparse grid level 3 in two dimensions with the sparse
    grid basis $\Phi:=\{\phi_i(x), i=1,\ldots,N\}$. Then the tableau of
    subspaces looks as follows: Tableau of subspaces for a regular sparse grid level
    3
     You could evaluate the function $ f_N(x) = \sum_{i=1}^N \alpha_i \phi_i(x)$
    for all basis functions $\phi_i(x)$, multiply them with the surplus and add
    them up. In $d$ dimensions this would lead to $N$ evaluations of $d$ one-
    dimensional basis functions each.  

    A better way is to (recursively) look at each subspace, as only one basis
    function per subspace can be non-zero (partially disjunct supports): Traversal
    of subspaces for evaluation
     This can be done recursively in both the dimension and the level. In each
    subspace the basis function concerned can be identified via a few index
    calculations and evaluated at the given point in the domain.  

    Even better would be to save further function evaluations and to reuse
    intermediate values obtained by the evaluation of one-dimensional basis
    functions, see the following figure. Minimize the number of evaluations
     Descending recursively in the d-th dimension, one can propagate the value of
    the intermediate function evaluation for the first d-1 dimensions that have
    already been looked at.  

    C++ includes: AlgorithmEvaluation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        """
        _pysgpp_swig.SAlgorithmEvaluation_swiginit(self, _pysgpp_swig.new_SAlgorithmEvaluation(storage))
    __swig_destroy__ = _pysgpp_swig.delete_SAlgorithmEvaluation

    def __call__(self, basis: "SLinearBase", point: "DataVector", alpha: "DataVector") -> "double":
        return _pysgpp_swig.SAlgorithmEvaluation___call__(self, basis, point, alpha)

# Register SAlgorithmEvaluation in _pysgpp_swig:
_pysgpp_swig.SAlgorithmEvaluation_swigregister(SAlgorithmEvaluation)

class SGetAffectedBasisFunctionsBoundaries(object):
    r"""


    Basic algorithm for getting all affected basis functions.  

    This implicitly assumes a tensor-product approach and local support. No grid
    points on the border are supported.  

    The main idea behind this algorithm is to spend as few function evaluations as
    possible. Assume a regular sparse grid level 3 in two dimensions with the sparse
    grid basis $\Phi:=\{\phi_i(x), i=1,\ldots,N\}$. Then the tableau of
    subspaces looks as follows: Tableau of subspaces for a regular sparse
     grid level 3" You could evaluate the function $ f_N(x) = \sum_{i=1}^N
    \alpha_i \phi_i(x)$ for all basis functions $\phi_i(x)$, multiply them with
    the surplus and add them up. In $d$ dimensions this would lead to $N$
    evaluations of $d$ one-dimensional basis functions each.  

    A better way is to (recursively) look at each subspace, as only one basis
    function per subspace can be non-zero (partially disjunct supports): Traversal
    of
     subspaces for evaluation" This can be done recursively in both the dimension
    and the level. In each subspace the basis function concerned can be identified
    via a few index calculations and evaluated at the given point in the domain.  

    Even better would be to save further function evaluations and to reuse
    intermediate values obtained by the evaluation of one-dimensional basis
    functions, see the following figure. Minimize
     the number of evaluations" width=10cm Descending recursively in the d-th
    dimension, one can propagate the value of the intermediate function evaluation
    for the first d-1 dimensions that have already been looked at.  

    C++ includes: GetAffectedBasisFunctions.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        """
        _pysgpp_swig.SGetAffectedBasisFunctionsBoundaries_swiginit(self, _pysgpp_swig.new_SGetAffectedBasisFunctionsBoundaries(storage))
    __swig_destroy__ = _pysgpp_swig.delete_SGetAffectedBasisFunctionsBoundaries

    def __call__(self, basis: "SLinearBoundaryBase", point: "DataVector") -> "void":
        return _pysgpp_swig.SGetAffectedBasisFunctionsBoundaries___call__(self, basis, point)

# Register SGetAffectedBasisFunctionsBoundaries in _pysgpp_swig:
_pysgpp_swig.SGetAffectedBasisFunctionsBoundaries_swigregister(SGetAffectedBasisFunctionsBoundaries)

class SGetAffectedBasisFunctionsLinearStretchedBoundaries(object):
    r"""


    Basic algorithm for getting all affected basis functions.  

    This implicitly assumes a tensor-product approach and local support. No grid
    points on the border are supported.  

    The main idea behind this algorithm is to spend as few function evaluations as
    possible. Assume a regular sparse grid level 3 in two dimensions with the sparse
    grid basis $\Phi:=\{\phi_i(x), i=1,\ldots,N\}$. Then the tableau of
    subspaces looks as follows: Tableau of subspaces for a regular sparse
     grid level 3" You could evaluate the function $ f_N(x) = \sum_{i=1}^N
    \alpha_i \phi_i(x)$ for all basis functions $\phi_i(x)$, multiply them with
    the surplus and add them up. In $d$ dimensions this would lead to $N$
    evaluations of $d$ one-dimensional basis functions each.  

    A better way is to (recursively) look at each subspace, as only one basis
    function per subspace can be non-zero (partially disjunct supports): Traversal
    of
     subspaces for evaluation" This can be done recursively in both the dimension
    and the level. In each subspace the basis function concerned can be identified
    via a few index calculations and evaluated at the given point in the domain.  

    Even better would be to save further function evaluations and to reuse
    intermediate values obtained by the evaluation of one-dimensional basis
    functions, see the following figure. Minimize
     the number of evaluations" width=10cm Descending recursively in the d-th
    dimension, one can propagate the value of the intermediate function evaluation
    for the first d-1 dimensions that have already been looked at.  

    C++ includes: GetAffectedBasisFunctions.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, storage: "HashGridStorage"):
        r"""


        """
        _pysgpp_swig.SGetAffectedBasisFunctionsLinearStretchedBoundaries_swiginit(self, _pysgpp_swig.new_SGetAffectedBasisFunctionsLinearStretchedBoundaries(storage))
    __swig_destroy__ = _pysgpp_swig.delete_SGetAffectedBasisFunctionsLinearStretchedBoundaries

    def __call__(self, basis: "SLinearStretchedBoundaryBase", point: "DataVector") -> "void":
        return _pysgpp_swig.SGetAffectedBasisFunctionsLinearStretchedBoundaries___call__(self, basis, point)

# Register SGetAffectedBasisFunctionsLinearStretchedBoundaries in _pysgpp_swig:
_pysgpp_swig.SGetAffectedBasisFunctionsLinearStretchedBoundaries_swigregister(SGetAffectedBasisFunctionsLinearStretchedBoundaries)

class BoundingBox1DVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.BoundingBox1DVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.BoundingBox1DVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.BoundingBox1DVector___bool__(self)

    def __len__(self) -> "std::vector< sgpp::base::BoundingBox1D >::size_type":
        return _pysgpp_swig.BoundingBox1DVector___len__(self)

    def __getslice__(self, i: "std::vector< sgpp::base::BoundingBox1D >::difference_type", j: "std::vector< sgpp::base::BoundingBox1D >::difference_type") -> "std::vector< sgpp::base::BoundingBox1D,std::allocator< sgpp::base::BoundingBox1D > > *":
        return _pysgpp_swig.BoundingBox1DVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.BoundingBox1DVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< sgpp::base::BoundingBox1D >::difference_type", j: "std::vector< sgpp::base::BoundingBox1D >::difference_type") -> "void":
        return _pysgpp_swig.BoundingBox1DVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.BoundingBox1DVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< sgpp::base::BoundingBox1D >::value_type const &":
        return _pysgpp_swig.BoundingBox1DVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.BoundingBox1DVector___setitem__(self, *args)

    def pop(self) -> "std::vector< sgpp::base::BoundingBox1D >::value_type":
        return _pysgpp_swig.BoundingBox1DVector_pop(self)

    def append(self, x: "BoundingBox1D") -> "void":
        return _pysgpp_swig.BoundingBox1DVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.BoundingBox1DVector_empty(self)

    def size(self) -> "std::vector< sgpp::base::BoundingBox1D >::size_type":
        return _pysgpp_swig.BoundingBox1DVector_size(self)

    def swap(self, v: "BoundingBox1DVector") -> "void":
        return _pysgpp_swig.BoundingBox1DVector_swap(self, v)

    def begin(self) -> "std::vector< sgpp::base::BoundingBox1D >::iterator":
        return _pysgpp_swig.BoundingBox1DVector_begin(self)

    def end(self) -> "std::vector< sgpp::base::BoundingBox1D >::iterator":
        return _pysgpp_swig.BoundingBox1DVector_end(self)

    def rbegin(self) -> "std::vector< sgpp::base::BoundingBox1D >::reverse_iterator":
        return _pysgpp_swig.BoundingBox1DVector_rbegin(self)

    def rend(self) -> "std::vector< sgpp::base::BoundingBox1D >::reverse_iterator":
        return _pysgpp_swig.BoundingBox1DVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.BoundingBox1DVector_clear(self)

    def get_allocator(self) -> "std::vector< sgpp::base::BoundingBox1D >::allocator_type":
        return _pysgpp_swig.BoundingBox1DVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.BoundingBox1DVector_pop_back(self)

    def erase(self, *args) -> "std::vector< sgpp::base::BoundingBox1D >::iterator":
        return _pysgpp_swig.BoundingBox1DVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.BoundingBox1DVector_swiginit(self, _pysgpp_swig.new_BoundingBox1DVector(*args))

    def push_back(self, x: "BoundingBox1D") -> "void":
        return _pysgpp_swig.BoundingBox1DVector_push_back(self, x)

    def front(self) -> "std::vector< sgpp::base::BoundingBox1D >::value_type const &":
        return _pysgpp_swig.BoundingBox1DVector_front(self)

    def back(self) -> "std::vector< sgpp::base::BoundingBox1D >::value_type const &":
        return _pysgpp_swig.BoundingBox1DVector_back(self)

    def assign(self, n: "std::vector< sgpp::base::BoundingBox1D >::size_type", x: "BoundingBox1D") -> "void":
        return _pysgpp_swig.BoundingBox1DVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.BoundingBox1DVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.BoundingBox1DVector_insert(self, *args)

    def reserve(self, n: "std::vector< sgpp::base::BoundingBox1D >::size_type") -> "void":
        return _pysgpp_swig.BoundingBox1DVector_reserve(self, n)

    def capacity(self) -> "std::vector< sgpp::base::BoundingBox1D >::size_type":
        return _pysgpp_swig.BoundingBox1DVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_BoundingBox1DVector

# Register BoundingBox1DVector in _pysgpp_swig:
_pysgpp_swig.BoundingBox1DVector_swigregister(BoundingBox1DVector)

class Stretching1DVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.Stretching1DVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.Stretching1DVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.Stretching1DVector___bool__(self)

    def __len__(self) -> "std::vector< sgpp::base::Stretching1D >::size_type":
        return _pysgpp_swig.Stretching1DVector___len__(self)

    def __getslice__(self, i: "std::vector< sgpp::base::Stretching1D >::difference_type", j: "std::vector< sgpp::base::Stretching1D >::difference_type") -> "std::vector< sgpp::base::Stretching1D,std::allocator< sgpp::base::Stretching1D > > *":
        return _pysgpp_swig.Stretching1DVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.Stretching1DVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< sgpp::base::Stretching1D >::difference_type", j: "std::vector< sgpp::base::Stretching1D >::difference_type") -> "void":
        return _pysgpp_swig.Stretching1DVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.Stretching1DVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< sgpp::base::Stretching1D >::value_type const &":
        return _pysgpp_swig.Stretching1DVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.Stretching1DVector___setitem__(self, *args)

    def pop(self) -> "std::vector< sgpp::base::Stretching1D >::value_type":
        return _pysgpp_swig.Stretching1DVector_pop(self)

    def append(self, x: "Stretching1D") -> "void":
        return _pysgpp_swig.Stretching1DVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.Stretching1DVector_empty(self)

    def size(self) -> "std::vector< sgpp::base::Stretching1D >::size_type":
        return _pysgpp_swig.Stretching1DVector_size(self)

    def swap(self, v: "Stretching1DVector") -> "void":
        return _pysgpp_swig.Stretching1DVector_swap(self, v)

    def begin(self) -> "std::vector< sgpp::base::Stretching1D >::iterator":
        return _pysgpp_swig.Stretching1DVector_begin(self)

    def end(self) -> "std::vector< sgpp::base::Stretching1D >::iterator":
        return _pysgpp_swig.Stretching1DVector_end(self)

    def rbegin(self) -> "std::vector< sgpp::base::Stretching1D >::reverse_iterator":
        return _pysgpp_swig.Stretching1DVector_rbegin(self)

    def rend(self) -> "std::vector< sgpp::base::Stretching1D >::reverse_iterator":
        return _pysgpp_swig.Stretching1DVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.Stretching1DVector_clear(self)

    def get_allocator(self) -> "std::vector< sgpp::base::Stretching1D >::allocator_type":
        return _pysgpp_swig.Stretching1DVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.Stretching1DVector_pop_back(self)

    def erase(self, *args) -> "std::vector< sgpp::base::Stretching1D >::iterator":
        return _pysgpp_swig.Stretching1DVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.Stretching1DVector_swiginit(self, _pysgpp_swig.new_Stretching1DVector(*args))

    def push_back(self, x: "Stretching1D") -> "void":
        return _pysgpp_swig.Stretching1DVector_push_back(self, x)

    def front(self) -> "std::vector< sgpp::base::Stretching1D >::value_type const &":
        return _pysgpp_swig.Stretching1DVector_front(self)

    def back(self) -> "std::vector< sgpp::base::Stretching1D >::value_type const &":
        return _pysgpp_swig.Stretching1DVector_back(self)

    def assign(self, n: "std::vector< sgpp::base::Stretching1D >::size_type", x: "Stretching1D") -> "void":
        return _pysgpp_swig.Stretching1DVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.Stretching1DVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.Stretching1DVector_insert(self, *args)

    def reserve(self, n: "std::vector< sgpp::base::Stretching1D >::size_type") -> "void":
        return _pysgpp_swig.Stretching1DVector_reserve(self, n)

    def capacity(self) -> "std::vector< sgpp::base::Stretching1D >::size_type":
        return _pysgpp_swig.Stretching1DVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_Stretching1DVector

# Register Stretching1DVector in _pysgpp_swig:
_pysgpp_swig.Stretching1DVector_swigregister(Stretching1DVector)

class ScalarFunction(object):
    r"""

    `ScalarFunction(d)`  

    Abstract base class for scalar-valued functions $f\colon [0, 1]^d \to
    \mathbb{R}$ (e.g., objective functions in optimization).  

    Constructors
    ------------
    * `ScalarFunction(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: ScalarFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        if self.__class__ == ScalarFunction:
            _self = None
        else:
            _self = self
        _pysgpp_swig.ScalarFunction_swiginit(self, _pysgpp_swig.new_ScalarFunction(_self, d))
    __swig_destroy__ = _pysgpp_swig.delete_ScalarFunction

    def eval(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `eval(x, value)`  

            Convenience method for calculating $f(\vec{x})$ for multiple $\vec{x}$.  

            Parameters:  
            * `x` :  
                matrix $\vec{x} \in [0, 1]^{N \times d}$ of evaluation points (row-
                wise)  
            * `value` :  
                $(f(\vec{x}_k))_k$ where $\vec{x}_k$ is the $k$-th row of $x$  

        * `eval(x) -> double`  

            Pure virtual method for calculating $f(\vec{x})$.  

            Parameters:  
            * `x` :  
                evaluation point $\vec{x} \in [0, 1]^d$  

            Returns:
            $f(\vec{x})$  

        """
        return _pysgpp_swig.ScalarFunction_eval(self, *args)

    def getNumberOfParameters(self) -> "size_t":
        r"""


        Returns
        -------
        dimension $d$ of the domain  

        """
        return _pysgpp_swig.ScalarFunction_getNumberOfParameters(self)

    def clone(self, clone: "std::unique_ptr< sgpp::base::ScalarFunction > &") -> "void":
        r"""


        Pure virtual method for cloning the function.  

        It should generate a pointer to the cloned object and it's used for parallel
        computations (the eval() method might not be thread-safe).  

        Parameters
        ----------
        * `clone` :  
            pointer to cloned object  

        """
        return _pysgpp_swig.ScalarFunction_clone(self, clone)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_ScalarFunction(self)
        return weakref.proxy(self)

# Register ScalarFunction in _pysgpp_swig:
_pysgpp_swig.ScalarFunction_swigregister(ScalarFunction)

class ScalarFunctionGradient(object):
    r"""

    `ScalarFunctionGradient(d)`  

    Abstract base class for scalar-valued functions $f\colon [0, 1]^d \to
    \mathbb{R}$ together with their gradients $\nabla f\colon [0, 1]^d \to
    \mathbb{R}^d$ (e.g., gradients of objective functions in optimization).  

    Constructors
    ------------
    * `ScalarFunctionGradient(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: ScalarFunctionGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        if self.__class__ == ScalarFunctionGradient:
            _self = None
        else:
            _self = self
        _pysgpp_swig.ScalarFunctionGradient_swiginit(self, _pysgpp_swig.new_ScalarFunctionGradient(_self, d))
    __swig_destroy__ = _pysgpp_swig.delete_ScalarFunctionGradient

    def eval(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `eval(x, value, gradient)`  

            Convenience method for calculating $f(\vec{x})$ together with $\nabla
            f(\vec{x})$ for multiple $\vec{x}$.  

            Parameters:  
            * `x` :  
                matrix $\vec{x} \in [0, 1]^{N \times d}$ of evaluation points (row-
                wise)  
            * `value` :  
                vector of size $N$, where the $k$-th entry is $f(\vec{x}_k)$ (where
                $\vec{x}_k$ is the $k$-th row of $x$)  
            * `gradient` :  
                matrix of size $N \times d$ where the $k$-th row is $\nabla
                f(\vec{x}_k)$  

        * `eval(x, gradient) -> double`  

            Pure virtual method for calculating $f(\vec{x})$ together with $\nabla
            f(\vec{x})$.  

            Parameters:  
            * `x` :  
                evaluation point $\vec{x} \in [0, 1]^d$  
            * `gradient` :  
                gradient $\nabla f(\vec{x}) \in \mathbb{R}^d$  

            Returns:
            $f(\vec{x})$  

        """
        return _pysgpp_swig.ScalarFunctionGradient_eval(self, *args)

    def getNumberOfParameters(self) -> "size_t":
        r"""


        Returns
        -------
        dimension $d$ of the domain  

        """
        return _pysgpp_swig.ScalarFunctionGradient_getNumberOfParameters(self)

    def clone(self, clone: "std::unique_ptr< sgpp::base::ScalarFunctionGradient > &") -> "void":
        r"""


        Pure virtual method for cloning the gradient.  

        It should generate a pointer to the cloned object and it's used for parallel
        computations (the eval() method might not be thread-safe).  

        Parameters
        ----------
        * `clone` :  
            pointer to cloned object  

        """
        return _pysgpp_swig.ScalarFunctionGradient_clone(self, clone)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_ScalarFunctionGradient(self)
        return weakref.proxy(self)

# Register ScalarFunctionGradient in _pysgpp_swig:
_pysgpp_swig.ScalarFunctionGradient_swigregister(ScalarFunctionGradient)

class ScalarFunctionHessian(object):
    r"""

    `ScalarFunctionHessian(d)`  

    Abstract base class for scalar-valued functions $f\colon [0, 1]^d \to
    \mathbb{R}$ together with their gradients $\nabla f\colon [0, 1]^d \to
    \mathbb{R}^d$ and Hessians $H_f\colon [0, 1]^d \to \mathbb{R}^{d \times d}$
    (e.g., Hessians of objective functions in optimization).  

    Constructors
    ------------
    * `ScalarFunctionHessian(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: ScalarFunctionHessian.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        if self.__class__ == ScalarFunctionHessian:
            _self = None
        else:
            _self = self
        _pysgpp_swig.ScalarFunctionHessian_swiginit(self, _pysgpp_swig.new_ScalarFunctionHessian(_self, d))
    __swig_destroy__ = _pysgpp_swig.delete_ScalarFunctionHessian

    def eval(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `eval(x, value, gradient, hessian)`  

            Convenience method for calculating $f(\vec{x})$ together with $\nabla
            f(\vec{x})$ and $H_f(\vec{x}) \in \mathbb{R}^{d \times d}$ for multiple
            $\vec{x}$.  

            Parameters:  
            * `x` :  
                matrix $\vec{x} \in [0, 1]^{N \times d}$ of evaluation points (row-
                wise)  
            * `value` :  
                vector of size $N$, where the $k$-th entry is $f(\vec{x}_k)$ (where
                $\vec{x}_k$ is the $k$-th row of $x$)  
            * `gradient` :  
                matrix of size $N \times d$ where the $k$-th row is $\nabla
                f(\vec{x}_k)$  
            * `hessian` :  
                $N$-vector of Hessians $\nabla^2 f(\vec{x}_k) \in \mathbb{R}^{d
                \times d}$  

        * `eval(x, gradient, hessian) -> double`  

            Pure virtual method for calculating $f(\vec{x})$ together with $\nabla
            f(\vec{x})$ and $H_f(\vec{x}) \in \mathbb{R}^{d \times d}$.  

            Parameters:  
            * `x` :  
                evaluation point $\vec{x} \in [0, 1]^d$  
            * `gradient` :  
                gradient $\nabla f(\vec{x}) \in \mathbb{R}^d$  
            * `hessian` :  
                Hessian matrix $H_f(\vec{x}) \in \mathbb{R}^{d \times d}$  

            Returns:
            $f(\vec{x})$  

        """
        return _pysgpp_swig.ScalarFunctionHessian_eval(self, *args)

    def getNumberOfParameters(self) -> "size_t":
        r"""


        Returns
        -------
        dimension $d$ of the domain  

        """
        return _pysgpp_swig.ScalarFunctionHessian_getNumberOfParameters(self)

    def clone(self, clone: "std::unique_ptr< sgpp::base::ScalarFunctionHessian > &") -> "void":
        r"""


        Pure virtual method for cloning the Hessian.  

        It should generate a pointer to the cloned object and it's used for parallel
        computations (the eval() method might not be thread-safe).  

        Parameters
        ----------
        * `clone` :  
            pointer to cloned object  

        """
        return _pysgpp_swig.ScalarFunctionHessian_clone(self, clone)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_ScalarFunctionHessian(self)
        return weakref.proxy(self)

# Register ScalarFunctionHessian in _pysgpp_swig:
_pysgpp_swig.ScalarFunctionHessian_swigregister(ScalarFunctionHessian)

class InterpolantScalarFunction(ScalarFunction):
    r"""

    `InterpolantScalarFunction(grid, alpha)`  

    Sparse grid interpolant of a scalar-valued function.  

    More generally, the function can be any linear combination $f\colon [0, 1]^d
    \to \mathbb{R}$, $f(\vec{x}) = \sum_{k=1}^N \alpha_k \varphi_k(\vec{x})$
    of the basis functions $\varphi_k = \varphi_{\vec{\ell}_k,\vec{i}_k}$ of a
    sparse grid with grid points $\vec{x}_k =
    \vec{x}_{\vec{\ell}_k,\vec{i}_k}$. But most often, the function (e.g., its
    coefficients) is constructed as an interpolant at the grid points for some
    function values.  

    Constructors
    ------------
    * `InterpolantScalarFunction(grid, alpha)`  

        Constructor.  

        Do not destruct the grid before the InterpolantScalarFunction object!  

        Parameters:  
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient vector  

    C++ includes: InterpolantScalarFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", alpha: "DataVector"):
        r"""


        Constructor.  

        Do not destruct the grid before the InterpolantScalarFunction object!  

        Parameters
        ----------
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient vector  

        """
        _pysgpp_swig.InterpolantScalarFunction_swiginit(self, _pysgpp_swig.new_InterpolantScalarFunction(grid, alpha))
    __swig_destroy__ = _pysgpp_swig.delete_InterpolantScalarFunction

    def getAlpha(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        coefficient vector  

        """
        return _pysgpp_swig.InterpolantScalarFunction_getAlpha(self)

    def setAlpha(self, alpha: "DataVector") -> "void":
        r"""


        Parameters
        ----------
        * `alpha` :  
            coefficient vector  

        """
        return _pysgpp_swig.InterpolantScalarFunction_setAlpha(self, alpha)

# Register InterpolantScalarFunction in _pysgpp_swig:
_pysgpp_swig.InterpolantScalarFunction_swigregister(InterpolantScalarFunction)

class InterpolantScalarFunctionGradient(ScalarFunctionGradient):
    r"""

    `InterpolantScalarFunctionGradient(grid, alpha)`  

    Sparse grid interpolant gradient of a scalar-valued function.  

    See also: InterpolantScalarFunction  

    Constructors
    ------------
    * `InterpolantScalarFunctionGradient(grid, alpha)`  

        Constructor.  

        Do not destruct the grid before the InterpolantScalarFunctionGradient
        object!  

        Parameters:  
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient vector  

    C++ includes: InterpolantScalarFunctionGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", alpha: "DataVector"):
        r"""


        Constructor.  

        Do not destruct the grid before the InterpolantScalarFunctionGradient object!  

        Parameters
        ----------
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient vector  

        """
        _pysgpp_swig.InterpolantScalarFunctionGradient_swiginit(self, _pysgpp_swig.new_InterpolantScalarFunctionGradient(grid, alpha))
    __swig_destroy__ = _pysgpp_swig.delete_InterpolantScalarFunctionGradient

    def getAlpha(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        coefficient vector  

        """
        return _pysgpp_swig.InterpolantScalarFunctionGradient_getAlpha(self)

    def setAlpha(self, alpha: "DataVector") -> "void":
        r"""


        Parameters
        ----------
        * `alpha` :  
            coefficient vector  

        """
        return _pysgpp_swig.InterpolantScalarFunctionGradient_setAlpha(self, alpha)

# Register InterpolantScalarFunctionGradient in _pysgpp_swig:
_pysgpp_swig.InterpolantScalarFunctionGradient_swigregister(InterpolantScalarFunctionGradient)

class InterpolantScalarFunctionHessian(ScalarFunctionHessian):
    r"""

    `InterpolantScalarFunctionHessian(grid, alpha)`  

    Sparse grid interpolant Hessian of a scalar-valued function.  

    See also: InterpolantScalarFunction  

    Constructors
    ------------
    * `InterpolantScalarFunctionHessian(grid, alpha)`  

        Constructor.  

        Do not destruct the grid before the InterpolantScalarFunctionHessian object!  

        Parameters:  
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient vector  

    C++ includes: InterpolantScalarFunctionHessian.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", alpha: "DataVector"):
        r"""


        Constructor.  

        Do not destruct the grid before the InterpolantScalarFunctionHessian object!  

        Parameters
        ----------
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient vector  

        """
        _pysgpp_swig.InterpolantScalarFunctionHessian_swiginit(self, _pysgpp_swig.new_InterpolantScalarFunctionHessian(grid, alpha))
    __swig_destroy__ = _pysgpp_swig.delete_InterpolantScalarFunctionHessian

    def getAlpha(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        coefficient vector  

        """
        return _pysgpp_swig.InterpolantScalarFunctionHessian_getAlpha(self)

    def setAlpha(self, alpha: "DataVector") -> "void":
        r"""


        Parameters
        ----------
        * `alpha` :  
            coefficient vector  

        """
        return _pysgpp_swig.InterpolantScalarFunctionHessian_setAlpha(self, alpha)

# Register InterpolantScalarFunctionHessian in _pysgpp_swig:
_pysgpp_swig.InterpolantScalarFunctionHessian_swigregister(InterpolantScalarFunctionHessian)

class VectorFunction(object):
    r"""

    `VectorFunction(d, m)`  

    Abstract base class for vector-valued functions $g\colon [0, 1]^d \to
    \mathbb{R}^m$ (e.g., equality/inequality constraints $g(\vec{x}) \le
    \vec{0}$ or $g(\vec{x}) = \vec{0}$ in optimization).  

    Constructors
    ------------
    * `VectorFunction(d, m)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  

    C++ includes: VectorFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", m: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  

        """
        if self.__class__ == VectorFunction:
            _self = None
        else:
            _self = self
        _pysgpp_swig.VectorFunction_swiginit(self, _pysgpp_swig.new_VectorFunction(_self, d, m))
    __swig_destroy__ = _pysgpp_swig.delete_VectorFunction

    def eval(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `eval(x, value)`  

            Convenience method for calculating $g(\vec{x})$ for multiple $\vec{x}$.  

            Parameters:  
            * `x` :  
                matrix $\vec{x} \in [0, 1]^{N \times d}$ of evaluation points (row-
                wise)  
            * `value` :  
                matrix of size $N \times m$ where the $k$-th row is $g(\vec{x}_k)$
                (where $\vec{x}_k$ is the $k$-th row of $x$)  

        * `eval(x, value)`  

            Pure virtual method for calculating $g(\vec{x})$.  

            Parameters:  
            * `x` :  
                evaluation point $\vec{x} \in [0, 1]^d$  
            * `value` :  
                $g(\vec{x})$  

        """
        return _pysgpp_swig.VectorFunction_eval(self, *args)

    def getNumberOfParameters(self) -> "size_t":
        r"""


        Returns
        -------
        dimension $d$ of the domain  

        """
        return _pysgpp_swig.VectorFunction_getNumberOfParameters(self)

    def getNumberOfComponents(self) -> "size_t":
        r"""


        Returns
        -------
        number $m$ of components  

        """
        return _pysgpp_swig.VectorFunction_getNumberOfComponents(self)

    def clone(self, clone: "std::unique_ptr< sgpp::base::VectorFunction > &") -> "void":
        r"""


        Pure virtual method for cloning the function.  

        It should generate a pointer to the cloned object and it's used for parallel
        computations (the eval() method might not be thread-safe).  

        Parameters
        ----------
        * `clone` :  
            pointer to cloned object  

        """
        return _pysgpp_swig.VectorFunction_clone(self, clone)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_VectorFunction(self)
        return weakref.proxy(self)

# Register VectorFunction in _pysgpp_swig:
_pysgpp_swig.VectorFunction_swigregister(VectorFunction)

class VectorFunctionGradient(object):
    r"""

    `VectorFunctionGradient(d, m)`  

    Abstract base class for vector-valued functions $g\colon [0, 1]^d \to
    \mathbb{R}^m$ together with their Jacobians $\nabla g\colon [0, 1]^d \to
    \mathbb{R}^{m \times d}$, i.e.  

    $(\nabla g)_{i,t} = \frac{\partial}{\partial x_t} g_i$ with $g =
    (g_i)_{i=1}^m$ (e.g., equality/inequality constraints $g(\vec{x}) \le
    \vec{0}$ or $g(\vec{x}) = \vec{0}$ in optimization).  

    Constructors
    ------------
    * `VectorFunctionGradient(d, m)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  

    C++ includes: VectorFunctionGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", m: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  

        """
        if self.__class__ == VectorFunctionGradient:
            _self = None
        else:
            _self = self
        _pysgpp_swig.VectorFunctionGradient_swiginit(self, _pysgpp_swig.new_VectorFunctionGradient(_self, d, m))
    __swig_destroy__ = _pysgpp_swig.delete_VectorFunctionGradient

    def eval(self, x: "DataVector", value: "DataVector", gradient: "DataMatrix") -> "void":
        r"""


        Pure virtual method for calculating $g(\vec{x})$ together with $\nabla
        g(\vec{x})$.  

        Parameters
        ----------
        * `x` :  
            evaluation point $\vec{x} \in [0, 1]^d$  
        * `value` :  
            $g(\vec{x})$  
        * `gradient` :  
            gradient $\nabla g(\vec{x}) \in \mathbb{R}^{m \times d}$  

        """
        return _pysgpp_swig.VectorFunctionGradient_eval(self, x, value, gradient)

    def getNumberOfParameters(self) -> "size_t":
        r"""


        Returns
        -------
        dimension $d$ of the domain  

        """
        return _pysgpp_swig.VectorFunctionGradient_getNumberOfParameters(self)

    def getNumberOfComponents(self) -> "size_t":
        r"""


        Returns
        -------
        number $m$ of components  

        """
        return _pysgpp_swig.VectorFunctionGradient_getNumberOfComponents(self)

    def clone(self, clone: "std::unique_ptr< sgpp::base::VectorFunctionGradient > &") -> "void":
        r"""


        Pure virtual method for cloning the gradient.  

        It should generate a pointer to the cloned object and it's used for parallel
        computations (the eval() method might not be thread-safe).  

        Parameters
        ----------
        * `clone` :  
            pointer to cloned object  

        """
        return _pysgpp_swig.VectorFunctionGradient_clone(self, clone)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_VectorFunctionGradient(self)
        return weakref.proxy(self)

# Register VectorFunctionGradient in _pysgpp_swig:
_pysgpp_swig.VectorFunctionGradient_swigregister(VectorFunctionGradient)

class VectorFunctionHessian(object):
    r"""

    `VectorFunctionHessian(d, m)`  

    Abstract base class for vector-valued functions $g\colon [0, 1]^d \to
    \mathbb{R}^m$ together with their Jacobians $\nabla g\colon [0, 1]^d \to
    \mathbb{R}^{m \times d}$, i.e.  

    $(\nabla g)_{i,t} = \frac{\partial}{\partial x_t} g_i$ with $g =
    (g_i)_{i=1}^m$, and their Hessians $\nabla g\colon [0, 1]^d \to
    \mathbb{R}^{m \times d \times d}$, i.e. $(\nabla^2 g)_{i,t_1,t_2} =
    \frac{\partial^2}{\partial x_{t_1} x_{t_2}} g_i$ (e.g., equality/inequality
    constraints $g(\vec{x}) \le \vec{0}$ or $g(\vec{x}) = \vec{0}$ in
    optimization).  

    Constructors
    ------------
    * `VectorFunctionHessian(d, m)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  

    C++ includes: VectorFunctionHessian.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", m: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  

        """
        if self.__class__ == VectorFunctionHessian:
            _self = None
        else:
            _self = self
        _pysgpp_swig.VectorFunctionHessian_swiginit(self, _pysgpp_swig.new_VectorFunctionHessian(_self, d, m))
    __swig_destroy__ = _pysgpp_swig.delete_VectorFunctionHessian

    def eval(self, x: "DataVector", value: "DataVector", gradient: "DataMatrix", hessian: "DataMatrixVector") -> "void":
        r"""


        Pure virtual method for calculating $g(\vec{x})$ together with $\nabla
        g(\vec{x})$.  

        Parameters
        ----------
        * `x` :  
            evaluation point $\vec{x} \in [0, 1]^d$  
        * `value` :  
            $g(\vec{x})$  
        * `gradient` :  
            Jacobian $\nabla g(\vec{x}) \in \mathbb{R}^{m \times d}$  
        * `hessian` :  
            $m$-vector of Hessians $\nabla^2 g_i(\vec{x}) \in \mathbb{R}^{d \times
            d}$  

        """
        return _pysgpp_swig.VectorFunctionHessian_eval(self, x, value, gradient, hessian)

    def getNumberOfParameters(self) -> "size_t":
        r"""


        Returns
        -------
        dimension $d$ of the domain  

        """
        return _pysgpp_swig.VectorFunctionHessian_getNumberOfParameters(self)

    def getNumberOfComponents(self) -> "size_t":
        r"""


        Returns
        -------
        number $m$ of components  

        """
        return _pysgpp_swig.VectorFunctionHessian_getNumberOfComponents(self)

    def clone(self, clone: "std::unique_ptr< sgpp::base::VectorFunctionHessian > &") -> "void":
        r"""


        Pure virtual method for cloning the Hessian.  

        It should generate a pointer to the cloned object and it's used for parallel
        computations (the eval() method might not be thread-safe).  

        Parameters
        ----------
        * `clone` :  
            pointer to cloned object  

        """
        return _pysgpp_swig.VectorFunctionHessian_clone(self, clone)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_VectorFunctionHessian(self)
        return weakref.proxy(self)

# Register VectorFunctionHessian in _pysgpp_swig:
_pysgpp_swig.VectorFunctionHessian_swigregister(VectorFunctionHessian)

class InterpolantVectorFunction(VectorFunction):
    r"""

    `InterpolantVectorFunction(grid, alpha)`  

    Sparse grid interpolant of a vector-valued function.  

    More generally, the function can be any linear combination $g\colon [0, 1]^d
    \to \mathbb{R}^m$, $g_j(\vec{x}) = \sum_{k=1}^N \alpha_{k,j}
    \varphi_k(\vec{x})$ of the basis functions $\varphi_k =
    \varphi_{\vec{\ell}_k,\vec{i}_k}$ of a sparse grid with grid points
    $\vec{x}_k = \vec{x}_{\vec{\ell}_k,\vec{i}_k}$. But most often, the
    function (e.g., its coefficients) is constructed as an interpolant at the grid
    points for some function values.  

    Constructors
    ------------
    * `InterpolantVectorFunction(grid, alpha)`  

        Constructor.  

        Do not destruct the grid before the InterpolantVectorFunction object!  

        Parameters:  
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient matrix (j-th column contains hierarchical surplusses
            $\alpha_{\cdot,j}$ of $g_j$)  

    C++ includes: InterpolantVectorFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", alpha: "DataMatrix"):
        r"""


        Constructor.  

        Do not destruct the grid before the InterpolantVectorFunction object!  

        Parameters
        ----------
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient matrix (j-th column contains hierarchical surplusses
            $\alpha_{\cdot,j}$ of $g_j$)  

        """
        _pysgpp_swig.InterpolantVectorFunction_swiginit(self, _pysgpp_swig.new_InterpolantVectorFunction(grid, alpha))
    __swig_destroy__ = _pysgpp_swig.delete_InterpolantVectorFunction

    def getAlpha(self) -> "sgpp::base::DataMatrix const &":
        r"""


        Returns
        -------
        coefficient matrix  

        """
        return _pysgpp_swig.InterpolantVectorFunction_getAlpha(self)

    def setAlpha(self, alpha: "DataMatrix") -> "void":
        r"""


        Parameters
        ----------
        * `alpha` :  
            coefficient matrix  

        """
        return _pysgpp_swig.InterpolantVectorFunction_setAlpha(self, alpha)

# Register InterpolantVectorFunction in _pysgpp_swig:
_pysgpp_swig.InterpolantVectorFunction_swigregister(InterpolantVectorFunction)

class InterpolantVectorFunctionGradient(VectorFunctionGradient):
    r"""

    `InterpolantVectorFunctionGradient(grid, alpha)`  

    Sparse grid interpolant gradient of a vector-valued function.  

    See also: InterpolantVectorFunction  

    Constructors
    ------------
    * `InterpolantVectorFunctionGradient(grid, alpha)`  

        Constructor.  

        Do not destruct the grid before the InterpolantVectorFunctionGradient
        object!  

        Parameters:  
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient matrix (j-th column contains hierarchical surplusses
            $\alpha_{\cdot,j}$ of $g_j$)  

    C++ includes: InterpolantVectorFunctionGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", alpha: "DataMatrix"):
        r"""


        Constructor.  

        Do not destruct the grid before the InterpolantVectorFunctionGradient object!  

        Parameters
        ----------
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient matrix (j-th column contains hierarchical surplusses
            $\alpha_{\cdot,j}$ of $g_j$)  

        """
        _pysgpp_swig.InterpolantVectorFunctionGradient_swiginit(self, _pysgpp_swig.new_InterpolantVectorFunctionGradient(grid, alpha))
    __swig_destroy__ = _pysgpp_swig.delete_InterpolantVectorFunctionGradient

    def getAlpha(self) -> "sgpp::base::DataMatrix const &":
        r"""


        Returns
        -------
        coefficient matrix  

        """
        return _pysgpp_swig.InterpolantVectorFunctionGradient_getAlpha(self)

    def setAlpha(self, alpha: "DataMatrix") -> "void":
        r"""


        Parameters
        ----------
        * `alpha` :  
            coefficient matrix  

        """
        return _pysgpp_swig.InterpolantVectorFunctionGradient_setAlpha(self, alpha)

# Register InterpolantVectorFunctionGradient in _pysgpp_swig:
_pysgpp_swig.InterpolantVectorFunctionGradient_swigregister(InterpolantVectorFunctionGradient)

class InterpolantVectorFunctionHessian(VectorFunctionHessian):
    r"""

    `InterpolantVectorFunctionHessian(grid, alpha)`  

    Sparse grid interpolant Hessian of a vector-valued function.  

    See also: InterpolantVectorFunction  

    Constructors
    ------------
    * `InterpolantVectorFunctionHessian(grid, alpha)`  

        Constructor.  

        Do not destruct the grid before the InterpolantVectorFunctionGradient
        object!  

        Parameters:  
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient matrix (j-th column contains hierarchical surplusses
            $\alpha_{\cdot,j}$ of $g_j$)  

    C++ includes: InterpolantVectorFunctionHessian.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", alpha: "DataMatrix"):
        r"""


        Constructor.  

        Do not destruct the grid before the InterpolantVectorFunctionGradient object!  

        Parameters
        ----------
        * `grid` :  
            sparse grid  
        * `alpha` :  
            coefficient matrix (j-th column contains hierarchical surplusses
            $\alpha_{\cdot,j}$ of $g_j$)  

        """
        _pysgpp_swig.InterpolantVectorFunctionHessian_swiginit(self, _pysgpp_swig.new_InterpolantVectorFunctionHessian(grid, alpha))
    __swig_destroy__ = _pysgpp_swig.delete_InterpolantVectorFunctionHessian

    def getAlpha(self) -> "sgpp::base::DataMatrix const &":
        r"""


        Returns
        -------
        coefficient matrix  

        """
        return _pysgpp_swig.InterpolantVectorFunctionHessian_getAlpha(self)

    def setAlpha(self, alpha: "DataMatrix") -> "void":
        r"""


        Parameters
        ----------
        * `alpha` :  
            coefficient matrix  

        """
        return _pysgpp_swig.InterpolantVectorFunctionHessian_setAlpha(self, alpha)

# Register InterpolantVectorFunctionHessian in _pysgpp_swig:
_pysgpp_swig.InterpolantVectorFunctionHessian_swigregister(InterpolantVectorFunctionHessian)

class ComponentScalarFunction(ScalarFunction):
    r"""

    `ComponentScalarFunction(f, defaultValues=std::vector< double >())`  
    `ComponentScalarFunction(f, k, defaultValues=std::vector< double >())`  

    One component of a vector-valued function.  

    Given a vector-valued $f\colon [0, 1]^d \to \mathbb{R}^m$ and indices $1 \le
    i_1 < \dotsb < i_n \le d$, this class represents a new function $g\colon [0,
    1]^n \to \mathbb{R}$ with $g(y_{i_1}, \dotsc, y_{i_n}) := f_k(y_1, \dotsc,
    y_d)$, where $y_t$ is constant for $t \in \{i_1, \dotsc, i_n\}$.  

    The resulting function $g$ is similar to a "slice plot" of the component $f_k$
    of $f$.  

    Constructors
    ------------
    * `ComponentScalarFunction(f, defaultValues=std::vector< double >())`  

        Constructor.  

        Use it like this: ComponentScalarFunction g(f, {NAN, NAN, 0.42}); where f is
        a scalar-valued function with 3 parameters. This selects the first two
        parameters of f, while constantly using 0.42 for the third parameter.  

        Parameters:  
        * `f` :  
            scalar-valued function  
        * `defaultValues` :  
            Vector of constant default values. It can be either empty (the default)
            or a vector of exactly m doubles, each of which can be finite or NAN. If
            the vector is empty, it will be initialized as m NANs (i.e., no
            restriction of the parameter domain). Each NAN represents a free
            parameter $x_t$, while the finite entries denote the constant values for
            the corresponding parameter.  

    * `ComponentScalarFunction(f, k, defaultValues=std::vector< double >())`  

        Constructor.  

        Use it like this: ComponentScalarFunction g(f, 3, {NAN, NAN, 0.42}); where f
        is a vector-valued function with 5 components and 3 parameters. This selects
        the first two parameters and the fourth component of f, while constantly
        using 0.42 for the third parameter.  

        Parameters:  
        * `f` :  
            vector-valued function (m components)  
        * `k` :  
            index of component $f_k$ to select (between 0 and m - 1)  
        * `defaultValues` :  
            see other constructor  

    C++ includes: ComponentScalarFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `ComponentScalarFunction(f, defaultValues=std::vector< double >())`  

            Constructor.  

            Use it like this: ComponentScalarFunction g(f, {NAN, NAN, 0.42}); where f is
            a scalar-valued function with 3 parameters. This selects the first two
            parameters of f, while constantly using 0.42 for the third parameter.  

            Parameters:  
            * `f` :  
                scalar-valued function  
            * `defaultValues` :  
                Vector of constant default values. It can be either empty (the default)
                or a vector of exactly m doubles, each of which can be finite or NAN. If
                the vector is empty, it will be initialized as m NANs (i.e., no
                restriction of the parameter domain). Each NAN represents a free
                parameter $x_t$, while the finite entries denote the constant values for
                the corresponding parameter.  

        * `ComponentScalarFunction(f, k, defaultValues=std::vector< double >())`  

            Constructor.  

            Use it like this: ComponentScalarFunction g(f, 3, {NAN, NAN, 0.42}); where f
            is a vector-valued function with 5 components and 3 parameters. This selects
            the first two parameters and the fourth component of f, while constantly
            using 0.42 for the third parameter.  

            Parameters:  
            * `f` :  
                vector-valued function (m components)  
            * `k` :  
                index of component $f_k$ to select (between 0 and m - 1)  
            * `defaultValues` :  
                see other constructor  

        """
        _pysgpp_swig.ComponentScalarFunction_swiginit(self, _pysgpp_swig.new_ComponentScalarFunction(*args))
    __swig_destroy__ = _pysgpp_swig.delete_ComponentScalarFunction

# Register ComponentScalarFunction in _pysgpp_swig:
_pysgpp_swig.ComponentScalarFunction_swigregister(ComponentScalarFunction)

class ComponentScalarFunctionGradient(ScalarFunctionGradient):
    r"""

    `ComponentScalarFunctionGradient(fGradient, defaultValues=std::vector< double
        >())`  
    `ComponentScalarFunctionGradient(fGradient, k, defaultValues=std::vector< double
        >())`  

    One component of a vector-valued function gradient.  

    See also: ComponentScalarFunction  

    Constructors
    ------------
    * `ComponentScalarFunctionGradient(fGradient, defaultValues=std::vector< double
        >())`  

        Constructor.  

        Use it like this: ComponentScalarFunctionGradient gGradient(fGradient, {NAN,
        NAN, 0.42}); where fGradient is a scalar-valued function gradient with 3
        parameters. This selects the first two parameters of fGradient, while
        constantly using 0.42 for the third parameter.  

        Parameters:  
        * `fGradient` :  
            scalar-valued function gradient  
        * `defaultValues` :  
            Vector of constant default values. It can be either empty (the default)
            or a vector of exactly m doubles, each of which can be finite or NAN. If
            the vector is empty, it will be initialized as m NANs (i.e., no
            restriction of the parameter domain). Each NAN represents a free
            parameter $x_t$, while the finite entries denote the constant values for
            the corresponding parameter.  

    * `ComponentScalarFunctionGradient(fGradient, k, defaultValues=std::vector<
        double >())`  

        Constructor.  

        Use it like this: ComponentScalarFunctionGradient gGradient(fGradient, 3,
        {NAN, NAN, 0.42}); where fGradient is a vector-valued function gradient with
        5 components and 3 parameters. This selects the first two parameters and the
        fourth component of fGradient, while constantly using 0.42 for the third
        parameter.  

        Parameters:  
        * `fGradient` :  
            vector-valued function gradient (m components)  
        * `k` :  
            index of component $f_k$ to select (between 0 and m - 1)  
        * `defaultValues` :  
            see other constructor  

    C++ includes: ComponentScalarFunctionGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `ComponentScalarFunctionGradient(fGradient, defaultValues=std::vector< double
            >())`  

            Constructor.  

            Use it like this: ComponentScalarFunctionGradient gGradient(fGradient, {NAN,
            NAN, 0.42}); where fGradient is a scalar-valued function gradient with 3
            parameters. This selects the first two parameters of fGradient, while
            constantly using 0.42 for the third parameter.  

            Parameters:  
            * `fGradient` :  
                scalar-valued function gradient  
            * `defaultValues` :  
                Vector of constant default values. It can be either empty (the default)
                or a vector of exactly m doubles, each of which can be finite or NAN. If
                the vector is empty, it will be initialized as m NANs (i.e., no
                restriction of the parameter domain). Each NAN represents a free
                parameter $x_t$, while the finite entries denote the constant values for
                the corresponding parameter.  

        * `ComponentScalarFunctionGradient(fGradient, k, defaultValues=std::vector<
            double >())`  

            Constructor.  

            Use it like this: ComponentScalarFunctionGradient gGradient(fGradient, 3,
            {NAN, NAN, 0.42}); where fGradient is a vector-valued function gradient with
            5 components and 3 parameters. This selects the first two parameters and the
            fourth component of fGradient, while constantly using 0.42 for the third
            parameter.  

            Parameters:  
            * `fGradient` :  
                vector-valued function gradient (m components)  
            * `k` :  
                index of component $f_k$ to select (between 0 and m - 1)  
            * `defaultValues` :  
                see other constructor  

        """
        _pysgpp_swig.ComponentScalarFunctionGradient_swiginit(self, _pysgpp_swig.new_ComponentScalarFunctionGradient(*args))
    __swig_destroy__ = _pysgpp_swig.delete_ComponentScalarFunctionGradient

# Register ComponentScalarFunctionGradient in _pysgpp_swig:
_pysgpp_swig.ComponentScalarFunctionGradient_swigregister(ComponentScalarFunctionGradient)

class ComponentScalarFunctionHessian(ScalarFunctionHessian):
    r"""

    `ComponentScalarFunctionHessian(fHessian, defaultValues=std::vector< double
        >())`  
    `ComponentScalarFunctionHessian(fHessian, k, defaultValues=std::vector< double
        >())`  

    One component of a vector-valued function Hessian.  

    See also: ComponentScalarFunction  

    Constructors
    ------------
    * `ComponentScalarFunctionHessian(fHessian, defaultValues=std::vector< double
        >())`  

        Constructor.  

        Use it like this: ComponentScalarFunctionHessian gHessian(fHessian, {NAN,
        NAN, 0.42}); where fHessian is a scalar-valued function Hessian with 3
        parameters. This selects the first two parameters of fHessian, while
        constantly using 0.42 for the third parameter.  

        Parameters:  
        * `fHessian` :  
            scalar-valued function Hessian  
        * `defaultValues` :  
            Vector of constant default values. It can be either empty (the default)
            or a vector of exactly m doubles, each of which can be finite or NAN. If
            the vector is empty, it will be initialized as m NANs (i.e., no
            restriction of the parameter domain). Each NAN represents a free
            parameter $x_t$, while the finite entries denote the constant values for
            the corresponding parameter.  

    * `ComponentScalarFunctionHessian(fHessian, k, defaultValues=std::vector< double
        >())`  

        Constructor.  

        Use it like this: ComponentScalarFunctionHessian gHessian(fHessian, 3, {NAN,
        NAN, 0.42}); where fHessian is a vector-valued function Hessian with 5
        components and 3 parameters. This selects the first two parameters and the
        fourth component of fHessian, while constantly using 0.42 for the third
        parameter.  

        Parameters:  
        * `fHessian` :  
            vector-valued function Hessian (m components)  
        * `k` :  
            index of component $f_k$ to select (between 0 and m - 1)  
        * `defaultValues` :  
            see other constructor  

    C++ includes: ComponentScalarFunctionHessian.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `ComponentScalarFunctionHessian(fHessian, defaultValues=std::vector< double
            >())`  

            Constructor.  

            Use it like this: ComponentScalarFunctionHessian gHessian(fHessian, {NAN,
            NAN, 0.42}); where fHessian is a scalar-valued function Hessian with 3
            parameters. This selects the first two parameters of fHessian, while
            constantly using 0.42 for the third parameter.  

            Parameters:  
            * `fHessian` :  
                scalar-valued function Hessian  
            * `defaultValues` :  
                Vector of constant default values. It can be either empty (the default)
                or a vector of exactly m doubles, each of which can be finite or NAN. If
                the vector is empty, it will be initialized as m NANs (i.e., no
                restriction of the parameter domain). Each NAN represents a free
                parameter $x_t$, while the finite entries denote the constant values for
                the corresponding parameter.  

        * `ComponentScalarFunctionHessian(fHessian, k, defaultValues=std::vector< double
            >())`  

            Constructor.  

            Use it like this: ComponentScalarFunctionHessian gHessian(fHessian, 3, {NAN,
            NAN, 0.42}); where fHessian is a vector-valued function Hessian with 5
            components and 3 parameters. This selects the first two parameters and the
            fourth component of fHessian, while constantly using 0.42 for the third
            parameter.  

            Parameters:  
            * `fHessian` :  
                vector-valued function Hessian (m components)  
            * `k` :  
                index of component $f_k$ to select (between 0 and m - 1)  
            * `defaultValues` :  
                see other constructor  

        """
        _pysgpp_swig.ComponentScalarFunctionHessian_swiginit(self, _pysgpp_swig.new_ComponentScalarFunctionHessian(*args))
    __swig_destroy__ = _pysgpp_swig.delete_ComponentScalarFunctionHessian

# Register ComponentScalarFunctionHessian in _pysgpp_swig:
_pysgpp_swig.ComponentScalarFunctionHessian_swigregister(ComponentScalarFunctionHessian)

class WrapperScalarFunction(ScalarFunction):
    r"""

    `WrapperScalarFunction(d, f)`  

    Implementation of ScalarFunction that wraps a std::function object.  

    Constructors
    ------------
    * `WrapperScalarFunction(d, f)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `f` :  
            function to be wrapped  

    C++ includes: WrapperScalarFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", f: "sgpp::base::WrapperScalarFunction::FunctionEvalType"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `f` :  
            function to be wrapped  

        """
        _pysgpp_swig.WrapperScalarFunction_swiginit(self, _pysgpp_swig.new_WrapperScalarFunction(d, f))
    __swig_destroy__ = _pysgpp_swig.delete_WrapperScalarFunction

# Register WrapperScalarFunction in _pysgpp_swig:
_pysgpp_swig.WrapperScalarFunction_swigregister(WrapperScalarFunction)

class WrapperScalarFunctionGradient(ScalarFunctionGradient):
    r"""

    `WrapperScalarFunctionGradient(d, fGradient)`  

    Implementation of ScalarFunctionGradient that wraps a std::function object.  

    Constructors
    ------------
    * `WrapperScalarFunctionGradient(d, fGradient)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `fGradient` :  
            function gradient to be wrapped  

    C++ includes: WrapperScalarFunctionGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", fGradient: "sgpp::base::WrapperScalarFunctionGradient::FunctionGradientEvalType"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `fGradient` :  
            function gradient to be wrapped  

        """
        _pysgpp_swig.WrapperScalarFunctionGradient_swiginit(self, _pysgpp_swig.new_WrapperScalarFunctionGradient(d, fGradient))
    __swig_destroy__ = _pysgpp_swig.delete_WrapperScalarFunctionGradient

# Register WrapperScalarFunctionGradient in _pysgpp_swig:
_pysgpp_swig.WrapperScalarFunctionGradient_swigregister(WrapperScalarFunctionGradient)

class WrapperScalarFunctionHessian(ScalarFunctionHessian):
    r"""

    `WrapperScalarFunctionHessian(d, fHessian)`  

    Implementation of ScalarFunctionHessian that wraps a std::function object.  

    Constructors
    ------------
    * `WrapperScalarFunctionHessian(d, fHessian)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `fHessian` :  
            function gradient to be wrapped  

    C++ includes: WrapperScalarFunctionHessian.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", fHessian: "sgpp::base::WrapperScalarFunctionHessian::FunctionHessianEvalType"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `fHessian` :  
            function gradient to be wrapped  

        """
        _pysgpp_swig.WrapperScalarFunctionHessian_swiginit(self, _pysgpp_swig.new_WrapperScalarFunctionHessian(d, fHessian))
    __swig_destroy__ = _pysgpp_swig.delete_WrapperScalarFunctionHessian

# Register WrapperScalarFunctionHessian in _pysgpp_swig:
_pysgpp_swig.WrapperScalarFunctionHessian_swigregister(WrapperScalarFunctionHessian)

class WrapperVectorFunction(VectorFunction):
    r"""

    `WrapperVectorFunction(d, m, f)`  

    Implementation of VectorFunction that wraps a std::function object.  

    Constructors
    ------------
    * `WrapperVectorFunction(d, m, f)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  
        * `f` :  
            function to be wrapped  

    C++ includes: WrapperVectorFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", m: "size_t", f: "sgpp::base::WrapperVectorFunction::FunctionEvalType"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  
        * `f` :  
            function to be wrapped  

        """
        _pysgpp_swig.WrapperVectorFunction_swiginit(self, _pysgpp_swig.new_WrapperVectorFunction(d, m, f))
    __swig_destroy__ = _pysgpp_swig.delete_WrapperVectorFunction

# Register WrapperVectorFunction in _pysgpp_swig:
_pysgpp_swig.WrapperVectorFunction_swigregister(WrapperVectorFunction)

class WrapperVectorFunctionGradient(VectorFunctionGradient):
    r"""

    `WrapperVectorFunctionGradient(d, m, fGradient)`  

    Implementation of VectorFunctionGradient that wraps a std::function object.  

    Constructors
    ------------
    * `WrapperVectorFunctionGradient(d, m, fGradient)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  
        * `fGradient` :  
            function gradient to be wrapped  

    C++ includes: WrapperVectorFunctionGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", m: "size_t", fGradient: "sgpp::base::WrapperVectorFunctionGradient::FunctionGradientEvalType"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  
        * `fGradient` :  
            function gradient to be wrapped  

        """
        _pysgpp_swig.WrapperVectorFunctionGradient_swiginit(self, _pysgpp_swig.new_WrapperVectorFunctionGradient(d, m, fGradient))
    __swig_destroy__ = _pysgpp_swig.delete_WrapperVectorFunctionGradient

# Register WrapperVectorFunctionGradient in _pysgpp_swig:
_pysgpp_swig.WrapperVectorFunctionGradient_swigregister(WrapperVectorFunctionGradient)

class WrapperVectorFunctionHessian(VectorFunctionHessian):
    r"""

    `WrapperVectorFunctionHessian(d, m, fHessian)`  

    Implementation of VectorFunctionHessian that wraps a std::function object.  

    Constructors
    ------------
    * `WrapperVectorFunctionHessian(d, m, fHessian)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  
        * `fHessian` :  
            function gradient to be wrapped  

    C++ includes: WrapperVectorFunctionHessian.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", m: "size_t", fHessian: "sgpp::base::WrapperVectorFunctionHessian::FunctionHessianEvalType"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  
        * `fHessian` :  
            function gradient to be wrapped  

        """
        _pysgpp_swig.WrapperVectorFunctionHessian_swiginit(self, _pysgpp_swig.new_WrapperVectorFunctionHessian(d, m, fHessian))
    __swig_destroy__ = _pysgpp_swig.delete_WrapperVectorFunctionHessian

# Register WrapperVectorFunctionHessian in _pysgpp_swig:
_pysgpp_swig.WrapperVectorFunctionHessian_swigregister(WrapperVectorFunctionHessian)

class EmptyVectorFunction(object):
    r"""


    Singleton containing an empty implementation of VectorFunction.  

    This is intended as a fill-in for ConstrainedOptimizer, if only equality or
    inequality constraints are supported.  

    C++ includes: EmptyVectorFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def getInstance() -> "sgpp::base::WrapperVectorFunction &":
        r"""


        """
        return _pysgpp_swig.EmptyVectorFunction_getInstance()
    __swig_destroy__ = _pysgpp_swig.delete_EmptyVectorFunction

# Register EmptyVectorFunction in _pysgpp_swig:
_pysgpp_swig.EmptyVectorFunction_swigregister(EmptyVectorFunction)

def EmptyVectorFunction_getInstance() -> "sgpp::base::WrapperVectorFunction &":
    r"""


    """
    return _pysgpp_swig.EmptyVectorFunction_getInstance()

class EmptyVectorFunctionGradient(object):
    r"""


    Singleton containing an empty implementation of VectorFunctionGradient.  

    This is intended as a fill-in for ConstrainedOptimizer, if only equality or
    inequality constraints are supported.  

    C++ includes: EmptyVectorFunctionGradient.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def getInstance() -> "sgpp::base::WrapperVectorFunctionGradient &":
        r"""


        """
        return _pysgpp_swig.EmptyVectorFunctionGradient_getInstance()
    __swig_destroy__ = _pysgpp_swig.delete_EmptyVectorFunctionGradient

# Register EmptyVectorFunctionGradient in _pysgpp_swig:
_pysgpp_swig.EmptyVectorFunctionGradient_swigregister(EmptyVectorFunctionGradient)

def EmptyVectorFunctionGradient_getInstance() -> "sgpp::base::WrapperVectorFunctionGradient &":
    r"""


    """
    return _pysgpp_swig.EmptyVectorFunctionGradient_getInstance()

class OperationParabolicPDESolverSystem(OperationMatrix):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationParabolicPDESolverSystem

    def generateRHS(self) -> "sgpp::base::DataVector *":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_generateRHS(self)

    def finishTimestep(self) -> "void":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_finishTimestep(self)

    def coarsenAndRefine(self, isLastTimestep: "bool"=False) -> "void":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_coarsenAndRefine(self, isLastTimestep)

    def startTimestep(self) -> "void":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_startTimestep(self)

    def getGrid(self) -> "sgpp::base::Grid *":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_getGrid(self)

    def getGridCoefficientsForCG(self) -> "sgpp::base::DataVector *":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_getGridCoefficientsForCG(self)

    def getGridCoefficients(self) -> "sgpp::base::DataVector *":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_getGridCoefficients(self)

    def setODESolver(self, ode: "std::string") -> "void":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_setODESolver(self, ode)

    def getODESolver(self) -> "std::string":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_getODESolver(self)

    def getSumGridPointsComplete(self) -> "size_t":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_getSumGridPointsComplete(self)

    def getSumGridPointsInner(self) -> "size_t":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_getSumGridPointsInner(self)

    def setTimestepSize(self, newTimestepSize: "double") -> "void":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_setTimestepSize(self, newTimestepSize)

    def abortTimestep(self) -> "void":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_abortTimestep(self)

    def saveAlpha(self) -> "void":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_saveAlpha(self)

    def getGridCoefficientsForSC(self, Values: "DataVector") -> "void":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_getGridCoefficientsForSC(self, Values)

    def getGridStorage(self) -> "sgpp::base::GridStorage *":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_getGridStorage(self)

    def getOldGridStorage(self) -> "sgpp::base::GridStorage *":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_getOldGridStorage(self)

    def getSecondGridStorage(self) -> "sgpp::base::GridStorage *":
        return _pysgpp_swig.OperationParabolicPDESolverSystem_getSecondGridStorage(self)

# Register OperationParabolicPDESolverSystem in _pysgpp_swig:
_pysgpp_swig.OperationParabolicPDESolverSystem_swigregister(OperationParabolicPDESolverSystem)

class OperationParabolicPDESolverSystemDirichlet(OperationParabolicPDESolverSystem):
    r"""

    `OperationParabolicPDESolverSystemDirichlet()`  

    Defines a System that is used to solve parabolic partial differential equations.  

    So an instance of this class has to pass to any ODE Solver used in SGpp.  

    $A \dot{u} = L \vec{u}$  

    A: mass matrix L: space discretization (L-Operator)  

    This class defines an elliptic problem in every timestep which is solved using
    an iterative SLE solver, that solving step is integrated in the ODE Solver.  

    This class is a specialized version of OperationParabolicPDESolverSystem which
    exploit Dirichlet boundary conditions. Hence there are no degrees of freedom on
    on the boundaries the iterative solver (CG or BiCGSTAB) has only to take inner
    grid points into account.  

    Constructors
    ------------
    * `OperationParabolicPDESolverSystemDirichlet()`  

        Constructor.  

    C++ includes: OperationParabolicPDESolverSystemDirichlet.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationParabolicPDESolverSystemDirichlet

# Register OperationParabolicPDESolverSystemDirichlet in _pysgpp_swig:
_pysgpp_swig.OperationParabolicPDESolverSystemDirichlet_swigregister(OperationParabolicPDESolverSystemDirichlet)

class HeatEquationParabolicPDESolverSystem(OperationParabolicPDESolverSystemDirichlet):
    r"""

    `HeatEquationParabolicPDESolverSystem(SparseGrid, alpha, a, TimestepSize,
        OperationMode="ExEul")`  

    This class implements the ParabolicPDESolverSystem for the Heat Equation.  

    Constructors
    ------------
    * `HeatEquationParabolicPDESolverSystem(SparseGrid, alpha, a, TimestepSize,
        OperationMode="ExEul")`  

        Std-Constructor.  

        Parameters:  
        * `SparseGrid` :  
            reference to the sparse grid  
        * `alpha` :  
            the sparse grid's coefficients  
        * `a` :  
            the heat coefficient  
        * `TimestepSize` :  
            the size of one timestep used in the ODE Solver  
        * `OperationMode` :  
            specifies in which solver this matrix is used, valid values are: ExEul
            for explicit Euler, ImEul for implicit Euler, CrNic for Crank Nicolson
            solver  

    C++ includes: HeatEquationParabolicPDESolverSystem.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Std-Constructor.  

        Parameters
        ----------
        * `SparseGrid` :  
            reference to the sparse grid  
        * `alpha` :  
            the sparse grid's coefficients  
        * `a` :  
            the heat coefficient  
        * `TimestepSize` :  
            the size of one timestep used in the ODE Solver  
        * `OperationMode` :  
            specifies in which solver this matrix is used, valid values are: ExEul for
            explicit Euler, ImEul for implicit Euler, CrNic for Crank Nicolson solver  

        """
        _pysgpp_swig.HeatEquationParabolicPDESolverSystem_swiginit(self, _pysgpp_swig.new_HeatEquationParabolicPDESolverSystem(*args))
    __swig_destroy__ = _pysgpp_swig.delete_HeatEquationParabolicPDESolverSystem

    def coarsenAndRefine(self, isLastTimestep: "bool"=False) -> "void":
        r"""


        """
        return _pysgpp_swig.HeatEquationParabolicPDESolverSystem_coarsenAndRefine(self, isLastTimestep)

# Register HeatEquationParabolicPDESolverSystem in _pysgpp_swig:
_pysgpp_swig.HeatEquationParabolicPDESolverSystem_swigregister(HeatEquationParabolicPDESolverSystem)

class PDESolver(object):
    r"""

    `PDESolver()`  

    This class provides defines a implements basic task and tools which are useful
    while solving PDEs.  

    E.g. grid construction, simple grid evaluation tools grid printing, initial grid
    refinement etc.  

    Constructors
    ------------
    * `PDESolver()`  

        Std-Constructor of the solver.  

    C++ includes: PDESolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_PDESolver

    def constructGrid(self, myBoundingBox: "BoundingBox", level: "size_t") -> "void":
        r"""


        Use this routine the construct a regular grid to solve a PDE.  

        Parameters
        ----------
        * `myBoundingBox` :  
            reference to a bounding box that describes the grid  
        * `level` :  
            number of the regular's grid levels  

        """
        return _pysgpp_swig.PDESolver_constructGrid(self, myBoundingBox, level)

    def setGrid(self, serializedGrid: "std::string const &") -> "void":
        r"""


        Sets the grid used in this BlackScholes Solver by an given serialized string of
        the grid.  

        Parameters
        ----------
        * `serializedGrid` :  
            a string that describes the grid that should be used in this solver  

        """
        return _pysgpp_swig.PDESolver_setGrid(self, serializedGrid)

    def getGrid(self) -> "std::string":
        r"""


        gets the a string the describes the grid which is currently used to solve  

        Returns
        -------
        a string containing a serialized grid  

        """
        return _pysgpp_swig.PDESolver_getGrid(self)

    def deleteGrid(self) -> "void":
        r"""


        deletes the grid created within that solver  

        """
        return _pysgpp_swig.PDESolver_deleteGrid(self)

    def refineInitialGridSurplus(self, alpha: "DataVector", numRefinePoints: "int", dThreshold: "double") -> "void":
        r"""


        Refines a grid by taking the grid's coefficients into account.  

        This refinement method refines the grid based on the surplus by refining grid
        points with big surpluses first. The number of grid points to refine may be
        specified by the numRefinePoints parameter.  

        Parameters
        ----------
        * `alpha` :  
            a sgpp::base::DataVector containing the grids coefficients  
        * `numRefinePoints` :  
            the number of grid points that should be refined; if this smaller than zero
            -> all refineable points will be refined  
        * `dThreshold` :  
            Threshold for a point's surplus for refining this point  

        """
        return _pysgpp_swig.PDESolver_refineInitialGridSurplus(self, alpha, numRefinePoints, dThreshold)

    def refineInitialGridSurplusToMaxLevel(self, alpha: "DataVector", dThreshold: "double", maxLevel: "sgpp::base::level_t") -> "void":
        r"""


        Refines a grid by taking the grid's coefficients into account.  

        This refinement method refines the grid based on the surplus by refining grid
        points with big surpluses first. The grid is refined to max. Level!  

        Parameters
        ----------
        * `alpha` :  
            a sgpp::base::DataVector containing the grids coefficients  
        * `dThreshold` :  
            Threshold for a point's surplus for refining this point  
        * `maxLevel` :  
            maxLevel of refinement  

        """
        return _pysgpp_swig.PDESolver_refineInitialGridSurplusToMaxLevel(self, alpha, dThreshold, maxLevel)

    def refineInitialGridSurplusSubDomain(self, alpha: "DataVector", numRefinePoints: "int", dThreshold: "double", norm_mu: "DoubleVector", norm_sigma: "DoubleVector") -> "void":
        r"""


        Refines a grid by taking the grid's coefficients into account.  

        This refinement method refines the grid based on the surplus by refining grid
        points with big surpluses first. The number of grid points to refine may be
        specified by the numRefinePoints parameter.  

        This functions refines the grid only in subdomain specified by a multi-
        dimensional normal distribution. The normal distribution is given by the
        parameters norm_mu and norm_sigma which are d-dimensional vectors.  

        Parameters
        ----------
        * `alpha` :  
            a sgpp::base::DataVector containing the grids coefficients  
        * `numRefinePoints` :  
            the number of grid points that should be refined; if this smaller than zero
            -> all refineable points will be refined  
        * `dThreshold` :  
            Threshold for a point's surplus for refining this point  
        * `norm_mu` :  
            the expected values of the normal distribution for every grid dimension  
        * `norm_sigma` :  
            the standard deviation of the normal distribution for every grid dimension  

        """
        return _pysgpp_swig.PDESolver_refineInitialGridSurplusSubDomain(self, alpha, numRefinePoints, dThreshold, norm_mu, norm_sigma)

    def refineInitialGridSurplusToMaxLevelSubDomain(self, alpha: "DataVector", dThreshold: "double", maxLevel: "sgpp::base::level_t", norm_mu: "DoubleVector", norm_sigma: "DoubleVector") -> "void":
        r"""


        Refines a grid by taking the grid's coefficients into account.  

        This refinement method refines the grid based on the surplus by refining grid
        points with big surpluses first. The grid is refined to max. Level!  

        This functions refines the grid only in subdomain specified by a multi-
        dimensional normal distribution. The normal distribution is given by the
        parameters norm_mu and norm_sigma which are d-dimensional vectors.  

        Parameters
        ----------
        * `alpha` :  
            a sgpp::base::DataVector containing the grids coefficients  
        * `dThreshold` :  
            Threshold for a point's surplus for refining this point  
        * `maxLevel` :  
            maxLevel of refinement  
        * `norm_mu` :  
            the expected values of the normal distribution for every grid dimension  
        * `norm_sigma` :  
            the standard deviation of the normal distribution for every grid dimension  

        """
        return _pysgpp_swig.PDESolver_refineInitialGridSurplusToMaxLevelSubDomain(self, alpha, dThreshold, maxLevel, norm_mu, norm_sigma)

    def coarsenInitialGridSurplus(self, alpha: "DataVector", dThreshold: "double") -> "void":
        r"""


        Coarsens a grid by taking the grid's coefficients into account.  

        This coarsen method coarsens the grid based on the surplus by coarsening grid
        points with small surpluses first.  

        Parameters
        ----------
        * `alpha` :  
            a sgpp::base::DataVector containing the grids coefficients  
        * `dThreshold` :  
            Threshold for a point's surplus for coarsening this point  

        """
        return _pysgpp_swig.PDESolver_coarsenInitialGridSurplus(self, alpha, dThreshold)

    def evaluatePoint(self, evalPoint: "DataVector", alpha: "DataVector") -> "double":
        r"""


        Determines the value of the function in the d-dimensional space.  

        Parameters
        ----------
        * `evalPoint` :  
            coordinates of the point at which the function should be evaluated  
        * `alpha` :  
            the ansatzfunctions' coefficients  

        Returns
        -------
        price of option for given point  

        """
        return _pysgpp_swig.PDESolver_evaluatePoint(self, evalPoint, alpha)

    def evaluateCuboid(self, alpha: "DataVector", FunctionValues: "DataVector", EvaluationPoints: "DataMatrix") -> "void":
        r"""


        Evaluates the sparse grid's function given by the stored grid and the alpha
        coefficients.  

        on different points specified in EvaluationPoints and stores the result into
        FunctionValues.  

        Parameters
        ----------
        * `alpha` :  
            the sparse grid's coefficients  
        * `FunctionValues` :  
            sgpp::base::DataVector into the which the result of function's evaluation is
            stored  
        * `EvaluationPoints` :  
            sgpp::base::DataMatrix that contains the points at which the sparse grid's
            function is evaluated  

        """
        return _pysgpp_swig.PDESolver_evaluateCuboid(self, alpha, FunctionValues, EvaluationPoints)

    def printLevelIndexGrid(self, tfilename: "std::string") -> "void":
        r"""


        Prints the level,index pairs of the grid for each Gridpoint to a file.  

        Parameters
        ----------
        * `tfilename` :  
            relative path to file into which the grid's evaluation is written  

        """
        return _pysgpp_swig.PDESolver_printLevelIndexGrid(self, tfilename)

    def printGrid(self, alpha: "DataVector", PointesPerDimension: "size_t", tfilename: "std::string") -> "void":
        r"""


        This is some kind of debug functionality.  

        It writes a file, that can be used with gnuplot the print the grid.  

        Is only implemented for 1D and 2D grids!  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `PointesPerDimension` :  
            the distance between evaluation points  
        * `tfilename` :  
            absolute path to file into which the grid's evaluation is written  

        """
        return _pysgpp_swig.PDESolver_printGrid(self, alpha, PointesPerDimension, tfilename)

    def printGridDomain(self, alpha: "DataVector", PointesPerDimension: "size_t", GridArea: "BoundingBox", tfilename: "std::string") -> "void":
        r"""


        This is some kind of debug functionality.  

        It writes a file, that can be used with gnuplot the print the grid.  

        Is only implemented for 2D grids!  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `PointesPerDimension` :  
            the distance between evaluation points  
        * `GridArea` :  
            the area in which the function should be plotted  
        * `tfilename` :  
            absolute path to file into which the grid's evaluation is written  

        """
        return _pysgpp_swig.PDESolver_printGridDomain(self, alpha, PointesPerDimension, GridArea, tfilename)

    def printSparseGrid(self, alpha: "DataVector", tfilename: "std::string", bSurplus: "bool") -> "void":
        r"""


        Prints the sgpp::base::Grid Points of the Sparse sgpp::base::Grid either with
        their node basis value or their hierarchical surplus.  

        This function is available for all dimensions  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the grid's ansatzfunctions  
        * `tfilename` :  
            absoulte path to the file the grid is written into  
        * `bSurplus` :  
            specifies whether the surplus (true) or the node basis value (false) is
            written  

        """
        return _pysgpp_swig.PDESolver_printSparseGrid(self, alpha, tfilename, bSurplus)

    def printSparseGridExpTransform(self, alpha: "DataVector", tfilename: "std::string", bSurplus: "bool") -> "void":
        r"""


        Prints the sgpp::base::Grid Points of the Sparse sgpp::base::Grid either with
        their node basis value or their hierarchical surplus.  

        This function is available for all dimensions.  

        The coordinates of the grid points are pushed the exp function. So log
        transformed grids can be plotted in cartesion coordinates.  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the grid's ansatzfunctions  
        * `tfilename` :  
            absoulte path to the file the grid is written into  
        * `bSurplus` :  
            specifies whether the surplus (true) or the node basis value (false) is
            written  

        """
        return _pysgpp_swig.PDESolver_printSparseGridExpTransform(self, alpha, tfilename, bSurplus)

    def getNumberGridPoints(self) -> "size_t":
        r"""


        use this to determine the number of grid points, used to solve the current
        problem  

        Returns
        -------
        the number of grid points  

        """
        return _pysgpp_swig.PDESolver_getNumberGridPoints(self)

    def getNumberInnerGridPoints(self) -> "size_t":
        r"""


        use this to determine the number of inner grid points, used to solve the current
        problem  

        Returns
        -------
        the number of inner grid points  

        """
        return _pysgpp_swig.PDESolver_getNumberInnerGridPoints(self)

    def getNumberDimensions(self) -> "size_t":
        r"""


        use this the determine the number of dimensions that are currently used in the
        solver.  

        Returns
        -------
        returns the number of the grid's dimensions, if the grid isn't constructed, yet
        it returns 0  

        """
        return _pysgpp_swig.PDESolver_getNumberDimensions(self)

# Register PDESolver in _pysgpp_swig:
_pysgpp_swig.PDESolver_swigregister(PDESolver)

class ParabolicPDESolver(PDESolver):
    r"""

    `ParabolicPDESolver()`  

    This class extends the PDESolver with functions that are needed to solve
    parabolic PDEs.  

    Constructors
    ------------
    * `ParabolicPDESolver()`  

        the size of one timestep  

        The number of timesteps that are executed during solving Std-Constructor of
        the solver  

    C++ includes: ParabolicPDESolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_ParabolicPDESolver

    def solveImplicitEuler(self, numTimesteps: "size_t", timestepsize: "double", maxCGIterations: "size_t", epsilonCG: "double", alpha: "DataVector", verbose: "bool"=False, generateAnimation: "bool"=False) -> "void":
        r"""


        Call this routine to use an explicit Euler algorithm to solve the parabolic PDE.  

        Parameters
        ----------
        * `numTimesteps` :  
            the number of timesteps that should be executed  
        * `timestepsize` :  
            the size of the interval one timestep moves forward  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `verbose` :  
            enables verbose output during solving  
        * `generateAnimation` :  
            set this to true, if you want to generate a grid output in every timestep  

        """
        return _pysgpp_swig.ParabolicPDESolver_solveImplicitEuler(self, numTimesteps, timestepsize, maxCGIterations, epsilonCG, alpha, verbose, generateAnimation)

    def solveExplicitEuler(self, numTimesteps: "size_t", timestepsize: "double", maxCGIterations: "size_t", epsilonCG: "double", alpha: "DataVector", verbose: "bool"=False, generateAnimation: "bool"=False) -> "void":
        r"""


        Call this routine to use an explicit Euler algorithm to solve the parabolic PDE.  

        Parameters
        ----------
        * `numTimesteps` :  
            the number of timesteps that should be executed  
        * `timestepsize` :  
            the size of the interval one timestep moves forward  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `verbose` :  
            enables verbose output during solving  
        * `generateAnimation` :  
            set this to true, if you want to generate a grid output in every timestep  

        """
        return _pysgpp_swig.ParabolicPDESolver_solveExplicitEuler(self, numTimesteps, timestepsize, maxCGIterations, epsilonCG, alpha, verbose, generateAnimation)

    def solveCrankNicolson(self, numTimesteps: "size_t", timestepsize: "double", maxCGIterations: "size_t", epsilonCG: "double", alpha: "DataVector", NumImEul: "size_t"=0) -> "void":
        r"""


        Call this routine to use the Crank Nicolson algorithm to solve the parabolic
        PDE.  

        Parameters
        ----------
        * `numTimesteps` :  
            the number of timesteps that should be executed  
        * `timestepsize` :  
            the size of the interval one timestep moves forward  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `NumImEul` :  
            specifies how many ImEul steps should be executed before CrNic is used,
            default is 0  

        """
        return _pysgpp_swig.ParabolicPDESolver_solveCrankNicolson(self, numTimesteps, timestepsize, maxCGIterations, epsilonCG, alpha, NumImEul)

# Register ParabolicPDESolver in _pysgpp_swig:
_pysgpp_swig.ParabolicPDESolver_swigregister(ParabolicPDESolver)

class HeatEquationSolver(ParabolicPDESolver):
    r"""

    `HeatEquationSolver()`  

    This class provides a simple-to-use solver of the multi dimensional Heat
    Equation on Sparse Grids.  

    The class's aim is, to hide all complex details of solving the Heat Equation on
    Sparse Grids!  

    Constructors
    ------------
    * `HeatEquationSolver()`  

        Std-Constructor of the solver.  

    C++ includes: HeatEquationSolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Std-Constructor of the solver.  

        """
        _pysgpp_swig.HeatEquationSolver_swiginit(self, _pysgpp_swig.new_HeatEquationSolver())
    __swig_destroy__ = _pysgpp_swig.delete_HeatEquationSolver

    def solveExplicitEuler(self, numTimesteps: "size_t", timestepsize: "double", maxCGIterations: "size_t", epsilonCG: "double", alpha: "DataVector", verbose: "bool"=False, generateAnimation: "bool"=False) -> "void":
        r"""


        Call this routine to use an explicit Euler algorithm to solve the parabolic PDE.  

        Parameters
        ----------
        * `numTimesteps` :  
            the number of timesteps that should be executed  
        * `timestepsize` :  
            the size of the interval one timestep moves forward  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `verbose` :  
            enables verbose output during solving  
        * `generateAnimation` :  
            set this to true, if you want to generate a grid output in every timestep  

        """
        return _pysgpp_swig.HeatEquationSolver_solveExplicitEuler(self, numTimesteps, timestepsize, maxCGIterations, epsilonCG, alpha, verbose, generateAnimation)

    def solveImplicitEuler(self, numTimesteps: "size_t", timestepsize: "double", maxCGIterations: "size_t", epsilonCG: "double", alpha: "DataVector", verbose: "bool"=False, generateAnimation: "bool"=False) -> "void":
        r"""


        Call this routine to use an explicit Euler algorithm to solve the parabolic PDE.  

        Parameters
        ----------
        * `numTimesteps` :  
            the number of timesteps that should be executed  
        * `timestepsize` :  
            the size of the interval one timestep moves forward  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `verbose` :  
            enables verbose output during solving  
        * `generateAnimation` :  
            set this to true, if you want to generate a grid output in every timestep  

        """
        return _pysgpp_swig.HeatEquationSolver_solveImplicitEuler(self, numTimesteps, timestepsize, maxCGIterations, epsilonCG, alpha, verbose, generateAnimation)

    def solveCrankNicolson(self, numTimesteps: "size_t", timestepsize: "double", maxCGIterations: "size_t", epsilonCG: "double", alpha: "DataVector", NumImEul: "size_t"=0) -> "void":
        r"""


        Call this routine to use the Crank Nicolson algorithm to solve the parabolic
        PDE.  

        Parameters
        ----------
        * `numTimesteps` :  
            the number of timesteps that should be executed  
        * `timestepsize` :  
            the size of the interval one timestep moves forward  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `NumImEul` :  
            specifies how many ImEul steps should be executed before CrNic is used,
            default is 0  

        """
        return _pysgpp_swig.HeatEquationSolver_solveCrankNicolson(self, numTimesteps, timestepsize, maxCGIterations, epsilonCG, alpha, NumImEul)

    def setHeatCoefficient(self, a: "double") -> "void":
        r"""


        This method sets the heat coefficient of the regarded material.  

        Parameters
        ----------
        * `a` :  
            the heat coefficient  

        """
        return _pysgpp_swig.HeatEquationSolver_setHeatCoefficient(self, a)

    def initGridWithSmoothHeat(self, alpha: "DataVector", mu: "double", sigma: "double", factor: "double") -> "void":
        r"""


        Inits the grid with a smooth heat distribution based on the normal distribution
        formula.  

        Parameters
        ----------
        * `alpha` :  
            reference to the coefficient's vector  
        * `mu` :  
            the exspected value of the normal distribution  
        * `sigma` :  
            the sigma of the normal distribution  
        * `factor` :  
            a factor that is used to stretch the function values  

        """
        return _pysgpp_swig.HeatEquationSolver_initGridWithSmoothHeat(self, alpha, mu, sigma, factor)

    def initScreen(self) -> "void":
        r"""


        Inits the screen object.  

        """
        return _pysgpp_swig.HeatEquationSolver_initScreen(self)

    def storeInnerRHS(self, alpha: "DataVector", tFilename: "std::string", timestepsize: "double") -> "void":
        r"""


        Routine to export the RHS of the inner system which has to be solved in order to
        solve the Poisson equation.  

        Parameters
        ----------
        * `alpha` :  
            the start solution  
        * `tFilename` :  
            file into which the rhs is written  
        * `timestepsize` :  
            the size of the timesteps  

        """
        return _pysgpp_swig.HeatEquationSolver_storeInnerRHS(self, alpha, tFilename, timestepsize)

    def storeInnerSolution(self, alpha: "DataVector", numTimesteps: "size_t", timestepsize: "double", maxCGIterations: "size_t", epsilonCG: "double", tFilename: "std::string") -> "void":
        r"""


        Routine to export the solution of the inner system which has been calculated by
        Up/Down scheme.  

        Parameters
        ----------
        * `alpha` :  
            the start solution  
        * `numTimesteps` :  
            number timesteps  
        * `timestepsize` :  
            size of timesteps  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the C  
        * `tFilename` :  
            file into which the rhs is written  

        """
        return _pysgpp_swig.HeatEquationSolver_storeInnerSolution(self, alpha, numTimesteps, timestepsize, maxCGIterations, epsilonCG, tFilename)

# Register HeatEquationSolver in _pysgpp_swig:
_pysgpp_swig.HeatEquationSolver_swigregister(HeatEquationSolver)

class HeatEquationSolverWithStretching(ParabolicPDESolver):
    r"""

    `HeatEquationSolverWithStretching()`  

    This class provides a simple-to-use solver of the multi dimensional Heat
    Equation that uses Sparse Grids.  

    The class's aim is, to hide all complex details of solving the Heat Equation
    with Sparse Grids!  

    Constructors
    ------------
    * `HeatEquationSolverWithStretching()`  

        Std-Constructor of the solver.  

    C++ includes: HeatEquationSolverWithStretching.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Std-Constructor of the solver.  

        """
        _pysgpp_swig.HeatEquationSolverWithStretching_swiginit(self, _pysgpp_swig.new_HeatEquationSolverWithStretching())
    __swig_destroy__ = _pysgpp_swig.delete_HeatEquationSolverWithStretching

    def constructGrid(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `constructGrid(myBoundingBox, level)`  

            Use this routine the construct a regular grid to solve a PDE.  

            Parameters:  
            * `myBoundingBox` :  
                reference to a bounding box that describes the grid  
            * `level` :  
                number of the regular's grid levels  

        * `constructGrid(myStretching, level)`  

        """
        return _pysgpp_swig.HeatEquationSolverWithStretching_constructGrid(self, *args)

    def solveExplicitEuler(self, numTimesteps: "size_t", timestepsize: "double", maxCGIterations: "size_t", epsilonCG: "double", alpha: "DataVector", verbose: "bool"=False, generateAnimation: "bool"=False) -> "void":
        r"""


        Call this routine to use an explicit Euler algorithm to solve the parabolic PDE.  

        Parameters
        ----------
        * `numTimesteps` :  
            the number of timesteps that should be executed  
        * `timestepsize` :  
            the size of the interval one timestep moves forward  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `verbose` :  
            enables verbose output during solving  
        * `generateAnimation` :  
            set this to true, if you want to generate a grid output in every timestep  

        """
        return _pysgpp_swig.HeatEquationSolverWithStretching_solveExplicitEuler(self, numTimesteps, timestepsize, maxCGIterations, epsilonCG, alpha, verbose, generateAnimation)

    def solveImplicitEuler(self, numTimesteps: "size_t", timestepsize: "double", maxCGIterations: "size_t", epsilonCG: "double", alpha: "DataVector", verbose: "bool"=False, generateAnimation: "bool"=False) -> "void":
        r"""


        Call this routine to use an explicit Euler algorithm to solve the parabolic PDE.  

        Parameters
        ----------
        * `numTimesteps` :  
            the number of timesteps that should be executed  
        * `timestepsize` :  
            the size of the interval one timestep moves forward  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `verbose` :  
            enables verbose output during solving  
        * `generateAnimation` :  
            set this to true, if you want to generate a grid output in every timestep  

        """
        return _pysgpp_swig.HeatEquationSolverWithStretching_solveImplicitEuler(self, numTimesteps, timestepsize, maxCGIterations, epsilonCG, alpha, verbose, generateAnimation)

    def solveCrankNicolson(self, numTimesteps: "size_t", timestepsize: "double", maxCGIterations: "size_t", epsilonCG: "double", alpha: "DataVector", NumImEul: "size_t"=0) -> "void":
        r"""


        Call this routine to use the Crank Nicolson algorithm to solve the parabolic
        PDE.  

        Parameters
        ----------
        * `numTimesteps` :  
            the number of timesteps that should be executed  
        * `timestepsize` :  
            the size of the interval one timestep moves forward  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `NumImEul` :  
            specifies how many ImEul steps should be executed before CrNic is used,
            default is 0  

        """
        return _pysgpp_swig.HeatEquationSolverWithStretching_solveCrankNicolson(self, numTimesteps, timestepsize, maxCGIterations, epsilonCG, alpha, NumImEul)

    def setHeatCoefficient(self, a: "double") -> "void":
        r"""


        This method sets the heat coefficient of the regarded material.  

        Parameters
        ----------
        * `a` :  
            the heat coefficient  

        """
        return _pysgpp_swig.HeatEquationSolverWithStretching_setHeatCoefficient(self, a)

    def initGridWithSmoothHeat(self, alpha: "DataVector", mu: "double", sigma: "double", factor: "double") -> "void":
        r"""


        Inits the grid in the middle of the whole domain with one single heat.  

        alpha reference to the coefficients vector heat the value of the heat in the
        middle of the domain Inits the grid in the middle the domain with an smooth heat
        distribution that the normal distribution formula  

        Parameters
        ----------
        * `alpha` :  
            reference to the coefficients vector  
        * `mu` :  
            the exspected value of the normal distribution  
        * `sigma` :  
            the sigma of the normal distribution  
        * `factor` :  
            a factor that is used to stretch the function values  

        """
        return _pysgpp_swig.HeatEquationSolverWithStretching_initGridWithSmoothHeat(self, alpha, mu, sigma, factor)

    def initScreen(self) -> "void":
        r"""


        Inits the grid with a constant heat.  

        alpha reference to the coefficients vector constHeat the temperature of the
        constant heat Inits the screen object  

        """
        return _pysgpp_swig.HeatEquationSolverWithStretching_initScreen(self)

    def printGridDomainStretching(self, alpha: "DataVector", PointesPerDimension: "size_t", GridArea: "Stretching", tfilename: "std::string") -> "void":
        r"""


        This is some kind of debug functionality.  

        It writes a file, that can be used with gnuplot the print the grid.  

        Is only implemented for 2D grids!  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions  
        * `PointesPerDimension` :  
            the distance between evaluation points  
        * `GridArea` :  
            the area in which the function should be plotted  
        * `tfilename` :  
            absolute path to file into which the grid's evaluation is written  

        """
        return _pysgpp_swig.HeatEquationSolverWithStretching_printGridDomainStretching(self, alpha, PointesPerDimension, GridArea, tfilename)

# Register HeatEquationSolverWithStretching in _pysgpp_swig:
_pysgpp_swig.HeatEquationSolverWithStretching_swigregister(HeatEquationSolverWithStretching)

class EllipticPDESolver(PDESolver):
    r"""

    `EllipticPDESolver()`  

    This class extends the PDESolver with functions that are needed to solve
    elliptic PDEs.  

    Constructors
    ------------
    * `EllipticPDESolver()`  

        Std-Constructor of the solver.  

    C++ includes: EllipticPDESolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_EllipticPDESolver

    def solvePDE(self, alpha: "DataVector", rhs: "DataVector", maxCGIterations: "size_t", epsilonCG: "double", verbose: "bool"=False) -> "void":
        r"""


        abstract method to solve an elliptic PDE.  

        All solver of elliptic PDEs have to implement this method.  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions will be in this vector
            after solving  
        * `rhs` :  
            the right hand side of the SLE  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `verbose` :  
            enables verbose output during solving  

        """
        return _pysgpp_swig.EllipticPDESolver_solvePDE(self, alpha, rhs, maxCGIterations, epsilonCG, verbose)

# Register EllipticPDESolver in _pysgpp_swig:
_pysgpp_swig.EllipticPDESolver_swigregister(EllipticPDESolver)

class PoissonEquationSolver(EllipticPDESolver):
    r"""

    `PoissonEquationSolver()`  

    This class provides a simple-to-use solver of the multi dimensional Poisson
    Equation on Sparse Grids.  

    The class's aim is, to hide all complex details of solving the Poisson Equation
    on Sparse Grids!  

    Constructors
    ------------
    * `PoissonEquationSolver()`  

        Std-Constructor of the solver.  

    C++ includes: PoissonEquationSolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Std-Constructor of the solver.  

        """
        _pysgpp_swig.PoissonEquationSolver_swiginit(self, _pysgpp_swig.new_PoissonEquationSolver())
    __swig_destroy__ = _pysgpp_swig.delete_PoissonEquationSolver

    def solvePDE(self, alpha: "DataVector", rhs: "DataVector", maxCGIterations: "size_t", epsilonCG: "double", verbose: "bool"=False) -> "void":
        r"""


        abstract method to solve an elliptic PDE.  

        All solver of elliptic PDEs have to implement this method.  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the Sparse Gird's basis functions will be in this vector
            after solving  
        * `rhs` :  
            the right hand side of the SLE  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the CG  
        * `verbose` :  
            enables verbose output during solving  

        """
        return _pysgpp_swig.PoissonEquationSolver_solvePDE(self, alpha, rhs, maxCGIterations, epsilonCG, verbose)

    def initGridWithSmoothHeat(self, alpha: "DataVector", mu: "double", sigma: "double", factor: "double") -> "void":
        r"""


        Inits the grid with a smooth heat distribution (based on a std-normal
        distribution) on its boundaries.  

        Coefficients of inner grid points are set to zero since an elliptical PDE is
        solved  

        Parameters
        ----------
        * `alpha` :  
            reference to the coefficients vector  
        * `mu` :  
            the exspected value of the normal distribution  
        * `sigma` :  
            the sigma of the normal distribution  
        * `factor` :  
            a factor that is used to stretch the function values  

        """
        return _pysgpp_swig.PoissonEquationSolver_initGridWithSmoothHeat(self, alpha, mu, sigma, factor)

    def initGridWithSmoothHeatFullDomain(self, alpha: "DataVector", mu: "double", sigma: "double", factor: "double") -> "void":
        r"""


        Inits the grid with a smooth heat distribution (based on a std-normal
        distribution) on its boundaries.  

        Coefficients of inner grid points aren't set to zero since they are used to hint
        an adaptive refinement of the grid BEFORE solving the PDE.  

        Parameters
        ----------
        * `alpha` :  
            reference to the coefficients vector  
        * `mu` :  
            the exspected value of the normal distribution  
        * `sigma` :  
            the sigma of the normal distribution  
        * `factor` :  
            a factor that is used to stretch the function values  

        """
        return _pysgpp_swig.PoissonEquationSolver_initGridWithSmoothHeatFullDomain(self, alpha, mu, sigma, factor)

    def initGridWithExpHeat(self, alpha: "DataVector", factor: "double"=1.0) -> "void":
        r"""


        Inits the grid with a heat distribution based on the e-function.  

        The e-function is shifted in that way the right boundary values becomes 1 (in
        case of factor = 1)  

        Parameters
        ----------
        * `alpha` :  
            reference to the coefficient's vector  
        * `factor` :  
            a constant factor used to enlarge the exp-functions input parameter  

        """
        return _pysgpp_swig.PoissonEquationSolver_initGridWithExpHeat(self, alpha, factor)

    def initGridWithExpHeatFullDomain(self, alpha: "DataVector", factor: "double"=1.0) -> "void":
        r"""


        Inits the grid with a heat distribution based on the e-function.  

        The e-function is shifted in that way the right boundary values becomes 1 (in
        case of factor = 1)  

        Parameters
        ----------
        * `alpha` :  
            reference to the coefficient's vector  
        * `factor` :  
            a constant factor used to enlarge the exp-functions input parameter  

        """
        return _pysgpp_swig.PoissonEquationSolver_initGridWithExpHeatFullDomain(self, alpha, factor)

    def storeInnerRHS(self, alpha: "DataVector", tFilename: "std::string") -> "void":
        r"""


        Routine to export the RHS of the inner system which has to be solved in order to
        solve the Poisson equation.  

        Parameters
        ----------
        * `alpha` :  
            the start solution  
        * `tFilename` :  
            file into which the rhs is written  

        """
        return _pysgpp_swig.PoissonEquationSolver_storeInnerRHS(self, alpha, tFilename)

    def storeInnerSolution(self, alpha: "DataVector", maxCGIterations: "size_t", epsilonCG: "double", tFilename: "std::string") -> "void":
        r"""


        Routine to export the solution of the inner system which has been calculated by
        Up/Down scheme.  

        Parameters
        ----------
        * `alpha` :  
            the start solution  
        * `maxCGIterations` :  
            the maximum of interation in the CG solver  
        * `epsilonCG` :  
            the epsilon used in the C  
        * `tFilename` :  
            file into which the rhs is written  

        """
        return _pysgpp_swig.PoissonEquationSolver_storeInnerSolution(self, alpha, maxCGIterations, epsilonCG, tFilename)

    def initScreen(self) -> "void":
        r"""


        Inits the screen object.  

        """
        return _pysgpp_swig.PoissonEquationSolver_initScreen(self)

# Register PoissonEquationSolver in _pysgpp_swig:
_pysgpp_swig.PoissonEquationSolver_swigregister(PoissonEquationSolver)


def createOperationLaplace(*args) -> "sgpp::base::OperationMatrix *":
    r"""


    Overloaded function
    -------------------
    * `createOperationLaplace(grid) -> base::OperationMatrix *`  

        Factory method, returning an OperationLaplace (OperationMatrix) for the grid
        at hand.  

        Note: object has to be freed after use.  

        Parameters:  
        * `grid` :  
            Grid which is to be used  

        Returns:
        Pointer to the new OperationMatrix object for the Grid grid  

    * `createOperationLaplace(grid, coef) -> base::OperationMatrix *`  

        Factory method, returning an OperationLaplace (OperationMatrix) for the grid
        at hand.  

        Note: object has to be freed after use.  

        Parameters:  
        * `grid` :  
            Grid which is to be used  
        * `coef` :  
            Coefficient vector for OperationLaplace  

        Returns:
        Pointer to the new OperationMatrix object for the Grid grid  

    """
    return _pysgpp_swig.createOperationLaplace(*args)

def createOperationLaplaceExplicit(*args) -> "sgpp::base::OperationMatrix *":
    r"""


    Overloaded function
    -------------------
    * `createOperationLaplaceExplicit(m, grid) -> base::OperationMatrix *`  

        Factory method, returning an OperationLaplaceExplicit (OperationMatrix) for
        the grid at hand.  

        Note: object has to be freed after use. The DataMatrix m is used to store
        the the matrix and is not destroyed if the OperationMatrix is destroyed.  

        Parameters:  
        * `grid` :  
            Grid which is to be used  
        * `m` :  
            DataMatrix in which the data is stored  

        Returns:
        Pointer to the new OperationMatrix object for the Grid grid  

    * `createOperationLaplaceExplicit(grid) -> base::OperationMatrix *`  

        Factory method, returning an OperationLaplaceExplicit (OperationMatrix) for
        the grid at hand.  

        Note: object has to be freed after use.  

        Parameters:  
        * `grid` :  
            Grid which is to be used  

        Returns:
        Pointer to the new OperationMatrix object for the Grid grid  

    """
    return _pysgpp_swig.createOperationLaplaceExplicit(*args)

def createOperationLTwoDotProduct(grid: "Grid") -> "sgpp::base::OperationMatrix *":
    r"""


    Factory method, returning an OperationLTwoDotProduct (OperationMatrix) for the
    grid at hand.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used  

    Returns
    -------
    Pointer to the new OperationMatrix object for the Grid grid  

    """
    return _pysgpp_swig.createOperationLTwoDotProduct(grid)

def createOperationLTwoDotExplicit(*args) -> "sgpp::base::OperationMatrix *":
    r"""


    Overloaded function
    -------------------
    * `createOperationLTwoDotExplicit(m, grid) -> base::OperationMatrix *`  

        Factory method, returning an OperationLTwoDotExplicit (OperationMatrix) for
        the grid at hand.  

        Note: object has to be freed after use. The DataMatrix m is used to store
        the the matrix and is not destroyed if the OperationMatrix is destroyed.  

        Parameters:  
        * `grid` :  
            Grid which is to be used  
        * `m` :  
            DataMatrix in which the data is stored  

        Returns:
        Pointer to the new OperationMatrix object for the Grid grid  

    * `createOperationLTwoDotExplicit(grid) -> base::OperationMatrix *`  

        Factory method, returning an OperationLTwoDotExplicit (OperationMatrix) for
        the grid at hand.  

        Note: object has to be freed after use.  

        Parameters:  
        * `grid` :  
            Grid which is to be used  

        Returns:
        Pointer to the new OperationMatrix object for the Grid grid  

    """
    return _pysgpp_swig.createOperationLTwoDotExplicit(*args)

def createOperationLaplaceEnhanced(*args) -> "sgpp::base::OperationMatrix *":
    r"""


    Overloaded function
    -------------------
    * `createOperationLaplaceEnhanced(grid) -> base::OperationMatrix *`  

        Factory method, returning an OperationLaplace (OperationMatrix) for the grid
        at hand.  

        Note: object has to be freed after use.  

        This Laplacian is implemented by a multi-dimensional sweep operation  

        Parameters:  
        * `grid` :  
            Grid which is to be used  

        Returns:
        Pointer to the new OperationMatrix object for the Grid grid  

    * `createOperationLaplaceEnhanced(grid, coef) -> base::OperationMatrix *`  

        Factory method, returning an OperationLaplace (OperationMatrix) for the grid
        at hand.  

        Note: object has to be freed after use.  

        This Laplacian is implemented by a multi-dimensional sweep operation  

        Parameters:  
        * `grid` :  
            Grid which is to be used  
        * `coef` :  
            Coefficient vector for OperationLaplace  

        Returns:
        Pointer to the new OperationMatrix object for the Grid grid  

    """
    return _pysgpp_swig.createOperationLaplaceEnhanced(*args)
class OperationParabolicPDESolverSystemFreeBoundaries(OperationParabolicPDESolverSystem):
    r"""

    `OperationParabolicPDESolverSystemFreeBoundaries()`  

    Defines a System that is used to solve parabolic partial differential equations.  

    So an instance of this class has to pass to any ODE Solver used in SGpp.  

    $A \dot{u} = L \vec{u}$  

    A: mass matrix L: space discretization (L-Operator)  

    This class defines an elliptic problem in every timestep which is solved using
    an iterative SLE solver, that solving step is integrated in the ODE Solver.  

    Constructors
    ------------
    * `OperationParabolicPDESolverSystemFreeBoundaries()`  

        Constructor.  

    C++ includes: OperationParabolicPDESolverSystemFreeBoundaries.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationParabolicPDESolverSystemFreeBoundaries

# Register OperationParabolicPDESolverSystemFreeBoundaries in _pysgpp_swig:
_pysgpp_swig.OperationParabolicPDESolverSystemFreeBoundaries_swigregister(OperationParabolicPDESolverSystemFreeBoundaries)

class OperationMatrixLTwoDotExplicitPeriodic(OperationMatrix):
    r"""

    `OperationMatrixLTwoDotExplicitPeriodic(m, grid)`  
    `OperationMatrixLTwoDotExplicitPeriodic(grid)`  

    Explicit representation of the matrix $(\Phi_i,\Phi_j)_{L2}$ for a sparse
    grid.  

    Constructors
    ------------
    * `OperationMatrixLTwoDotExplicitPeriodic(m, grid)`  

        Constructor that uses a external matrix pointer to construct the matrix,.  

        Parameters:  
        * `m` :  
            pointer to datamatrix of size (number of grid point) x (number of grid
            points)  
        * `grid` :  
            the sparse grid  

    * `OperationMatrixLTwoDotExplicitPeriodic(grid)`  

        Constructor that creates an own matrix.  

        Parameters:  
        * `grid` :  
            the sparse grid  

    C++ includes: OperationMatrixLTwoDotExplicitPeriodic.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `OperationMatrixLTwoDotExplicitPeriodic(m, grid)`  

            Constructor that uses a external matrix pointer to construct the matrix,.  

            Parameters:  
            * `m` :  
                pointer to datamatrix of size (number of grid point) x (number of grid
                points)  
            * `grid` :  
                the sparse grid  

        * `OperationMatrixLTwoDotExplicitPeriodic(grid)`  

            Constructor that creates an own matrix.  

            Parameters:  
            * `grid` :  
                the sparse grid  

        """
        _pysgpp_swig.OperationMatrixLTwoDotExplicitPeriodic_swiginit(self, _pysgpp_swig.new_OperationMatrixLTwoDotExplicitPeriodic(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OperationMatrixLTwoDotExplicitPeriodic

# Register OperationMatrixLTwoDotExplicitPeriodic in _pysgpp_swig:
_pysgpp_swig.OperationMatrixLTwoDotExplicitPeriodic_swigregister(OperationMatrixLTwoDotExplicitPeriodic)

class OperationMatrixLTwoDotPeriodic(OperationMatrix):
    r"""

    `OperationMatrixLTwoDotPeriodic(gridStorage)`  

    Implements the standard L 2 scalar product on periodic grids.  

    Constructors
    ------------
    * `OperationMatrixLTwoDotPeriodic(gridStorage)`  

        Constructor.  

        Parameters:  
        * `gridStorage` :  
            pointer to the GridStorage of the grid  

    C++ includes: OperationMatrixLTwoDotPeriodic.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, gridStorage: "HashGridStorage"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `gridStorage` :  
            pointer to the GridStorage of the grid  

        """
        _pysgpp_swig.OperationMatrixLTwoDotPeriodic_swiginit(self, _pysgpp_swig.new_OperationMatrixLTwoDotPeriodic(gridStorage))
    __swig_destroy__ = _pysgpp_swig.delete_OperationMatrixLTwoDotPeriodic

# Register OperationMatrixLTwoDotPeriodic in _pysgpp_swig:
_pysgpp_swig.OperationMatrixLTwoDotPeriodic_swigregister(OperationMatrixLTwoDotPeriodic)

class SGSolver(object):
    r"""

    `SGSolver(nMaximumIterations, epsilon)`  

    Abstract class that defines a solver used in Sparse Grids Applications.  

    Constructors
    ------------
    * `SGSolver(nMaximumIterations, epsilon)`  

        Std-Constructor.  

        Parameters:  
        * `nMaximumIterations` :  
            number of maximum executed iterations  
        * `epsilon` :  
            the final error in the iterative solver, or the size of one timestep  

    C++ includes: SGSolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nMaximumIterations: "size_t", epsilon: "double"):
        r"""


        Std-Constructor.  

        Parameters
        ----------
        * `nMaximumIterations` :  
            number of maximum executed iterations  
        * `epsilon` :  
            the final error in the iterative solver, or the size of one timestep  

        """
        _pysgpp_swig.SGSolver_swiginit(self, _pysgpp_swig.new_SGSolver(nMaximumIterations, epsilon))
    __swig_destroy__ = _pysgpp_swig.delete_SGSolver

    def getNumberIterations(self) -> "size_t":
        r"""


        function that returns the number of needed solve steps  

        Returns
        -------
        the number of needed solve steps of the sovler  

        """
        return _pysgpp_swig.SGSolver_getNumberIterations(self)

    def getResiduum(self) -> "double":
        r"""


        function the returns the residuum (current or final), error of the solver  

        Returns
        -------
        the residuum  

        """
        return _pysgpp_swig.SGSolver_getResiduum(self)

    def setMaxIterations(self, nIterations: "size_t") -> "void":
        r"""


        resets the number of maximum iterations  

        Parameters
        ----------
        * `nIterations` :  
            the new number of maximum iterations  

        """
        return _pysgpp_swig.SGSolver_setMaxIterations(self, nIterations)

    def setEpsilon(self, eps: "double") -> "void":
        r"""


        resets the epsilon, that is used in the SGSolver  

        Parameters
        ----------
        * `eps` :  
            the new value of epsilon  

        """
        return _pysgpp_swig.SGSolver_setEpsilon(self, eps)

    def getEpsilon(self) -> "double":
        r"""


        gets the the epsilon, that is used in the SGSolver  

        Returns
        -------
        the epsilon, used in the solver  

        """
        return _pysgpp_swig.SGSolver_getEpsilon(self)

# Register SGSolver in _pysgpp_swig:
_pysgpp_swig.SGSolver_swigregister(SGSolver)

DEFAULT_RES_THRESHOLD = _pysgpp_swig.DEFAULT_RES_THRESHOLD
class SolverModuleSLESolver(SGSolver):
    r"""

    `SLESolver(imax, epsilon)`  

    Constructors
    ------------
    * `SLESolver(imax, epsilon)`  

        Std-Constructor.  

        Parameters:  
        * `imax` :  
            number of maximum executed iterations  
        * `epsilon` :  
            the final error in the iterative solver  

    C++ includes: SLESolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SolverModuleSLESolver

    def solve(self, SystemMatrix: "OperationMatrix", alpha: "DataVector", b: "DataVector", reuse: "bool"=False, verbose: "bool"=False, max_threshold: "double"=-1.0) -> "void":
        r"""


        Pure virtual Function that defines a solve method for an iterative solver.  

        Parameters
        ----------
        * `SystemMatrix` :  
            reference to an sgpp::base::OperationMatrix Object that implements the
            matrix vector multiplication  
        * `alpha` :  
            the sparse grid's coefficients which have to be determined  
        * `b` :  
            the right hand side of the system of linear equations  
        * `reuse` :  
            identifies if the alphas, stored in alpha at calling time, should be reused  
        * `verbose` :  
            prints information during execution of the solver  
        * `max_threshold` :  
            additional abort criteria for solver, default value is 10^-9!  

        """
        return _pysgpp_swig.SolverModuleSLESolver_solve(self, SystemMatrix, alpha, b, reuse, verbose, max_threshold)

# Register SolverModuleSLESolver in _pysgpp_swig:
_pysgpp_swig.SolverModuleSLESolver_swigregister(SolverModuleSLESolver)

class ODESolver(SGSolver):
    r"""

    `ODESolver(imax, timestepSize)`  

    Constructors
    ------------
    * `ODESolver(imax, timestepSize)`  

        Std-Constructor.  

        Parameters:  
        * `imax` :  
            number of maximum executed iterations  
        * `timestepSize` :  
            the size of one timestep  

    C++ includes: ODESolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_ODESolver

    def solve(self, LinearSystemSolver: "SolverModuleSLESolver", System: "OperationParabolicPDESolverSystem", bIdentifyLastStep: "bool"=False, verbose: "bool"=False) -> "void":
        r"""


        Pure virtual Function that defines a solve method for an ODE solver.  

        Parameters
        ----------
        * `LinearSystemSolver` :  
            reference to an instance of a linear system solver that is used by this ODE
            solver  
        * `System` :  
            reference to an sgpp::base::OperationMatrix Object that implements the
            matrix vector multiplication  
        * `bIdentifyLastStep` :  
            set this to true to tell System the last step  
        * `verbose` :  
            prints information during execution of the solver  

        """
        return _pysgpp_swig.ODESolver_solve(self, LinearSystemSolver, System, bIdentifyLastStep, verbose)

# Register ODESolver in _pysgpp_swig:
_pysgpp_swig.ODESolver_swigregister(ODESolver)

class ConjugateGradients(SolverModuleSLESolver):
    r"""

    `ConjugateGradients(imax, epsilon)`  

    Constructors
    ------------
    * `ConjugateGradients(imax, epsilon)`  

        Std-Constructor.  

    C++ includes: ConjugateGradients.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, imax: "size_t", epsilon: "double"):
        r"""


        Std-Constructor.  

        """
        if self.__class__ == ConjugateGradients:
            _self = None
        else:
            _self = self
        _pysgpp_swig.ConjugateGradients_swiginit(self, _pysgpp_swig.new_ConjugateGradients(_self, imax, epsilon))
    __swig_destroy__ = _pysgpp_swig.delete_ConjugateGradients

    def solve(self, SystemMatrix: "OperationMatrix", alpha: "DataVector", b: "DataVector", reuse: "bool"=False, verbose: "bool"=False, max_threshold: "double"=-1.0) -> "void":
        r"""


        Pure virtual Function that defines a solve method for an iterative solver.  

        Parameters
        ----------
        * `SystemMatrix` :  
            reference to an sgpp::base::OperationMatrix Object that implements the
            matrix vector multiplication  
        * `alpha` :  
            the sparse grid's coefficients which have to be determined  
        * `b` :  
            the right hand side of the system of linear equations  
        * `reuse` :  
            identifies if the alphas, stored in alpha at calling time, should be reused  
        * `verbose` :  
            prints information during execution of the solver  
        * `max_threshold` :  
            additional abort criteria for solver, default value is 10^-9!  

        """
        return _pysgpp_swig.ConjugateGradients_solve(self, SystemMatrix, alpha, b, reuse, verbose, max_threshold)

    def starting(self) -> "void":
        r"""


        function that signals the start of the CG method (used in python)  

        """
        return _pysgpp_swig.ConjugateGradients_starting(self)

    def calcStarting(self) -> "void":
        r"""


        function that signals the start of the calculation of the CG method (used in
        python)  

        """
        return _pysgpp_swig.ConjugateGradients_calcStarting(self)

    def iterationComplete(self) -> "void":
        r"""


        function that signals that one iteration step of the CG method has been
        completed (used in python)  

        """
        return _pysgpp_swig.ConjugateGradients_iterationComplete(self)

    def complete(self) -> "void":
        r"""


        function that signals the finish of the cg method (used in python)  

        """
        return _pysgpp_swig.ConjugateGradients_complete(self)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_ConjugateGradients(self)
        return weakref.proxy(self)

# Register ConjugateGradients in _pysgpp_swig:
_pysgpp_swig.ConjugateGradients_swigregister(ConjugateGradients)

class SolverModuleBiCGStab(SolverModuleSLESolver):
    r"""

    `BiCGStab(imax, epsilon)`  

    Constructors
    ------------
    * `BiCGStab(imax, epsilon)`  

        Std-Constructor.  

    C++ includes: BiCGStab.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, imax: "size_t", epsilon: "double"):
        r"""


        Std-Constructor.  

        """
        _pysgpp_swig.SolverModuleBiCGStab_swiginit(self, _pysgpp_swig.new_SolverModuleBiCGStab(imax, epsilon))
    __swig_destroy__ = _pysgpp_swig.delete_SolverModuleBiCGStab

    def solve(self, SystemMatrix: "OperationMatrix", alpha: "DataVector", b: "DataVector", reuse: "bool"=False, verbose: "bool"=False, max_threshold: "double"=-1.0) -> "void":
        r"""


        max_threashold is ignored in this solver  

        Reference: http://www.iue.tuwien.ac.at/phd/heinreichsberger/node70.html
        http://www.numerik.math.tu-graz.ac.at/kurse/lgs/SIMNET6.pdf http://netlib.org  

        """
        return _pysgpp_swig.SolverModuleBiCGStab_solve(self, SystemMatrix, alpha, b, reuse, verbose, max_threshold)

# Register SolverModuleBiCGStab in _pysgpp_swig:
_pysgpp_swig.SolverModuleBiCGStab_swigregister(SolverModuleBiCGStab)

class Euler(ODESolver):
    r"""

    `Euler(Mode, imax, timestepSize, generateAnimation=false, screen=nullptr)`  

    This class implements the explicit and implicit Euler method for solving
    ordinary partial equations.  

    Constructors
    ------------
    * `Euler(Mode, imax, timestepSize, generateAnimation=false, screen=nullptr)`  

        Std-Constructer.  

        Parameters:  
        * `Mode` :  
            the mode of the euler that should be executed, must be ExEul or ImEul  
        * `imax` :  
            number of maximum executed iterations  
        * `timestepSize` :  
            the size of one timestep  
        * `generateAnimation` :  
            set this, if you want to create a grid evaluation in every time step, in
            order to create an animation  
        * `screen` :  
            possible pointer to a sgpp::base::ScreenOutput object  

    C++ includes: Euler.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, Mode: "std::string", imax: "size_t", timestepSize: "double", generateAnimation: "bool"=False, screen: "ScreenOutput"=None):
        r"""


        Std-Constructer.  

        Parameters
        ----------
        * `Mode` :  
            the mode of the euler that should be executed, must be ExEul or ImEul  
        * `imax` :  
            number of maximum executed iterations  
        * `timestepSize` :  
            the size of one timestep  
        * `generateAnimation` :  
            set this, if you want to create a grid evaluation in every time step, in
            order to create an animation  
        * `screen` :  
            possible pointer to a sgpp::base::ScreenOutput object  

        """
        _pysgpp_swig.Euler_swiginit(self, _pysgpp_swig.new_Euler(Mode, imax, timestepSize, generateAnimation, screen))
    __swig_destroy__ = _pysgpp_swig.delete_Euler

    def solve(self, LinearSystemSolver: "SolverModuleSLESolver", System: "OperationParabolicPDESolverSystem", bIdentifyLastStep: "bool"=False, verbose: "bool"=False) -> "void":
        r"""


        Pure virtual Function that defines a solve method for an ODE solver.  

        Parameters
        ----------
        * `LinearSystemSolver` :  
            reference to an instance of a linear system solver that is used by this ODE
            solver  
        * `System` :  
            reference to an sgpp::base::OperationMatrix Object that implements the
            matrix vector multiplication  
        * `bIdentifyLastStep` :  
            set this to true to tell System the last step  
        * `verbose` :  
            prints information during execution of the solver  

        """
        return _pysgpp_swig.Euler_solve(self, LinearSystemSolver, System, bIdentifyLastStep, verbose)

# Register Euler in _pysgpp_swig:
_pysgpp_swig.Euler_swigregister(Euler)

class CrankNicolson(ODESolver):
    r"""

    `CrankNicolson(nTimesteps, timestepSize, screen=nullptr)`  

    This class implements the Crank-Nicolson method for solving ordinary partial
    equations.  

    For solving the system of linear equations the already implemented CG-method is
    used  

    Constructors
    ------------
    * `CrankNicolson(nTimesteps, timestepSize, screen=nullptr)`  

        Std-Constructer.  

        Parameters:  
        * `nTimesteps` :  
            number of maximum executed iterations  
        * `timestepSize` :  
            the size of one timestep  
        * `screen` :  
            possible pointer to a sgpp::base::ScreenOutput object  

    C++ includes: CrankNicolson.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nTimesteps: "size_t", timestepSize: "double", screen: "ScreenOutput"=None):
        r"""


        Std-Constructer.  

        Parameters
        ----------
        * `nTimesteps` :  
            number of maximum executed iterations  
        * `timestepSize` :  
            the size of one timestep  
        * `screen` :  
            possible pointer to a sgpp::base::ScreenOutput object  

        """
        _pysgpp_swig.CrankNicolson_swiginit(self, _pysgpp_swig.new_CrankNicolson(nTimesteps, timestepSize, screen))
    __swig_destroy__ = _pysgpp_swig.delete_CrankNicolson

    def solve(self, LinearSystemSolver: "SolverModuleSLESolver", System: "OperationParabolicPDESolverSystem", bIdentifyLastStep: "bool"=False, verbose: "bool"=False) -> "void":
        r"""


        Pure virtual Function that defines a solve method for an ODE solver.  

        Parameters
        ----------
        * `LinearSystemSolver` :  
            reference to an instance of a linear system solver that is used by this ODE
            solver  
        * `System` :  
            reference to an sgpp::base::OperationMatrix Object that implements the
            matrix vector multiplication  
        * `bIdentifyLastStep` :  
            set this to true to tell System the last step  
        * `verbose` :  
            prints information during execution of the solver  

        """
        return _pysgpp_swig.CrankNicolson_solve(self, LinearSystemSolver, System, bIdentifyLastStep, verbose)

# Register CrankNicolson in _pysgpp_swig:
_pysgpp_swig.CrankNicolson_swigregister(CrankNicolson)

SLESolverType_CG = _pysgpp_swig.SLESolverType_CG
SLESolverType_BiCGSTAB = _pysgpp_swig.SLESolverType_BiCGSTAB
SLESolverType_FISTA = _pysgpp_swig.SLESolverType_FISTA
class SLESolverConfiguration(object):
    r"""


    C++ includes: TypesSolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type_ = property(_pysgpp_swig.SLESolverConfiguration_type__get, _pysgpp_swig.SLESolverConfiguration_type__set)
    eps_ = property(_pysgpp_swig.SLESolverConfiguration_eps__get, _pysgpp_swig.SLESolverConfiguration_eps__set)
    maxIterations_ = property(_pysgpp_swig.SLESolverConfiguration_maxIterations__get, _pysgpp_swig.SLESolverConfiguration_maxIterations__set)
    threshold_ = property(_pysgpp_swig.SLESolverConfiguration_threshold__get, _pysgpp_swig.SLESolverConfiguration_threshold__set)
    verbose_ = property(_pysgpp_swig.SLESolverConfiguration_verbose__get, _pysgpp_swig.SLESolverConfiguration_verbose__set)

    def __init__(self):
        _pysgpp_swig.SLESolverConfiguration_swiginit(self, _pysgpp_swig.new_SLESolverConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_SLESolverConfiguration

# Register SLESolverConfiguration in _pysgpp_swig:
_pysgpp_swig.SLESolverConfiguration_swigregister(SLESolverConfiguration)

class SLESolverSPConfiguration(object):
    r"""


    C++ includes: TypesSolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type_ = property(_pysgpp_swig.SLESolverSPConfiguration_type__get, _pysgpp_swig.SLESolverSPConfiguration_type__set)
    eps_ = property(_pysgpp_swig.SLESolverSPConfiguration_eps__get, _pysgpp_swig.SLESolverSPConfiguration_eps__set)
    maxIterations_ = property(_pysgpp_swig.SLESolverSPConfiguration_maxIterations__get, _pysgpp_swig.SLESolverSPConfiguration_maxIterations__set)
    threshold_ = property(_pysgpp_swig.SLESolverSPConfiguration_threshold__get, _pysgpp_swig.SLESolverSPConfiguration_threshold__set)

    def __init__(self):
        _pysgpp_swig.SLESolverSPConfiguration_swiginit(self, _pysgpp_swig.new_SLESolverSPConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_SLESolverSPConfiguration

# Register SLESolverSPConfiguration in _pysgpp_swig:
_pysgpp_swig.SLESolverSPConfiguration_swigregister(SLESolverSPConfiguration)

class SLESolverTypeParser(object):
    r"""


    Convenience class to convert strings to sgpp::solver::SLESolverType and generate
    string representations for values of sgpp::solver::SLESolverType.  

    C++ includes: SLESolverTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::solver::SLESolverType":
        r"""


        Convert strings to values sgpp::solver::SLESolverType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a sgpp::solver::SLESolverType.  

        Returns
        -------
        the corresponding sgpp::solver::SLESolverType.  

        """
        return _pysgpp_swig.SLESolverTypeParser_parse(input)

    @staticmethod
    def toString(type: "sgpp::solver::SLESolverType") -> "std::string const &":
        r"""


        generate string representations for values of sgpp::solver::SLESolverType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::solver::SLESolverType.  

        """
        return _pysgpp_swig.SLESolverTypeParser_toString(type)

    def __init__(self):
        _pysgpp_swig.SLESolverTypeParser_swiginit(self, _pysgpp_swig.new_SLESolverTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_SLESolverTypeParser

# Register SLESolverTypeParser in _pysgpp_swig:
_pysgpp_swig.SLESolverTypeParser_swigregister(SLESolverTypeParser)

def SLESolverTypeParser_parse(input: "std::string const &") -> "sgpp::solver::SLESolverType":
    r"""


    Convert strings to values sgpp::solver::SLESolverType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a sgpp::solver::SLESolverType.  

    Returns
    -------
    the corresponding sgpp::solver::SLESolverType.  

    """
    return _pysgpp_swig.SLESolverTypeParser_parse(input)

def SLESolverTypeParser_toString(type: "sgpp::solver::SLESolverType") -> "std::string const &":
    r"""


    generate string representations for values of sgpp::solver::SLESolverType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::solver::SLESolverType.  

    """
    return _pysgpp_swig.SLESolverTypeParser_toString(type)

class Random(object):
    r"""


    Wraps the random generator to use.  

    Ensures that it is is seeded correctly.  

    C++ includes: Random.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def seed(*args) -> "void":
        r"""


        Manually seed the generator with a given seed.  

        Parameters
        ----------
        * `seed_value` :  
            the seed to use.  

        """
        return _pysgpp_swig.Random_seed(*args)

    @staticmethod
    def random_uint64() -> "std::uint64_t":
        r"""


        returns a random integer value in [0, RAND_MAX)  

        """
        return _pysgpp_swig.Random_random_uint64()

    @staticmethod
    def random_double() -> "double":
        r"""


        returns a random double value in [0, 1)  

        """
        return _pysgpp_swig.Random_random_double()

    def __init__(self):
        _pysgpp_swig.Random_swiginit(self, _pysgpp_swig.new_Random())
    __swig_destroy__ = _pysgpp_swig.delete_Random

# Register Random in _pysgpp_swig:
_pysgpp_swig.Random_swigregister(Random)

def Random_seed(*args) -> "void":
    r"""


    Manually seed the generator with a given seed.  

    Parameters
    ----------
    * `seed_value` :  
        the seed to use.  

    """
    return _pysgpp_swig.Random_seed(*args)

def Random_random_uint64() -> "std::uint64_t":
    r"""


    returns a random integer value in [0, RAND_MAX)  

    """
    return _pysgpp_swig.Random_random_uint64()

def Random_random_double() -> "double":
    r"""


    returns a random double value in [0, 1)  

    """
    return _pysgpp_swig.Random_random_double()

class SampleGenerator(object):
    r"""

    `SampleGenerator(dimensions, seed=std::mt19937_64::default_seed)`  

    Base class for all types of MonteCarlo sample generators used in SGPP.  

    A sample generator is used to generate one or multiple n-dimensional sample
    vectors inside the n-dimensional unit cube.  

    Constructors
    ------------
    * `SampleGenerator(dimensions, seed=std::mt19937_64::default_seed)`  

        Standard constructor.  

        Parameters:  
        * `dimensions` :  
            number of dimensions used for sample generation  
        * `seed` :  
            custom seed (defaults to default seed of mt19937_64)  

    C++ includes: SampleGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Standard constructor.  

        Parameters
        ----------
        * `dimensions` :  
            number of dimensions used for sample generation  
        * `seed` :  
            custom seed (defaults to default seed of mt19937_64)  

        """
        _pysgpp_swig.SampleGenerator_swiginit(self, _pysgpp_swig.new_SampleGenerator(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SampleGenerator

    def getSample(self, sample: "DataVector") -> "void":
        r"""


        Abstract Method which has to be implemented by each sample generator One single
        sample is generated by this method.  

        The dimensionality of the parameter has to fit the number of dimensions used in
        this sample generator.  

        Parameters
        ----------
        * `sample` :  
            provide a DataVector to store the generated sample.  

        """
        return _pysgpp_swig.SampleGenerator_getSample(self, sample)

    def getSamples(self, samples: "DataMatrix") -> "void":
        r"""


        This method generates a given number of samples.  

        The resulting samples are written to the parameter DataMatrix. Therefore the
        number of cols has to fit the number of dimensions whereas the number of rows
        defines the number of generated samples.  

        Parameters
        ----------
        * `samples` :  
            provide a DataMatrix to hold the generated samples  

        """
        return _pysgpp_swig.SampleGenerator_getSamples(self, samples)

    def getDimensions(self) -> "size_t":
        r"""


        Returns
        -------
        current number of dimensions used for sample generation  

        """
        return _pysgpp_swig.SampleGenerator_getDimensions(self)

    def setDimensions(self, dimensions: "size_t") -> "void":
        r"""


        Sets the number of dimensions for sample generation to the given value.  

        Parameters
        ----------
        * `dimensions` :  
            new number of dimensions  

        """
        return _pysgpp_swig.SampleGenerator_setDimensions(self, dimensions)

# Register SampleGenerator in _pysgpp_swig:
_pysgpp_swig.SampleGenerator_swigregister(SampleGenerator)

class NaiveSampleGenerator(SampleGenerator):
    r"""

    `NaiveSampleGenerator(dimension, seed=std::mt19937_64::default_seed)`  

    The class NaiveSampleGenerator implements a simple MonteCarlo sample generator.  

    A sample is generated using the standard random number generator from cmath and
    transforming the values to double range 0.0 to 1.0.  

    Constructors
    ------------
    * `NaiveSampleGenerator(dimension, seed=std::mt19937_64::default_seed)`  

        Standard constructor.  

        Parameters:  
        * `dimension` :  
            number of dimensions used for sample generation  
        * `seed` :  
            custom seed (defaults to default seed of mt19937_64)  

    C++ includes: NaiveSampleGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Standard constructor.  

        Parameters
        ----------
        * `dimension` :  
            number of dimensions used for sample generation  
        * `seed` :  
            custom seed (defaults to default seed of mt19937_64)  

        """
        _pysgpp_swig.NaiveSampleGenerator_swiginit(self, _pysgpp_swig.new_NaiveSampleGenerator(*args))
    __swig_destroy__ = _pysgpp_swig.delete_NaiveSampleGenerator

# Register NaiveSampleGenerator in _pysgpp_swig:
_pysgpp_swig.NaiveSampleGenerator_swigregister(NaiveSampleGenerator)

class LatinHypercubeSampleGenerator(SampleGenerator):
    r"""

    `LatinHypercubeSampleGenerator(dimensions, numberOfStrata,
        seed=std::mt19937_64::default_seed)`  

    The class NaiveSampleGenerator implements a simple MonteCarlo sample generator.  

    A sample is generated using the standard random number generator from cmath and
    transforming the values to double range 0.0 to 1.0.  

    Constructors
    ------------
    * `LatinHypercubeSampleGenerator(dimensions, numberOfStrata,
        seed=std::mt19937_64::default_seed)`  

        Standard constructor.  

        Parameters:  
        * `dimensions` :  
            number of dimensions used for sample generation  
        * `numberOfStrata` :  
            number of strata  
        * `seed` :  
            custom seed (defaults to default seed of mt19937_64)  

    C++ includes: LatinHypercubeSampleGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Standard constructor.  

        Parameters
        ----------
        * `dimensions` :  
            number of dimensions used for sample generation  
        * `numberOfStrata` :  
            number of strata  
        * `seed` :  
            custom seed (defaults to default seed of mt19937_64)  

        """
        _pysgpp_swig.LatinHypercubeSampleGenerator_swiginit(self, _pysgpp_swig.new_LatinHypercubeSampleGenerator(*args))
    __swig_destroy__ = _pysgpp_swig.delete_LatinHypercubeSampleGenerator

# Register LatinHypercubeSampleGenerator in _pysgpp_swig:
_pysgpp_swig.LatinHypercubeSampleGenerator_swigregister(LatinHypercubeSampleGenerator)

class StratifiedSampleGenerator(SampleGenerator):
    r"""

    `StratifiedSampleGenerator(strataPerDimension,
        seed=std::mt19937_64::default_seed)`  

    The class StratifiedSampleGenerator subdivides every dimension in a given number
    of strata.  

    For each strata one sample point is generated. In case one sample has already
    been generated for every strata, the next requested sample will be placed into
    the first strata.  

    Constructors
    ------------
    * `StratifiedSampleGenerator(strataPerDimension,
        seed=std::mt19937_64::default_seed)`  

        Standard constructor.  

        Parameters:  
        * `strataPerDimension` :  
            array holding the number of strata used to subdivide the specific
            dimension  
        * `seed` :  
            custom seed (defaults to default seed of mt19937_64)  

    C++ includes: StratifiedSampleGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Standard constructor.  

        Parameters
        ----------
        * `strataPerDimension` :  
            array holding the number of strata used to subdivide the specific dimension  
        * `seed` :  
            custom seed (defaults to default seed of mt19937_64)  

        """
        _pysgpp_swig.StratifiedSampleGenerator_swiginit(self, _pysgpp_swig.new_StratifiedSampleGenerator(*args))
    __swig_destroy__ = _pysgpp_swig.delete_StratifiedSampleGenerator

# Register StratifiedSampleGenerator in _pysgpp_swig:
_pysgpp_swig.StratifiedSampleGenerator_swigregister(StratifiedSampleGenerator)

class HaltonSampleGenerator(SampleGenerator):
    r"""

    `HaltonSampleGenerator(dimension, seed=std::mt19937_64::default_seed)`  

    Constructors
    ------------
    * `HaltonSampleGenerator(dimension, seed=std::mt19937_64::default_seed)`  

        Standard constructor.  

        Parameters:  
        * `dimension` :  
            number of dimensions used for sample generation  
        * `seed` :  
            custom seed (defaults to default seed of mt19937_64)  

    C++ includes: HaltonSampleGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Standard constructor.  

        Parameters
        ----------
        * `dimension` :  
            number of dimensions used for sample generation  
        * `seed` :  
            custom seed (defaults to default seed of mt19937_64)  

        """
        _pysgpp_swig.HaltonSampleGenerator_swiginit(self, _pysgpp_swig.new_HaltonSampleGenerator(*args))
    __swig_destroy__ = _pysgpp_swig.delete_HaltonSampleGenerator

# Register HaltonSampleGenerator in _pysgpp_swig:
_pysgpp_swig.HaltonSampleGenerator_swigregister(HaltonSampleGenerator)


def createOperationQuadratureMCAdvanced(*args) -> "sgpp::quadrature::OperationQuadratureMCAdvanced *":
    r"""


    Creates an OperationQuadratureMCAdvanced.  

    Parameters
    ----------
    * `grid` :  
        Reference to the grid object  
    * `numberOfSamples` :  
        Number of Monte Carlo samples  
    * `seed` :  
        Custom seed (defaults to default seed of mt19937_64)  

    """
    return _pysgpp_swig.createOperationQuadratureMCAdvanced(*args)

def omp_set_num_threads(num_threads: "int") -> "void":
    return _pysgpp_swig.omp_set_num_threads(num_threads)
class OptFuzzyInterval(object):
    r"""

    `FuzzyInterval(other)`  
    `FuzzyInterval(supportLowerBound, supportUpperBound,
        numberOfIntegralSamples=DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES)`  

    Abstract class for a fuzzy interval.  

    A fuzzy set is the graph $\tilde{x} = \{(x, \mu_{\tilde{x}}(x)) \mid x \in
    X\}$ of some function $\mu_{\tilde{x}}\colon X \to [0, 1]$ (membership
    function), where usually $X = [0, 1]$ (since we are working on sparse grids
    here). A fuzzy interval is convex if $\min(\mu_{\tilde{x}}(a),
    \mu_{\tilde{x}}(c)) \le \mu_{\tilde{x}}(b)$ for all $a, b, c \in X$ with
    $a \le b \le c$. A fuzzy interval is normalized if $\max \mu_{\tilde{x}} =
    1$. A fuzzy interval is a convex and normalized fuzzy set with piecewise
    continuous membership function.  

    For some given $\alpha \in [0, 1]$, the confidence interval of level $\alpha$
    or the $\alpha$-cut is defined as $(\tilde{x})_\alpha = \{x \in X \mid
    \mu_{\tilde{x}}(x) \ge \alpha\}$ for $\alpha > 0$ and
    $(\tilde{x})_\alpha = \mathrm{supp}(\mu_{\tilde{x}})$ for $\alpha = 0$.
    The confidence intervals of fuzzy intervals are always nested closed intervals,
    i.e., $(\tilde{x})_\alpha = [a, b]$ for some $a \le b$ and
    $(\tilde{x})_{\alpha_1} \supset (\tilde{x})_{\alpha_2}$ for $\alpha_1 \le
    \alpha_2$.  

    Constructors
    ------------
    * `FuzzyInterval(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            other fuzzy interval  

    * `FuzzyInterval(supportLowerBound, supportUpperBound,
        numberOfIntegralSamples=DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES)`  

        Constructor.  

        Needs the support of the fuzzy interval (which is always a closed interval,
        so it suffices to supply lower and upper bound).  

        Parameters:  
        * `supportLowerBound` :  
            lower bound of the support  
        * `supportUpperBound` :  
            upper bound of the support  
        * `numberOfIntegralSamples` :  
            number of samples to compute norms  

    C++ includes: FuzzyInterval.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NormMode_ViaMembershipFunction = _pysgpp_swig.OptFuzzyInterval_NormMode_ViaMembershipFunction
    NormMode_ViaConfidenceInterval = _pysgpp_swig.OptFuzzyInterval_NormMode_ViaConfidenceInterval
    DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES = _pysgpp_swig.OptFuzzyInterval_DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `FuzzyInterval(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                other fuzzy interval  

        * `FuzzyInterval(supportLowerBound, supportUpperBound,
            numberOfIntegralSamples=DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES)`  

            Constructor.  

            Needs the support of the fuzzy interval (which is always a closed interval,
            so it suffices to supply lower and upper bound).  

            Parameters:  
            * `supportLowerBound` :  
                lower bound of the support  
            * `supportUpperBound` :  
                upper bound of the support  
            * `numberOfIntegralSamples` :  
                number of samples to compute norms  

        """
        if self.__class__ == OptFuzzyInterval:
            _self = None
        else:
            _self = self
        _pysgpp_swig.OptFuzzyInterval_swiginit(self, _pysgpp_swig.new_OptFuzzyInterval(_self, *args))
    __swig_destroy__ = _pysgpp_swig.delete_OptFuzzyInterval

    def evaluateMembershipFunction(self, x: "double") -> "double":
        r"""


        Pure virtual method to evaluate the membership function.  

        Parameters
        ----------
        * `x` :  
            $x \in X$  

        Returns
        -------
        $\mu_{\tilde{x}}(x) \in [0, 1]$  

        """
        return _pysgpp_swig.OptFuzzyInterval_evaluateMembershipFunction(self, x)

    def evaluateConfidenceIntervalLowerBound(self, alpha: "double") -> "double":
        r"""


        Pure virtual method to evaluate the lower bound of a confidence interval, which
        is always a closed interval $(\tilde{x})_\alpha = [a, b]$.  

        Parameters
        ----------
        * `alpha` :  
            $\alpha \in [0, 1]$  

        Returns
        -------
        $a \in X$  

        """
        return _pysgpp_swig.OptFuzzyInterval_evaluateConfidenceIntervalLowerBound(self, alpha)

    def evaluateConfidenceIntervalUpperBound(self, alpha: "double") -> "double":
        r"""


        Pure virtual method to evaluate the upper bound of a confidence interval, which
        is always a closed interval $(\tilde{x})_\alpha = [a, b]$.  

        Parameters
        ----------
        * `alpha` :  
            $\alpha \in [0, 1]$  

        Returns
        -------
        $b \in X$  

        """
        return _pysgpp_swig.OptFuzzyInterval_evaluateConfidenceIntervalUpperBound(self, alpha)

    def computeL1Norm(self, *args) -> "double":
        r"""


        Compute L1 norm of fuzzy interval.  

        Parameters
        ----------
        * `normMode` :  
            mode with which to compute the norm  

        Returns
        -------
        L1 norm  

        """
        return _pysgpp_swig.OptFuzzyInterval_computeL1Norm(self, *args)

    def computeL2Norm(self, *args) -> "double":
        r"""


        Compute L2 norm of fuzzy interval.  

        Parameters
        ----------
        * `normMode` :  
            mode with which to compute the norm  

        Returns
        -------
        L2 norm  

        """
        return _pysgpp_swig.OptFuzzyInterval_computeL2Norm(self, *args)

    def computeLinfNorm(self, *args) -> "double":
        r"""


        Compute Linf norm of fuzzy interval.  

        Parameters
        ----------
        * `normMode` :  
            mode with which to compute the norm  

        Returns
        -------
        Linf norm  

        """
        return _pysgpp_swig.OptFuzzyInterval_computeLinfNorm(self, *args)

    def computeL1Error(self, *args) -> "double":
        r"""


        Compute absolute L1 error to other fuzzy interval.  

        Parameters
        ----------
        * `other` :  
            other fuzzy interval  
        * `normMode` :  
            mode with which to compute the norms  

        Returns
        -------
        absolute L1 error  

        """
        return _pysgpp_swig.OptFuzzyInterval_computeL1Error(self, *args)

    def computeL2Error(self, *args) -> "double":
        r"""


        Compute absolute L2 error to other fuzzy interval.  

        Parameters
        ----------
        * `other` :  
            other fuzzy interval  
        * `normMode` :  
            mode with which to compute the norms  

        Returns
        -------
        absolute L2 error  

        """
        return _pysgpp_swig.OptFuzzyInterval_computeL2Error(self, *args)

    def computeLinfError(self, *args) -> "double":
        r"""


        Compute absolute Linf error to other fuzzy interval.  

        Parameters
        ----------
        * `other` :  
            other fuzzy interval  
        * `normMode` :  
            mode with which to compute the norms  

        Returns
        -------
        absolute Linf error  

        """
        return _pysgpp_swig.OptFuzzyInterval_computeLinfError(self, *args)

    def computeRelativeL1Error(self, *args) -> "double":
        r"""


        Compute relative L1 error to other fuzzy interval.  

        Parameters
        ----------
        * `other` :  
            other fuzzy interval  
        * `normMode` :  
            mode with which to compute the norms  

        Returns
        -------
        relative L1 error  

        """
        return _pysgpp_swig.OptFuzzyInterval_computeRelativeL1Error(self, *args)

    def computeRelativeL2Error(self, *args) -> "double":
        r"""


        Compute relative L2 error to other fuzzy interval.  

        Parameters
        ----------
        * `other` :  
            other fuzzy interval  
        * `normMode` :  
            mode with which to compute the norms  

        Returns
        -------
        relative L2 error  

        """
        return _pysgpp_swig.OptFuzzyInterval_computeRelativeL2Error(self, *args)

    def computeRelativeLinfError(self, *args) -> "double":
        r"""


        Compute relative Linf error to other fuzzy interval.  

        Parameters
        ----------
        * `other` :  
            other fuzzy interval  
        * `normMode` :  
            mode with which to compute the norms  

        Returns
        -------
        relative Linf error  

        """
        return _pysgpp_swig.OptFuzzyInterval_computeRelativeLinfError(self, *args)

    def getSupportLowerBound(self) -> "double":
        r"""


        Returns
        -------
        lower bound of the support  

        """
        return _pysgpp_swig.OptFuzzyInterval_getSupportLowerBound(self)

    def getSupportUpperBound(self) -> "double":
        r"""


        Returns
        -------
        upper bound of the support  

        """
        return _pysgpp_swig.OptFuzzyInterval_getSupportUpperBound(self)

    def getNumberOfIntegralSamples(self) -> "size_t":
        r"""


        Returns
        -------
        number of samples to compute norms  

        """
        return _pysgpp_swig.OptFuzzyInterval_getNumberOfIntegralSamples(self)

    def setNumberOfIntegralSamples(self, numberOfIntegralSamples: "size_t") -> "void":
        r"""


        Parameters
        ----------
        * `numberOfIntegralSamples` :  
            number of samples to compute norms  

        """
        return _pysgpp_swig.OptFuzzyInterval_setNumberOfIntegralSamples(self, numberOfIntegralSamples)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_OptFuzzyInterval(self)
        return weakref.proxy(self)

# Register OptFuzzyInterval in _pysgpp_swig:
_pysgpp_swig.OptFuzzyInterval_swigregister(OptFuzzyInterval)

class OptHashRefinementMultiple(HashRefinement):
    r"""


    Descendant of base::HashRefinement refining without the generation of
    hierarchical ancestors.  

    In SG++ grids (as in sgpp::base), every grid fulfills the "hierarchical
    ancestors" property, e.g. every gridpoint has a direct ancestor in every
    dimension whose level is > 1.  

    By using this refinement class, the property doesn't necessarily hold anymore.
    The original base::HashRefinement looks at the neigbors of a grid point to be
    refined. If a neighbor in a dimension and a direction (left/right) already
    exists, no new point is inserted. If it doesn't exist, it is inserted and all
    hierarchical ancestors are generated recursively.  

    HashRefinementMultiple instead inserts exactly $2d$ new grid points, if a point
    is to be refined (for Noboundary grids with $d$ being the number of dimensions).
    This is done by looking at neighbors of higher levels (closer to the point to be
    refined) and inserting the first neighbor that doesn't exist in the grid.
    Additionally, no hierarchical ancestors are creating by omitting the
    base::HashRefinement::createGridpoint() calls.  

    Grids without the "hierarchical ancestors" property don't allow most standard
    algorithms to be executed on them, therefore grids and basis functions are
    separated in this module from those in sgpp::base.  

    C++ includes: HashRefinementMultiple.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pysgpp_swig.OptHashRefinementMultiple_swiginit(self, _pysgpp_swig.new_OptHashRefinementMultiple())
    __swig_destroy__ = _pysgpp_swig.delete_OptHashRefinementMultiple

# Register OptHashRefinementMultiple in _pysgpp_swig:
_pysgpp_swig.OptHashRefinementMultiple_swigregister(OptHashRefinementMultiple)

class OptIterativeGridGenerator(object):
    r"""

    `IterativeGridGenerator(f, grid, N)`  

    Abstract base class for iterative grid generation methods.  

    Constructors
    ------------
    * `IterativeGridGenerator(f, grid, N)`  

        Constructor.  

        Do not destruct the grid before this object!  

        Parameters:  
        * `f` :  
            objective function  
        * `grid` :  
            grid (should be empty)  
        * `N` :  
            maximal number of grid points  

    C++ includes: IterativeGridGenerator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, f: "ScalarFunction", grid: "Grid", N: "size_t"):
        r"""


        Constructor.  

        Do not destruct the grid before this object!  

        Parameters
        ----------
        * `f` :  
            objective function  
        * `grid` :  
            grid (should be empty)  
        * `N` :  
            maximal number of grid points  

        """
        if self.__class__ == OptIterativeGridGenerator:
            _self = None
        else:
            _self = self
        _pysgpp_swig.OptIterativeGridGenerator_swiginit(self, _pysgpp_swig.new_OptIterativeGridGenerator(_self, f, grid, N))
    __swig_destroy__ = _pysgpp_swig.delete_OptIterativeGridGenerator

    def generate(self) -> "bool":
        r"""


        Pure virtual method for iterative grid generation.  

        Returns
        -------
        true on success, otherwise false  

        """
        return _pysgpp_swig.OptIterativeGridGenerator_generate(self)

    def getGrid(self) -> "sgpp::base::Grid &":
        r"""


        Returns
        -------
        underlying grid  

        """
        return _pysgpp_swig.OptIterativeGridGenerator_getGrid(self)

    def getFunctionValues(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        vector of function values at the grid points  

        """
        return _pysgpp_swig.OptIterativeGridGenerator_getFunctionValues(self)

    def printIterativeGridGenerator(self) -> "void":
        r"""


        Prints grid points and function values.  

        """
        return _pysgpp_swig.OptIterativeGridGenerator_printIterativeGridGenerator(self)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_OptIterativeGridGenerator(self)
        return weakref.proxy(self)

# Register OptIterativeGridGenerator in _pysgpp_swig:
_pysgpp_swig.OptIterativeGridGenerator_swigregister(OptIterativeGridGenerator)

class OptIterativeGridGeneratorRitterNovak(OptIterativeGridGenerator):
    r"""

    `IterativeGridGeneratorRitterNovak(f, grid, N, adaptivity=DEFAULT_ADAPTIVITY,
        initialLevel=DEFAULT_INITIAL_LEVEL, maxLevel=DEFAULT_MAX_LEVEL,
        powMethod=PowMethod::STD_POW)`  

    Iterative grid generation based on Ritter/Novak's refinement criterion.  

    Caution: This class uses HashRefinementMultiple, so it generates grids that
    don't meet the "hierarchical ancestors" requirement!  

    Literature: Erich Novak, Klaus Ritter. Global Optimization Using Hyperbolic
    Cross Points. In: Christodoulos A. Floudas, Panos M. Pardalos (eds.): State of
    the Art in Global Optimization, Computational Methods and Applications, Vol. 7.
    Springer 1996. DOI: 10.1007/978-1-4613-3437-8_2  

    See also: HashRefinementMultiple  

    Constructors
    ------------
    * `IterativeGridGeneratorRitterNovak(f, grid, N, adaptivity=DEFAULT_ADAPTIVITY,
        initialLevel=DEFAULT_INITIAL_LEVEL, maxLevel=DEFAULT_MAX_LEVEL,
        powMethod=PowMethod::STD_POW)`  

        Constructor.  

        Do not destruct the grid before this object!  

        Parameters:  
        * `f` :  
            objective function  
        * `grid` :  
            grid (should be empty)  
        * `N` :  
            maximal number of grid points  
        * `adaptivity` :  
            adaptivity between 0 and 1  
        * `initialLevel` :  
            level of initial regular sparse grid  
        * `maxLevel` :  
            maximal level of grid points  
        * `powMethod` :  
            exponentiation method (fastPow is faster than std::pow, but only
            approximative)  

    C++ includes: IterativeGridGeneratorRitterNovak.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_ADAPTIVITY = _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_DEFAULT_ADAPTIVITY
    DEFAULT_INITIAL_LEVEL = _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_DEFAULT_INITIAL_LEVEL
    DEFAULT_MAX_LEVEL = _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_DEFAULT_MAX_LEVEL
    PowMethod_STD_POW = _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_PowMethod_STD_POW
    PowMethod_FAST_POW = _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_PowMethod_FAST_POW

    def __init__(self, *args):
        r"""


        Constructor.  

        Do not destruct the grid before this object!  

        Parameters
        ----------
        * `f` :  
            objective function  
        * `grid` :  
            grid (should be empty)  
        * `N` :  
            maximal number of grid points  
        * `adaptivity` :  
            adaptivity between 0 and 1  
        * `initialLevel` :  
            level of initial regular sparse grid  
        * `maxLevel` :  
            maximal level of grid points  
        * `powMethod` :  
            exponentiation method (fastPow is faster than std::pow, but only
            approximative)  

        """
        _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_swiginit(self, _pysgpp_swig.new_OptIterativeGridGeneratorRitterNovak(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptIterativeGridGeneratorRitterNovak

    def getAdaptivity(self) -> "double":
        r"""


        Returns
        -------
        adaptivity between 0 and 1  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_getAdaptivity(self)

    def setAdaptivity(self, adaptivity: "double") -> "void":
        r"""


        Parameters
        ----------
        * `adaptivity` :  
            adaptivity between 0 and 1  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_setAdaptivity(self, adaptivity)

    def getInitialLevel(self) -> "sgpp::base::level_t":
        r"""


        Returns
        -------
        level of initial regular sparse grid  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_getInitialLevel(self)

    def setInitialLevel(self, initialLevel: "sgpp::base::level_t") -> "void":
        r"""


        Parameters
        ----------
        * `initialLevel` :  
            level of initial regular sparse grid  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_setInitialLevel(self, initialLevel)

    def getMaxLevel(self) -> "sgpp::base::level_t":
        r"""


        Returns
        -------
        maximal level of grid points  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_getMaxLevel(self)

    def setMaxLevel(self, maxLevel: "sgpp::base::level_t") -> "void":
        r"""


        Parameters
        ----------
        * `maxLevel` :  
            maximal level of grid points  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_setMaxLevel(self, maxLevel)

    def getPowMethod(self) -> "sgpp::optimization::IterativeGridGeneratorRitterNovak::PowMethod":
        r"""


        Returns
        -------
        exponentiation method  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_getPowMethod(self)

    def setPowMethod(self, powMethod: "sgpp::optimization::IterativeGridGeneratorRitterNovak::PowMethod") -> "void":
        r"""


        Parameters
        ----------
        * `powMethod` :  
            exponentiation method  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorRitterNovak_setPowMethod(self, powMethod)

# Register OptIterativeGridGeneratorRitterNovak in _pysgpp_swig:
_pysgpp_swig.OptIterativeGridGeneratorRitterNovak_swigregister(OptIterativeGridGeneratorRitterNovak)

class OptIterativeGridGeneratorFuzzyRitterNovak(OptIterativeGridGeneratorRitterNovak):
    r"""

    `IterativeGridGeneratorFuzzyRitterNovak(f, grid, N, xFuzzy,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS,
        adaptivity=DEFAULT_ADAPTIVITY, initialLevel=DEFAULT_INITIAL_LEVEL,
        maxLevel=DEFAULT_MAX_LEVEL, powMethod=PowMethod::STD_POW)`  

    Iterative grid generation based on Ritter/Novak's refinement criterion like
    IterativeGridGeneratorRitterNovak, but adapted for the use with fuzzy intervals.  

    Caution: This class uses HashRefinementMultiple, so it generates grids that
    don't meet the "hierarchical ancestors" requirement!  

    Literature: Julian Valentin. B-Splines for Sparse Grids: Algorithms and
    Application to Higher-Dimensional Optimization. PhD thesis, University of
    Stuttgart, IPVS, 2019.  

    See also: IterativeGridGeneratorRitterNovak  

    See also: HashRefinementMultiple  

    Constructors
    ------------
    * `IterativeGridGeneratorFuzzyRitterNovak(f, grid, N, xFuzzy,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS,
        adaptivity=DEFAULT_ADAPTIVITY, initialLevel=DEFAULT_INITIAL_LEVEL,
        maxLevel=DEFAULT_MAX_LEVEL, powMethod=PowMethod::STD_POW)`  

        Constructor.  

        Do not destruct the grid before this object!  

        Parameters:  
        * `f` :  
            objective function  
        * `grid` :  
            grid (should be empty)  
        * `N` :  
            maximal number of grid points  
        * `xFuzzy` :  
            fuzzy input intervals  
        * `numberOfAlphaSegments` :  
            number of alpha segments (i.e., number of inner Ritter-Novak
            generations)  
        * `adaptivity` :  
            adaptivity between 0 and 1  
        * `initialLevel` :  
            level of initial regular sparse grid  
        * `maxLevel` :  
            maximal level of grid points  
        * `powMethod` :  
            exponentiation method (fastPow is faster than std::pow, but only
            approximative)  

    C++ includes: IterativeGridGeneratorFuzzyRitterNovak.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_NUMBER_OF_ALPHA_SEGMENTS = _pysgpp_swig.OptIterativeGridGeneratorFuzzyRitterNovak_DEFAULT_NUMBER_OF_ALPHA_SEGMENTS

    def __init__(self, *args):
        r"""


        Constructor.  

        Do not destruct the grid before this object!  

        Parameters
        ----------
        * `f` :  
            objective function  
        * `grid` :  
            grid (should be empty)  
        * `N` :  
            maximal number of grid points  
        * `xFuzzy` :  
            fuzzy input intervals  
        * `numberOfAlphaSegments` :  
            number of alpha segments (i.e., number of inner Ritter-Novak generations)  
        * `adaptivity` :  
            adaptivity between 0 and 1  
        * `initialLevel` :  
            level of initial regular sparse grid  
        * `maxLevel` :  
            maximal level of grid points  
        * `powMethod` :  
            exponentiation method (fastPow is faster than std::pow, but only
            approximative)  

        """
        _pysgpp_swig.OptIterativeGridGeneratorFuzzyRitterNovak_swiginit(self, _pysgpp_swig.new_OptIterativeGridGeneratorFuzzyRitterNovak(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptIterativeGridGeneratorFuzzyRitterNovak

    def getXFuzzy(self) -> "std::vector< sgpp::optimization::FuzzyInterval const *,std::allocator< sgpp::optimization::FuzzyInterval const * > > const &":
        r"""


        Returns
        -------
        fuzzy input intervals  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorFuzzyRitterNovak_getXFuzzy(self)

    def setXFuzzy(self, xFuzzy: "OptFuzzyIntervalVector") -> "void":
        r"""


        Parameters
        ----------
        * `xFuzzy` :  
            fuzzy input intervals  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorFuzzyRitterNovak_setXFuzzy(self, xFuzzy)

    def getNumberOfAlphaSegments(self) -> "size_t":
        r"""


        Returns
        -------
        number of alpha segments (i.e., number of inner Ritter-Novak generations)  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorFuzzyRitterNovak_getNumberOfAlphaSegments(self)

    def setNumberOfAlphaSegments(self, numberOfAlphaSegments: "size_t") -> "void":
        r"""


        Parameters
        ----------
        * `numberOfAlphaSegments` :  
            number of alpha segments (i.e., number of inner Ritter-Novak generations)  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorFuzzyRitterNovak_setNumberOfAlphaSegments(self, numberOfAlphaSegments)

# Register OptIterativeGridGeneratorFuzzyRitterNovak in _pysgpp_swig:
_pysgpp_swig.OptIterativeGridGeneratorFuzzyRitterNovak_swigregister(OptIterativeGridGeneratorFuzzyRitterNovak)

class OptIterativeGridGeneratorLinearSurplus(OptIterativeGridGenerator):
    r"""

    `IterativeGridGeneratorLinearSurplus(f, grid, N, adaptivity=DEFAULT_ADAPTIVITY,
        initialLevel=DEFAULT_INITIAL_LEVEL)`  

    Iterative grid generation based on linear surplusses.  

    In each iteration, the fraction of $gamma$ (e.g. $\gamma = 0.2$ means 20%) of
    the grid points with the largest hierarchical linear surplusses are refined.  

    Constructors
    ------------
    * `IterativeGridGeneratorLinearSurplus(f, grid, N,
        adaptivity=DEFAULT_ADAPTIVITY, initialLevel=DEFAULT_INITIAL_LEVEL)`  

        Constructor.  

        Do not destruct the grid before this object!  

        Parameters:  
        * `f` :  
            objective function  
        * `grid` :  
            grid (should be empty)  
        * `N` :  
            maximal number of grid points  
        * `adaptivity` :  
            adaptivity between 0 and 1  
        * `initialLevel` :  
            level of initial regular sparse grid  

    C++ includes: IterativeGridGeneratorLinearSurplus.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_ADAPTIVITY = _pysgpp_swig.OptIterativeGridGeneratorLinearSurplus_DEFAULT_ADAPTIVITY
    DEFAULT_INITIAL_LEVEL = _pysgpp_swig.OptIterativeGridGeneratorLinearSurplus_DEFAULT_INITIAL_LEVEL

    def __init__(self, *args):
        r"""


        Constructor.  

        Do not destruct the grid before this object!  

        Parameters
        ----------
        * `f` :  
            objective function  
        * `grid` :  
            grid (should be empty)  
        * `N` :  
            maximal number of grid points  
        * `adaptivity` :  
            adaptivity between 0 and 1  
        * `initialLevel` :  
            level of initial regular sparse grid  

        """
        _pysgpp_swig.OptIterativeGridGeneratorLinearSurplus_swiginit(self, _pysgpp_swig.new_OptIterativeGridGeneratorLinearSurplus(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptIterativeGridGeneratorLinearSurplus

    def getAdaptivity(self) -> "double":
        r"""


        Returns
        -------
        adaptivity between 0 and 1  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorLinearSurplus_getAdaptivity(self)

    def setAdaptivity(self, adaptivity: "double") -> "void":
        r"""


        Parameters
        ----------
        * `adaptivity` :  
            adaptivity between 0 and 1  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorLinearSurplus_setAdaptivity(self, adaptivity)

    def getInitialLevel(self) -> "sgpp::base::level_t":
        r"""


        Returns
        -------
        level of initial regular sparse grid  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorLinearSurplus_getInitialLevel(self)

    def setInitialLevel(self, initialLevel: "sgpp::base::level_t") -> "void":
        r"""


        Parameters
        ----------
        * `initialLevel` :  
            level of initial regular sparse grid  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorLinearSurplus_setInitialLevel(self, initialLevel)

# Register OptIterativeGridGeneratorLinearSurplus in _pysgpp_swig:
_pysgpp_swig.OptIterativeGridGeneratorLinearSurplus_swigregister(OptIterativeGridGeneratorLinearSurplus)

class OptIterativeGridGeneratorSOO(OptIterativeGridGenerator):
    r"""

    `IterativeGridGeneratorSOO(f, grid, N, adaptivity=DEFAULT_ADAPTIVITY)`  

    Iterative grid generator using simultaneous optimistic optimization (SOO).  

    Constructors
    ------------
    * `IterativeGridGeneratorSOO(f, grid, N, adaptivity=DEFAULT_ADAPTIVITY)`  

        Constructor.  

        Do not destruct the grid before this object!  

        Parameters:  
        * `f` :  
            objective function  
        * `grid` :  
            grid (should be empty)  
        * `N` :  
            maximal number of grid points  
        * `adaptivity` :  
            adaptivity (positive number)  

    C++ includes: IterativeGridGeneratorSOO.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_ADAPTIVITY = _pysgpp_swig.OptIterativeGridGeneratorSOO_DEFAULT_ADAPTIVITY

    def __init__(self, *args):
        r"""


        Constructor.  

        Do not destruct the grid before this object!  

        Parameters
        ----------
        * `f` :  
            objective function  
        * `grid` :  
            grid (should be empty)  
        * `N` :  
            maximal number of grid points  
        * `adaptivity` :  
            adaptivity (positive number)  

        """
        _pysgpp_swig.OptIterativeGridGeneratorSOO_swiginit(self, _pysgpp_swig.new_OptIterativeGridGeneratorSOO(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptIterativeGridGeneratorSOO

    def getAdaptivity(self) -> "sgpp::optimization::IterativeGridGeneratorSOO::AdaptivityFunction":
        r"""


        """
        return _pysgpp_swig.OptIterativeGridGeneratorSOO_getAdaptivity(self)

    def setAdaptivity(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `setAdaptivity(adaptivity)`  

        * `setAdaptivity(adaptivity)`  

        """
        return _pysgpp_swig.OptIterativeGridGeneratorSOO_setAdaptivity(self, *args)

# Register OptIterativeGridGeneratorSOO in _pysgpp_swig:
_pysgpp_swig.OptIterativeGridGeneratorSOO_swigregister(OptIterativeGridGeneratorSOO)

class OperationMultipleHierarchisation(object):
    r"""

    `OperationMultipleHierarchisation()`  

    Abstract operation for hierarchization and dehierarchization for multiple sets
    of function values at the grid nodes.  

    Constructors
    ------------
    * `OperationMultipleHierarchisation()`  

        Constructor.  

    C++ includes: OperationMultipleHierarchisation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationMultipleHierarchisation

    def doHierarchisation(self, *args) -> "bool":
        r"""


        Overloaded function
        -------------------
        * `doHierarchisation(nodeValues) -> bool`  

            Pure virtual method for hierarchizing for multiple sets of function values.  

            Parameters:  
            * `nodeValues` :  
                before: matrix of function values at the grid points, after: matrix of
                hierarchical coefficients  

            Returns:
            whether hierarchisation was successful  

        * `doHierarchisation(nodeValues) -> bool`  

            Virtual method for hierarchizing for one set of function values.  

            Parameters:  
            * `nodeValues` :  
                before: vector of function values at the grid points, after: vector of
                hierarchical coefficients  

            Returns:
            whether hierarchisation was successful  

        """
        return _pysgpp_swig.OperationMultipleHierarchisation_doHierarchisation(self, *args)

    def doDehierarchisation(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `doDehierarchisation(alpha)`  

            Pure virtual method for dehierarchizing for multiple sets of coefficients.  

            Parameters:  
            * `alpha` :  
                before: matrix of hierarchical coefficients, after: matrix of function
                values at the grid points  

        * `doDehierarchisation(alpha)`  

            Virtual method for dehierarchizing for one set of function values.  

            Parameters:  
            * `alpha` :  
                before: vector of hierarchical coefficients, after: vector of function
                values at the grid points  

        """
        return _pysgpp_swig.OperationMultipleHierarchisation_doDehierarchisation(self, *args)

# Register OperationMultipleHierarchisation in _pysgpp_swig:
_pysgpp_swig.OperationMultipleHierarchisation_swigregister(OperationMultipleHierarchisation)

class OptUnconstrainedOptimizer(object):
    r"""

    `UnconstrainedOptimizer(f, fGradient, fHessian, N=DEFAULT_N)`  
    `UnconstrainedOptimizer(other)`  

    Abstract class for optimizing objective functions.  

    Constructors
    ------------
    * `UnconstrainedOptimizer(f, fGradient, fHessian, N=DEFAULT_N)`  

        Constructor.  

        The starting point is set to $(0.5, \dotsc, 0.5)^{\mathrm{T}}$.  

        Parameters:  
        * `f` :  
            function to optimize  
        * `fGradient` :  
            gradient of f (nullptr to omit)  
        * `fHessian` :  
            Hessian of f (nullptr to omit)  
        * `N` :  
            maximal number of iterations or function evaluations (depending on the
            implementation)  

    * `UnconstrainedOptimizer(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: UnconstrainedOptimizer.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DEFAULT_N = _pysgpp_swig.OptUnconstrainedOptimizer_DEFAULT_N
    __swig_destroy__ = _pysgpp_swig.delete_OptUnconstrainedOptimizer

    def optimize(self) -> "void":
        r"""


        Pure virtual method for optimization of the objective function.  

        The result of the optimization process can be obtained by member functions,
        e.g., getOptimalPoint() and getOptimalValue().  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_optimize(self)

    def getObjectiveFunction(self) -> "sgpp::base::ScalarFunction &":
        r"""


        Returns
        -------
        objective function  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_getObjectiveFunction(self)

    def setObjectiveFunction(self, f: "ScalarFunction") -> "void":
        r"""


        Parameters
        ----------
        * `f` :  
            objective function  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_setObjectiveFunction(self, f)

    def getObjectiveGradient(self) -> "sgpp::base::ScalarFunctionGradient *":
        r"""


        Returns
        -------
        objective gradient  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_getObjectiveGradient(self)

    def setObjectiveGradient(self, fGradient: "ScalarFunctionGradient") -> "void":
        r"""


        Parameters
        ----------
        * `fGradient` :  
            objective gradient  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_setObjectiveGradient(self, fGradient)

    def getObjectiveHessian(self) -> "sgpp::base::ScalarFunctionHessian *":
        r"""


        Returns
        -------
        objective Hessian  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_getObjectiveHessian(self)

    def setObjectiveHessian(self, fHessian: "ScalarFunctionHessian") -> "void":
        r"""


        Parameters
        ----------
        * `fHessian` :  
            objective Hessian  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_setObjectiveHessian(self, fHessian)

    def getN(self) -> "size_t":
        r"""


        Returns
        -------
        maximal number of iterations or function evaluations  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_getN(self)

    def setN(self, N: "size_t") -> "void":
        r"""


        Parameters
        ----------
        * `N` :  
            maximal number of iterations or function evaluations  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_setN(self, N)

    def getStartingPoint(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        starting point  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_getStartingPoint(self)

    def setStartingPoint(self, startingPoint: "DataVector") -> "void":
        r"""


        Parameters
        ----------
        * `startingPoint` :  
            starting point  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_setStartingPoint(self, startingPoint)

    def getOptimalPoint(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        result of optimization (location of optimum), empty vector on error  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_getOptimalPoint(self)

    def getOptimalValue(self) -> "double":
        r"""


        Returns
        -------
        result of optimization (optimal function value), NaN on error  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_getOptimalValue(self)

    def getHistoryOfOptimalPoints(self) -> "sgpp::base::DataMatrix const &":
        r"""


        Returns
        -------
        tall matrix (d columns) in which the k-th row indicates the best point after k
        iterations of the optimization, empty matrix on error or if not supported  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_getHistoryOfOptimalPoints(self)

    def getHistoryOfOptimalValues(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        vector in which the k-th entry indicates the best function value after k
        iterations of the optimization, empty vector on error or if not supported  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_getHistoryOfOptimalValues(self)

    def clone(self, clone: "std::unique_ptr< sgpp::optimization::optimizer::UnconstrainedOptimizer > &") -> "void":
        r"""


        Pure virtual method for cloning the optimizer.  

        It should generate a pointer to the cloned object and it's used for parallel
        computations.  

        Parameters
        ----------
        * `clone` :  
            pointer to cloned object  

        """
        return _pysgpp_swig.OptUnconstrainedOptimizer_clone(self, clone)

# Register OptUnconstrainedOptimizer in _pysgpp_swig:
_pysgpp_swig.OptUnconstrainedOptimizer_swigregister(OptUnconstrainedOptimizer)

class OptAdaptiveGradientDescent(OptUnconstrainedOptimizer):
    r"""

    `AdaptiveGradientDescent(other)`  
    `AdaptiveGradientDescent(f, fGradient, maxItCount=DEFAULT_N,
        tolerance=DEFAULT_TOLERANCE,
        stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
        stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR,
        lineSearchAccuracy=DEFAULT_LINE_SEARCH_ACCURACY)`  

    Gradient descent with adaptive step size.  

    Constructors
    ------------
    * `AdaptiveGradientDescent(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    * `AdaptiveGradientDescent(f, fGradient, maxItCount=DEFAULT_N,
        tolerance=DEFAULT_TOLERANCE,
        stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
        stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR,
        lineSearchAccuracy=DEFAULT_LINE_SEARCH_ACCURACY)`  

        Constructor.  

        Parameters:  
        * `f` :  
            objective function  
        * `fGradient` :  
            objective function gradient  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `tolerance` :  
            tolerance  
        * `stepSizeIncreaseFactor` :  
            step size increase factor  
        * `stepSizeDecreaseFactor` :  
            step size decrease factor  
        * `lineSearchAccuracy` :  
            line search accuracy  

    C++ includes: AdaptiveGradientDescent.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_TOLERANCE = _pysgpp_swig.OptAdaptiveGradientDescent_DEFAULT_TOLERANCE
    DEFAULT_STEP_SIZE_INCREASE_FACTOR = _pysgpp_swig.OptAdaptiveGradientDescent_DEFAULT_STEP_SIZE_INCREASE_FACTOR
    DEFAULT_STEP_SIZE_DECREASE_FACTOR = _pysgpp_swig.OptAdaptiveGradientDescent_DEFAULT_STEP_SIZE_DECREASE_FACTOR
    DEFAULT_LINE_SEARCH_ACCURACY = _pysgpp_swig.OptAdaptiveGradientDescent_DEFAULT_LINE_SEARCH_ACCURACY

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `AdaptiveGradientDescent(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        * `AdaptiveGradientDescent(f, fGradient, maxItCount=DEFAULT_N,
            tolerance=DEFAULT_TOLERANCE,
            stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
            stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR,
            lineSearchAccuracy=DEFAULT_LINE_SEARCH_ACCURACY)`  

            Constructor.  

            Parameters:  
            * `f` :  
                objective function  
            * `fGradient` :  
                objective function gradient  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `tolerance` :  
                tolerance  
            * `stepSizeIncreaseFactor` :  
                step size increase factor  
            * `stepSizeDecreaseFactor` :  
                step size decrease factor  
            * `lineSearchAccuracy` :  
                line search accuracy  

        """
        _pysgpp_swig.OptAdaptiveGradientDescent_swiginit(self, _pysgpp_swig.new_OptAdaptiveGradientDescent(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptAdaptiveGradientDescent

    def getTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance  

        """
        return _pysgpp_swig.OptAdaptiveGradientDescent_getTolerance(self)

    def setTolerance(self, tolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `tolerance` :  
            tolerance  

        """
        return _pysgpp_swig.OptAdaptiveGradientDescent_setTolerance(self, tolerance)

    def getStepSizeIncreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        step size increase factor  

        """
        return _pysgpp_swig.OptAdaptiveGradientDescent_getStepSizeIncreaseFactor(self)

    def setStepSizeIncreaseFactor(self, stepSizeIncreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `stepSizeIncreaseFactor` :  
            step size increase factor  

        """
        return _pysgpp_swig.OptAdaptiveGradientDescent_setStepSizeIncreaseFactor(self, stepSizeIncreaseFactor)

    def getStepSizeDecreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        step size decrease factor  

        """
        return _pysgpp_swig.OptAdaptiveGradientDescent_getStepSizeDecreaseFactor(self)

    def setStepSizeDecreaseFactor(self, stepSizeDecreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `stepSizeDecreaseFactor` :  
            step size decrease factor  

        """
        return _pysgpp_swig.OptAdaptiveGradientDescent_setStepSizeDecreaseFactor(self, stepSizeDecreaseFactor)

    def getLineSearchAccuracy(self) -> "double":
        r"""


        Returns
        -------
        line search accuracy  

        """
        return _pysgpp_swig.OptAdaptiveGradientDescent_getLineSearchAccuracy(self)

    def setLineSearchAccuracy(self, lineSearchAccuracy: "double") -> "void":
        r"""


        Parameters
        ----------
        * `lineSearchAccuracy` :  
            line search accuracy  

        """
        return _pysgpp_swig.OptAdaptiveGradientDescent_setLineSearchAccuracy(self, lineSearchAccuracy)

# Register OptAdaptiveGradientDescent in _pysgpp_swig:
_pysgpp_swig.OptAdaptiveGradientDescent_swigregister(OptAdaptiveGradientDescent)

class OptAdaptiveNewton(OptUnconstrainedOptimizer):
    r"""

    `AdaptiveNewton(other)`  
    `AdaptiveNewton(f, fHessian, maxItCount, tolerance, stepSizeIncreaseFactor,
        stepSizeDecreaseFactor, dampingIncreaseFactor, dampingDecreaseFactor,
        lineSearchAccuracy, sleSolver)`  
    `AdaptiveNewton(f, fHessian, maxItCount=DEFAULT_N, tolerance=DEFAULT_TOLERANCE,
        stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
        stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR,
        dampingIncreaseFactor=DEFAULT_DAMPING_INCREASE_FACTOR,
        dampingDecreaseFactor=DEFAULT_DAMPING_DECREASE_FACTOR,
        lineSearchAccuracy=DEFAULT_LINE_SEARCH_ACCURACY)`  

    Newton method with adaptive step size.  

    Constructors
    ------------
    * `AdaptiveNewton(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    * `AdaptiveNewton(f, fHessian, maxItCount, tolerance, stepSizeIncreaseFactor,
        stepSizeDecreaseFactor, dampingIncreaseFactor, dampingDecreaseFactor,
        lineSearchAccuracy, sleSolver)`  

        Constructor.  

        Do not destruct the solver before this object!  

        Parameters:  
        * `f` :  
            objective function  
        * `fHessian` :  
            objective function Hessian  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `tolerance` :  
            tolerance  
        * `stepSizeIncreaseFactor` :  
            step size increase factor  
        * `stepSizeDecreaseFactor` :  
            step size decrease factor  
        * `dampingIncreaseFactor` :  
            damping increase factor  
        * `dampingDecreaseFactor` :  
            damping decrease factor  
        * `lineSearchAccuracy` :  
            line search accuracy  
        * `sleSolver` :  
            reference to linear solver for solving the linear systems (Hessian as
            coefficient matrix)  

    * `AdaptiveNewton(f, fHessian, maxItCount=DEFAULT_N,
        tolerance=DEFAULT_TOLERANCE,
        stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
        stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR,
        dampingIncreaseFactor=DEFAULT_DAMPING_INCREASE_FACTOR,
        dampingDecreaseFactor=DEFAULT_DAMPING_DECREASE_FACTOR,
        lineSearchAccuracy=DEFAULT_LINE_SEARCH_ACCURACY)`  

        Constructor.  

        By default, GaussianElimination is used to solve the linear systems.  

        Parameters:  
        * `f` :  
            objective function  
        * `fHessian` :  
            objective function Hessian  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `tolerance` :  
            tolerance  
        * `stepSizeIncreaseFactor` :  
            step size increase factor  
        * `stepSizeDecreaseFactor` :  
            step size decrease factor  
        * `dampingIncreaseFactor` :  
            damping increase factor  
        * `dampingDecreaseFactor` :  
            damping decrease factor  
        * `lineSearchAccuracy` :  
            line search accuracy  

    C++ includes: AdaptiveNewton.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_TOLERANCE = _pysgpp_swig.OptAdaptiveNewton_DEFAULT_TOLERANCE
    DEFAULT_STEP_SIZE_INCREASE_FACTOR = _pysgpp_swig.OptAdaptiveNewton_DEFAULT_STEP_SIZE_INCREASE_FACTOR
    DEFAULT_STEP_SIZE_DECREASE_FACTOR = _pysgpp_swig.OptAdaptiveNewton_DEFAULT_STEP_SIZE_DECREASE_FACTOR
    DEFAULT_DAMPING_INCREASE_FACTOR = _pysgpp_swig.OptAdaptiveNewton_DEFAULT_DAMPING_INCREASE_FACTOR
    DEFAULT_DAMPING_DECREASE_FACTOR = _pysgpp_swig.OptAdaptiveNewton_DEFAULT_DAMPING_DECREASE_FACTOR
    DEFAULT_LINE_SEARCH_ACCURACY = _pysgpp_swig.OptAdaptiveNewton_DEFAULT_LINE_SEARCH_ACCURACY

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `AdaptiveNewton(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        * `AdaptiveNewton(f, fHessian, maxItCount, tolerance, stepSizeIncreaseFactor,
            stepSizeDecreaseFactor, dampingIncreaseFactor, dampingDecreaseFactor,
            lineSearchAccuracy, sleSolver)`  

            Constructor.  

            Do not destruct the solver before this object!  

            Parameters:  
            * `f` :  
                objective function  
            * `fHessian` :  
                objective function Hessian  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `tolerance` :  
                tolerance  
            * `stepSizeIncreaseFactor` :  
                step size increase factor  
            * `stepSizeDecreaseFactor` :  
                step size decrease factor  
            * `dampingIncreaseFactor` :  
                damping increase factor  
            * `dampingDecreaseFactor` :  
                damping decrease factor  
            * `lineSearchAccuracy` :  
                line search accuracy  
            * `sleSolver` :  
                reference to linear solver for solving the linear systems (Hessian as
                coefficient matrix)  

        * `AdaptiveNewton(f, fHessian, maxItCount=DEFAULT_N,
            tolerance=DEFAULT_TOLERANCE,
            stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
            stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR,
            dampingIncreaseFactor=DEFAULT_DAMPING_INCREASE_FACTOR,
            dampingDecreaseFactor=DEFAULT_DAMPING_DECREASE_FACTOR,
            lineSearchAccuracy=DEFAULT_LINE_SEARCH_ACCURACY)`  

            Constructor.  

            By default, GaussianElimination is used to solve the linear systems.  

            Parameters:  
            * `f` :  
                objective function  
            * `fHessian` :  
                objective function Hessian  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `tolerance` :  
                tolerance  
            * `stepSizeIncreaseFactor` :  
                step size increase factor  
            * `stepSizeDecreaseFactor` :  
                step size decrease factor  
            * `dampingIncreaseFactor` :  
                damping increase factor  
            * `dampingDecreaseFactor` :  
                damping decrease factor  
            * `lineSearchAccuracy` :  
                line search accuracy  

        """
        _pysgpp_swig.OptAdaptiveNewton_swiginit(self, _pysgpp_swig.new_OptAdaptiveNewton(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptAdaptiveNewton

    def getTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance  

        """
        return _pysgpp_swig.OptAdaptiveNewton_getTolerance(self)

    def setTolerance(self, tolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `tolerance` :  
            tolerance  

        """
        return _pysgpp_swig.OptAdaptiveNewton_setTolerance(self, tolerance)

    def getStepSizeIncreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        step size increase factor  

        """
        return _pysgpp_swig.OptAdaptiveNewton_getStepSizeIncreaseFactor(self)

    def setStepSizeIncreaseFactor(self, stepSizeIncreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `stepSizeIncreaseFactor` :  
            step size increase factor  

        """
        return _pysgpp_swig.OptAdaptiveNewton_setStepSizeIncreaseFactor(self, stepSizeIncreaseFactor)

    def getStepSizeDecreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        step size decrease factor  

        """
        return _pysgpp_swig.OptAdaptiveNewton_getStepSizeDecreaseFactor(self)

    def setStepSizeDecreaseFactor(self, stepSizeDecreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `stepSizeDecreaseFactor` :  
            step size decrease factor  

        """
        return _pysgpp_swig.OptAdaptiveNewton_setStepSizeDecreaseFactor(self, stepSizeDecreaseFactor)

    def getDampingIncreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        damping increase factor  

        """
        return _pysgpp_swig.OptAdaptiveNewton_getDampingIncreaseFactor(self)

    def setDampingIncreaseFactor(self, dampingIncreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `dampingIncreaseFactor` :  
            damping increase factor  

        """
        return _pysgpp_swig.OptAdaptiveNewton_setDampingIncreaseFactor(self, dampingIncreaseFactor)

    def getDampingDecreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        damping decrease factor  

        """
        return _pysgpp_swig.OptAdaptiveNewton_getDampingDecreaseFactor(self)

    def setDampingDecreaseFactor(self, dampingDecreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `dampingDecreaseFactor` :  
            damping decrease factor  

        """
        return _pysgpp_swig.OptAdaptiveNewton_setDampingDecreaseFactor(self, dampingDecreaseFactor)

    def getLineSearchAccuracy(self) -> "double":
        r"""


        Returns
        -------
        line search accuracy  

        """
        return _pysgpp_swig.OptAdaptiveNewton_getLineSearchAccuracy(self)

    def setLineSearchAccuracy(self, lineSearchAccuracy: "double") -> "void":
        r"""


        Parameters
        ----------
        * `lineSearchAccuracy` :  
            line search accuracy  

        """
        return _pysgpp_swig.OptAdaptiveNewton_setLineSearchAccuracy(self, lineSearchAccuracy)

# Register OptAdaptiveNewton in _pysgpp_swig:
_pysgpp_swig.OptAdaptiveNewton_swigregister(OptAdaptiveNewton)

class OptBFGS(OptUnconstrainedOptimizer):
    r"""

    `BFGS(f, fGradient, maxItCount=DEFAULT_N, tolerance=DEFAULT_TOLERANCE,
        stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
        stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR,
        lineSearchAccuracy=DEFAULT_LINE_SEARCH_ACCURACY)`  
    `BFGS(other)`  

    BFGS method for unconstrained optimization.  

    Constructors
    ------------
    * `BFGS(f, fGradient, maxItCount=DEFAULT_N, tolerance=DEFAULT_TOLERANCE,
        stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
        stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR,
        lineSearchAccuracy=DEFAULT_LINE_SEARCH_ACCURACY)`  

        Constructor.  

        Parameters:  
        * `f` :  
            objective function  
        * `fGradient` :  
            objective function gradient  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `tolerance` :  
            tolerance  
        * `stepSizeIncreaseFactor` :  
            step size increase factor  
        * `stepSizeDecreaseFactor` :  
            step size decrease factor  
        * `lineSearchAccuracy` :  
            line search accuracy  

    * `BFGS(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: BFGS.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_TOLERANCE = _pysgpp_swig.OptBFGS_DEFAULT_TOLERANCE
    DEFAULT_STEP_SIZE_INCREASE_FACTOR = _pysgpp_swig.OptBFGS_DEFAULT_STEP_SIZE_INCREASE_FACTOR
    DEFAULT_STEP_SIZE_DECREASE_FACTOR = _pysgpp_swig.OptBFGS_DEFAULT_STEP_SIZE_DECREASE_FACTOR
    DEFAULT_LINE_SEARCH_ACCURACY = _pysgpp_swig.OptBFGS_DEFAULT_LINE_SEARCH_ACCURACY

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `BFGS(f, fGradient, maxItCount=DEFAULT_N, tolerance=DEFAULT_TOLERANCE,
            stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
            stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR,
            lineSearchAccuracy=DEFAULT_LINE_SEARCH_ACCURACY)`  

            Constructor.  

            Parameters:  
            * `f` :  
                objective function  
            * `fGradient` :  
                objective function gradient  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `tolerance` :  
                tolerance  
            * `stepSizeIncreaseFactor` :  
                step size increase factor  
            * `stepSizeDecreaseFactor` :  
                step size decrease factor  
            * `lineSearchAccuracy` :  
                line search accuracy  

        * `BFGS(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        """
        _pysgpp_swig.OptBFGS_swiginit(self, _pysgpp_swig.new_OptBFGS(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptBFGS

    def getTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance  

        """
        return _pysgpp_swig.OptBFGS_getTolerance(self)

    def setTolerance(self, tolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `tolerance` :  
            tolerance  

        """
        return _pysgpp_swig.OptBFGS_setTolerance(self, tolerance)

    def getStepSizeIncreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        step size increase factor  

        """
        return _pysgpp_swig.OptBFGS_getStepSizeIncreaseFactor(self)

    def setStepSizeIncreaseFactor(self, stepSizeIncreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `stepSizeIncreaseFactor` :  
            step size increase factor  

        """
        return _pysgpp_swig.OptBFGS_setStepSizeIncreaseFactor(self, stepSizeIncreaseFactor)

    def getStepSizeDecreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        step size decrease factor  

        """
        return _pysgpp_swig.OptBFGS_getStepSizeDecreaseFactor(self)

    def setStepSizeDecreaseFactor(self, stepSizeDecreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `stepSizeDecreaseFactor` :  
            step size decrease factor  

        """
        return _pysgpp_swig.OptBFGS_setStepSizeDecreaseFactor(self, stepSizeDecreaseFactor)

    def getLineSearchAccuracy(self) -> "double":
        r"""


        Returns
        -------
        line search accuracy  

        """
        return _pysgpp_swig.OptBFGS_getLineSearchAccuracy(self)

    def setLineSearchAccuracy(self, lineSearchAccuracy: "double") -> "void":
        r"""


        Parameters
        ----------
        * `lineSearchAccuracy` :  
            line search accuracy  

        """
        return _pysgpp_swig.OptBFGS_setLineSearchAccuracy(self, lineSearchAccuracy)

# Register OptBFGS in _pysgpp_swig:
_pysgpp_swig.OptBFGS_swigregister(OptBFGS)

class OptCMAES(OptUnconstrainedOptimizer):
    r"""

    `CMAES(f, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT)`  
    `CMAES(other)`  

    Gradient-free CMA-ES method.  

    Constructors
    ------------
    * `CMAES(f, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT)`  

        Constructor.  

        The starting point is set to $(0.5, \dotsc, 0.5)^{\mathrm{T}}$.  

        Parameters:  
        * `f` :  
            objective function  
        * `maxFcnEvalCount` :  
            maximal number of function evaluations  

    * `CMAES(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: CMAES.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_MAX_FCN_EVAL_COUNT = _pysgpp_swig.OptCMAES_DEFAULT_MAX_FCN_EVAL_COUNT

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `CMAES(f, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT)`  

            Constructor.  

            The starting point is set to $(0.5, \dotsc, 0.5)^{\mathrm{T}}$.  

            Parameters:  
            * `f` :  
                objective function  
            * `maxFcnEvalCount` :  
                maximal number of function evaluations  

        * `CMAES(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        """
        _pysgpp_swig.OptCMAES_swiginit(self, _pysgpp_swig.new_OptCMAES(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptCMAES

# Register OptCMAES in _pysgpp_swig:
_pysgpp_swig.OptCMAES_swigregister(OptCMAES)

class OptDifferentialEvolution(OptUnconstrainedOptimizer):
    r"""

    `DifferentialEvolution(f, maxFcnEvalCount=DEFAULT_N, populationSize=0,
        crossoverProbability=DEFAULT_CROSSOVER_PROBABILITY,
        scalingFactor=DEFAULT_SCALING_FACTOR,
        idleGenerationsCount=DEFAULT_IDLE_GENERATIONS_COUNT,
        avgImprovementThreshold=DEFAULT_AVG_IMPROVEMENT_THRESHOLD,
        maxDistanceThreshold=DEFAULT_MAX_DISTANCE_THRESHOLD)`  
    `DifferentialEvolution(other)`  

    Gradient-free Differential Evolution method.  

    Constructors
    ------------
    * `DifferentialEvolution(f, maxFcnEvalCount=DEFAULT_N, populationSize=0,
        crossoverProbability=DEFAULT_CROSSOVER_PROBABILITY,
        scalingFactor=DEFAULT_SCALING_FACTOR,
        idleGenerationsCount=DEFAULT_IDLE_GENERATIONS_COUNT,
        avgImprovementThreshold=DEFAULT_AVG_IMPROVEMENT_THRESHOLD,
        maxDistanceThreshold=DEFAULT_MAX_DISTANCE_THRESHOLD)`  

        Constructor.  

        Parameters:  
        * `f` :  
            objective function  
        * `maxFcnEvalCount` :  
            maximal number of function evaluations  
        * `populationSize` :  
            number of individuals (default: $10d$)  
        * `crossoverProbability` :  
            crossover probability  
        * `scalingFactor` :  
            crossover scaling factor  
        * `idleGenerationsCount` :  
            stopping criterion parameter 1  
        * `avgImprovementThreshold` :  
            stopping criterion parameter 2  
        * `maxDistanceThreshold` :  
            stopping criterion parameter 3  

    * `DifferentialEvolution(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: DifferentialEvolution.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_CROSSOVER_PROBABILITY = _pysgpp_swig.OptDifferentialEvolution_DEFAULT_CROSSOVER_PROBABILITY
    DEFAULT_SCALING_FACTOR = _pysgpp_swig.OptDifferentialEvolution_DEFAULT_SCALING_FACTOR
    DEFAULT_IDLE_GENERATIONS_COUNT = _pysgpp_swig.OptDifferentialEvolution_DEFAULT_IDLE_GENERATIONS_COUNT
    DEFAULT_AVG_IMPROVEMENT_THRESHOLD = _pysgpp_swig.OptDifferentialEvolution_DEFAULT_AVG_IMPROVEMENT_THRESHOLD
    DEFAULT_MAX_DISTANCE_THRESHOLD = _pysgpp_swig.OptDifferentialEvolution_DEFAULT_MAX_DISTANCE_THRESHOLD

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DifferentialEvolution(f, maxFcnEvalCount=DEFAULT_N, populationSize=0,
            crossoverProbability=DEFAULT_CROSSOVER_PROBABILITY,
            scalingFactor=DEFAULT_SCALING_FACTOR,
            idleGenerationsCount=DEFAULT_IDLE_GENERATIONS_COUNT,
            avgImprovementThreshold=DEFAULT_AVG_IMPROVEMENT_THRESHOLD,
            maxDistanceThreshold=DEFAULT_MAX_DISTANCE_THRESHOLD)`  

            Constructor.  

            Parameters:  
            * `f` :  
                objective function  
            * `maxFcnEvalCount` :  
                maximal number of function evaluations  
            * `populationSize` :  
                number of individuals (default: $10d$)  
            * `crossoverProbability` :  
                crossover probability  
            * `scalingFactor` :  
                crossover scaling factor  
            * `idleGenerationsCount` :  
                stopping criterion parameter 1  
            * `avgImprovementThreshold` :  
                stopping criterion parameter 2  
            * `maxDistanceThreshold` :  
                stopping criterion parameter 3  

        * `DifferentialEvolution(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        """
        _pysgpp_swig.OptDifferentialEvolution_swiginit(self, _pysgpp_swig.new_OptDifferentialEvolution(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptDifferentialEvolution

    def getPopulationSize(self) -> "size_t":
        r"""


        Returns
        -------
        number of individuals  

        """
        return _pysgpp_swig.OptDifferentialEvolution_getPopulationSize(self)

    def setPopulationSize(self, populationSize: "size_t") -> "void":
        r"""


        Parameters
        ----------
        * `populationSize` :  
            number of individuals  

        """
        return _pysgpp_swig.OptDifferentialEvolution_setPopulationSize(self, populationSize)

    def getCrossoverProbability(self) -> "double":
        r"""


        Returns
        -------
        crossover probability  

        """
        return _pysgpp_swig.OptDifferentialEvolution_getCrossoverProbability(self)

    def setCrossoverProbability(self, crossoverProbability: "double") -> "void":
        r"""


        Parameters
        ----------
        * `crossoverProbability` :  
            crossover probability  

        """
        return _pysgpp_swig.OptDifferentialEvolution_setCrossoverProbability(self, crossoverProbability)

    def getScalingFactor(self) -> "double":
        r"""


        Returns
        -------
        crossover scaling factor  

        """
        return _pysgpp_swig.OptDifferentialEvolution_getScalingFactor(self)

    def setScalingFactor(self, scalingFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `scalingFactor` :  
            crossover scaling factor  

        """
        return _pysgpp_swig.OptDifferentialEvolution_setScalingFactor(self, scalingFactor)

    def getIdleGenerationsCount(self) -> "size_t":
        r"""


        Returns
        -------
        stopping criterion parameter 1  

        """
        return _pysgpp_swig.OptDifferentialEvolution_getIdleGenerationsCount(self)

    def setIdleGenerationsCount(self, idleGenerationsCount: "size_t") -> "void":
        r"""


        Parameters
        ----------
        * `idleGenerationsCount` :  
            stopping criterion parameter 1  

        """
        return _pysgpp_swig.OptDifferentialEvolution_setIdleGenerationsCount(self, idleGenerationsCount)

    def getAvgImprovementThreshold(self) -> "double":
        r"""


        Returns
        -------
        stopping criterion parameter 2  

        """
        return _pysgpp_swig.OptDifferentialEvolution_getAvgImprovementThreshold(self)

    def setAvgImprovementThreshold(self, avgImprovementThreshold: "double") -> "void":
        r"""


        Parameters
        ----------
        * `avgImprovementThreshold` :  
            stopping criterion parameter 2  

        """
        return _pysgpp_swig.OptDifferentialEvolution_setAvgImprovementThreshold(self, avgImprovementThreshold)

    def getMaxDistanceThreshold(self) -> "double":
        r"""


        Returns
        -------
        stopping criterion parameter 3  

        """
        return _pysgpp_swig.OptDifferentialEvolution_getMaxDistanceThreshold(self)

    def setMaxDistanceThreshold(self, maxDistanceThreshold: "double") -> "void":
        r"""


        Parameters
        ----------
        * `maxDistanceThreshold` :  
            stopping criterion parameter 3  

        """
        return _pysgpp_swig.OptDifferentialEvolution_setMaxDistanceThreshold(self, maxDistanceThreshold)

# Register OptDifferentialEvolution in _pysgpp_swig:
_pysgpp_swig.OptDifferentialEvolution_swigregister(OptDifferentialEvolution)

class OptGradientDescent(OptUnconstrainedOptimizer):
    r"""

    `GradientDescent(f, fGradient, maxItCount=DEFAULT_MAX_IT_COUNT,
        beta=DEFAULT_BETA, gamma=DEFAULT_GAMMA, tolerance=DEFAULT_TOLERANCE,
        epsilon=DEFAULT_EPSILON)`  
    `GradientDescent(other)`  

    Gradient-based method of steepest descent.  

    Constructors
    ------------
    * `GradientDescent(f, fGradient, maxItCount=DEFAULT_MAX_IT_COUNT,
        beta=DEFAULT_BETA, gamma=DEFAULT_GAMMA, tolerance=DEFAULT_TOLERANCE,
        epsilon=DEFAULT_EPSILON)`  

        Constructor.  

        Parameters:  
        * `f` :  
            objective function  
        * `fGradient` :  
            objective function gradient  
        * `maxItCount` :  
            maximal number of iterations  
        * `beta` :  
            beta (parameter for Armijo's rule)  
        * `gamma` :  
            gamma (parameter for Armijo's rule)  
        * `tolerance` :  
            tolerance (parameter for Armijo's rule)  
        * `epsilon` :  
            epsilon (parameter for Armijo's rule)  

    * `GradientDescent(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: GradientDescent.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_MAX_IT_COUNT = _pysgpp_swig.OptGradientDescent_DEFAULT_MAX_IT_COUNT
    DEFAULT_BETA = _pysgpp_swig.OptGradientDescent_DEFAULT_BETA
    DEFAULT_GAMMA = _pysgpp_swig.OptGradientDescent_DEFAULT_GAMMA
    DEFAULT_TOLERANCE = _pysgpp_swig.OptGradientDescent_DEFAULT_TOLERANCE
    DEFAULT_EPSILON = _pysgpp_swig.OptGradientDescent_DEFAULT_EPSILON

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `GradientDescent(f, fGradient, maxItCount=DEFAULT_MAX_IT_COUNT,
            beta=DEFAULT_BETA, gamma=DEFAULT_GAMMA, tolerance=DEFAULT_TOLERANCE,
            epsilon=DEFAULT_EPSILON)`  

            Constructor.  

            Parameters:  
            * `f` :  
                objective function  
            * `fGradient` :  
                objective function gradient  
            * `maxItCount` :  
                maximal number of iterations  
            * `beta` :  
                beta (parameter for Armijo's rule)  
            * `gamma` :  
                gamma (parameter for Armijo's rule)  
            * `tolerance` :  
                tolerance (parameter for Armijo's rule)  
            * `epsilon` :  
                epsilon (parameter for Armijo's rule)  

        * `GradientDescent(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        """
        _pysgpp_swig.OptGradientDescent_swiginit(self, _pysgpp_swig.new_OptGradientDescent(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptGradientDescent

    def getBeta(self) -> "double":
        r"""


        Returns
        -------
        beta (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptGradientDescent_getBeta(self)

    def setBeta(self, beta: "double") -> "void":
        r"""


        Parameters
        ----------
        * `beta` :  
            beta (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptGradientDescent_setBeta(self, beta)

    def getGamma(self) -> "double":
        r"""


        Returns
        -------
        gamma (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptGradientDescent_getGamma(self)

    def setGamma(self, gamma: "double") -> "void":
        r"""


        Parameters
        ----------
        * `gamma` :  
            gamma (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptGradientDescent_setGamma(self, gamma)

    def getTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptGradientDescent_getTolerance(self)

    def setTolerance(self, tolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `tolerance` :  
            tolerance (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptGradientDescent_setTolerance(self, tolerance)

    def getEpsilon(self) -> "double":
        r"""


        Returns
        -------
        epsilon (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptGradientDescent_getEpsilon(self)

    def setEpsilon(self, epsilon: "double") -> "void":
        r"""


        Parameters
        ----------
        * `epsilon` :  
            epsilon (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptGradientDescent_setEpsilon(self, epsilon)

# Register OptGradientDescent in _pysgpp_swig:
_pysgpp_swig.OptGradientDescent_swigregister(OptGradientDescent)

class OptMultiStart(OptUnconstrainedOptimizer):
    r"""

    `MultiStart(f, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT, populationSize=0)`  
    `MultiStart(other)`  
    `MultiStart(optimizer, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT,
        populationSize=0)`  

    Meta optimization algorithm calling local algorithm multiple times.  

    MultiStart generates a random population of a given number of starting points,
    and then runs a local optimization algorithm for each of the starting point. The
    best point wins.  

    Constructors
    ------------
    * `MultiStart(f, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT, populationSize=0)`  

        Constructor.  

        By default, Nelder-Mead is used as optimization algorithm.  

        Parameters:  
        * `f` :  
            objective function  
        * `maxFcnEvalCount` :  
            maximal number of function evaluations  
        * `populationSize` :  
            number of individual points (default: $\min(10d, 100)$)  

    * `MultiStart(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    * `MultiStart(optimizer, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT,
        populationSize=0)`  

        Constructor with custom optimization algorithm.  

        The current values of the optimizer's N and starting point properties will
        not be used.  

        Parameters:  
        * `optimizer` :  
            optimization algorithm and objective function  
        * `maxFcnEvalCount` :  
            maximal number of function evaluations  
        * `populationSize` :  
            number of individual points (default: $\min(10d, 100)$)  

    C++ includes: MultiStart.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_MAX_FCN_EVAL_COUNT = _pysgpp_swig.OptMultiStart_DEFAULT_MAX_FCN_EVAL_COUNT

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `MultiStart(f, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT, populationSize=0)`  

            Constructor.  

            By default, Nelder-Mead is used as optimization algorithm.  

            Parameters:  
            * `f` :  
                objective function  
            * `maxFcnEvalCount` :  
                maximal number of function evaluations  
            * `populationSize` :  
                number of individual points (default: $\min(10d, 100)$)  

        * `MultiStart(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        * `MultiStart(optimizer, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT,
            populationSize=0)`  

            Constructor with custom optimization algorithm.  

            The current values of the optimizer's N and starting point properties will
            not be used.  

            Parameters:  
            * `optimizer` :  
                optimization algorithm and objective function  
            * `maxFcnEvalCount` :  
                maximal number of function evaluations  
            * `populationSize` :  
                number of individual points (default: $\min(10d, 100)$)  

        """
        _pysgpp_swig.OptMultiStart_swiginit(self, _pysgpp_swig.new_OptMultiStart(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptMultiStart

    def getPopulationSize(self) -> "size_t":
        r"""


        Returns
        -------
        number of individual points  

        """
        return _pysgpp_swig.OptMultiStart_getPopulationSize(self)

    def setPopulationSize(self, populationSize: "size_t") -> "void":
        r"""


        Parameters
        ----------
        * `populationSize` :  
            number of individual points  

        """
        return _pysgpp_swig.OptMultiStart_setPopulationSize(self, populationSize)

    def getHistoryOfInnerIterations(self) -> "std::vector< size_t,std::allocator< size_t > > const &":
        r"""


        Returns
        -------
        vector in which the k-th entry indicates the number of inner iterations in the
        k-th (outer) iteration, empty vector on error  

        """
        return _pysgpp_swig.OptMultiStart_getHistoryOfInnerIterations(self)

# Register OptMultiStart in _pysgpp_swig:
_pysgpp_swig.OptMultiStart_swigregister(OptMultiStart)

class OptNelderMead(OptUnconstrainedOptimizer):
    r"""

    `NelderMead(f, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT, alpha=DEFAULT_ALPHA,
        beta=DEFAULT_BETA, gamma=DEFAULT_GAMMA, delta=DEFAULT_DELTA)`  
    `NelderMead(other)`  

    Gradient-free Nelder-Mead method.  

    Constructors
    ------------
    * `NelderMead(f, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT,
        alpha=DEFAULT_ALPHA, beta=DEFAULT_BETA, gamma=DEFAULT_GAMMA,
        delta=DEFAULT_DELTA)`  

        Constructor.  

        The starting point is set to $(0.5, \dotsc, 0.5)^{\mathrm{T}}$.  

        Parameters:  
        * `f` :  
            objective function  
        * `maxFcnEvalCount` :  
            maximal number of function evaluations  
        * `alpha` :  
            reflection coefficient  
        * `beta` :  
            expansion coefficient  
        * `gamma` :  
            contraction coefficient  
        * `delta` :  
            shrinking coefficient  

    * `NelderMead(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: NelderMead.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_ALPHA = _pysgpp_swig.OptNelderMead_DEFAULT_ALPHA
    DEFAULT_BETA = _pysgpp_swig.OptNelderMead_DEFAULT_BETA
    DEFAULT_GAMMA = _pysgpp_swig.OptNelderMead_DEFAULT_GAMMA
    DEFAULT_DELTA = _pysgpp_swig.OptNelderMead_DEFAULT_DELTA
    DEFAULT_MAX_FCN_EVAL_COUNT = _pysgpp_swig.OptNelderMead_DEFAULT_MAX_FCN_EVAL_COUNT
    STARTING_SIMPLEX_EDGE_LENGTH = _pysgpp_swig.OptNelderMead_STARTING_SIMPLEX_EDGE_LENGTH

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `NelderMead(f, maxFcnEvalCount=DEFAULT_MAX_FCN_EVAL_COUNT,
            alpha=DEFAULT_ALPHA, beta=DEFAULT_BETA, gamma=DEFAULT_GAMMA,
            delta=DEFAULT_DELTA)`  

            Constructor.  

            The starting point is set to $(0.5, \dotsc, 0.5)^{\mathrm{T}}$.  

            Parameters:  
            * `f` :  
                objective function  
            * `maxFcnEvalCount` :  
                maximal number of function evaluations  
            * `alpha` :  
                reflection coefficient  
            * `beta` :  
                expansion coefficient  
            * `gamma` :  
                contraction coefficient  
            * `delta` :  
                shrinking coefficient  

        * `NelderMead(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        """
        _pysgpp_swig.OptNelderMead_swiginit(self, _pysgpp_swig.new_OptNelderMead(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptNelderMead

    def getAlpha(self) -> "double":
        r"""


        Returns
        -------
        reflection coefficient  

        """
        return _pysgpp_swig.OptNelderMead_getAlpha(self)

    def setAlpha(self, alpha: "double") -> "void":
        r"""


        Parameters
        ----------
        * `alpha` :  
            reflection coefficient  

        """
        return _pysgpp_swig.OptNelderMead_setAlpha(self, alpha)

    def getBeta(self) -> "double":
        r"""


        Returns
        -------
        expansion coefficient  

        """
        return _pysgpp_swig.OptNelderMead_getBeta(self)

    def setBeta(self, beta: "double") -> "void":
        r"""


        Parameters
        ----------
        * `beta` :  
            expansion coefficient  

        """
        return _pysgpp_swig.OptNelderMead_setBeta(self, beta)

    def getGamma(self) -> "double":
        r"""


        Returns
        -------
        contraction coefficient  

        """
        return _pysgpp_swig.OptNelderMead_getGamma(self)

    def setGamma(self, gamma: "double") -> "void":
        r"""


        Parameters
        ----------
        * `gamma` :  
            contraction coefficient  

        """
        return _pysgpp_swig.OptNelderMead_setGamma(self, gamma)

    def getDelta(self) -> "double":
        r"""


        Returns
        -------
        shrinking coefficient  

        """
        return _pysgpp_swig.OptNelderMead_getDelta(self)

    def setDelta(self, delta: "double") -> "void":
        r"""


        Parameters
        ----------
        * `delta` :  
            shrinking coefficient  

        """
        return _pysgpp_swig.OptNelderMead_setDelta(self, delta)

# Register OptNelderMead in _pysgpp_swig:
_pysgpp_swig.OptNelderMead_swigregister(OptNelderMead)

class OptNewton(OptUnconstrainedOptimizer):
    r"""

    `Newton(f, fHessian, maxItCount, beta, gamma, tolerance, epsilon, alpha1,
        alpha2, p, sleSolver)`  
    `Newton(f, fHessian, maxItCount=DEFAULT_N, beta=DEFAULT_BETA,
        gamma=DEFAULT_GAMMA, tolerance=DEFAULT_TOLERANCE, epsilon=DEFAULT_EPSILON,
        alpha1=DEFAULT_ALPHA1, alpha2=DEFAULT_ALPHA2, p=DEFAULT_P)`  
    `Newton(other)`  

    Gradient-based nonlinear conjugate gradient method.  

    The method is restarted with the steepest descent direction if the inner product
    of negated gradient and search direction is not big enough (criterion depending
    on three parameters).  

    Constructors
    ------------
    * `Newton(f, fHessian, maxItCount, beta, gamma, tolerance, epsilon, alpha1,
        alpha2, p, sleSolver)`  

        Constructor.  

        Do not destruct the solver before this object!  

        Parameters:  
        * `f` :  
            objective function  
        * `fHessian` :  
            objective function Hessian  
        * `maxItCount` :  
            maximal number of iterations  
        * `beta` :  
            beta (parameter for Armijo's rule)  
        * `gamma` :  
            gamma (parameter for Armijo's rule)  
        * `tolerance` :  
            tolerance (parameter for Armijo's rule)  
        * `epsilon` :  
            epsilon (parameter for Armijo's rule)  
        * `alpha1` :  
            steepest descent restart parameter 1  
        * `alpha2` :  
            steepest descent restart parameter 2  
        * `p` :  
            steepest descent restart exponent  
        * `sleSolver` :  
            reference to linear solver for solving the linear systems (Hessian as
            coefficient matrix)  

    * `Newton(f, fHessian, maxItCount=DEFAULT_N, beta=DEFAULT_BETA,
        gamma=DEFAULT_GAMMA, tolerance=DEFAULT_TOLERANCE, epsilon=DEFAULT_EPSILON,
        alpha1=DEFAULT_ALPHA1, alpha2=DEFAULT_ALPHA2, p=DEFAULT_P)`  

        Constructor.  

        By default, GaussianElimination is used to solve the linear systems.  

        Parameters:  
        * `f` :  
            objective function  
        * `fHessian` :  
            objective function Hessian  
        * `maxItCount` :  
            maximal number of iterations  
        * `beta` :  
            beta (parameter for Armijo's rule)  
        * `gamma` :  
            gamma (parameter for Armijo's rule)  
        * `tolerance` :  
            tolerance (parameter for Armijo's rule)  
        * `epsilon` :  
            epsilon (parameter for Armijo's rule)  
        * `alpha1` :  
            steepest descent restart parameter 1  
        * `alpha2` :  
            steepest descent restart parameter 2  
        * `p` :  
            steepest descent restart exponent  

    * `Newton(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: Newton.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_BETA = _pysgpp_swig.OptNewton_DEFAULT_BETA
    DEFAULT_GAMMA = _pysgpp_swig.OptNewton_DEFAULT_GAMMA
    DEFAULT_TOLERANCE = _pysgpp_swig.OptNewton_DEFAULT_TOLERANCE
    DEFAULT_EPSILON = _pysgpp_swig.OptNewton_DEFAULT_EPSILON
    DEFAULT_ALPHA1 = _pysgpp_swig.OptNewton_DEFAULT_ALPHA1
    DEFAULT_ALPHA2 = _pysgpp_swig.OptNewton_DEFAULT_ALPHA2
    DEFAULT_P = _pysgpp_swig.OptNewton_DEFAULT_P

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `Newton(f, fHessian, maxItCount, beta, gamma, tolerance, epsilon, alpha1,
            alpha2, p, sleSolver)`  

            Constructor.  

            Do not destruct the solver before this object!  

            Parameters:  
            * `f` :  
                objective function  
            * `fHessian` :  
                objective function Hessian  
            * `maxItCount` :  
                maximal number of iterations  
            * `beta` :  
                beta (parameter for Armijo's rule)  
            * `gamma` :  
                gamma (parameter for Armijo's rule)  
            * `tolerance` :  
                tolerance (parameter for Armijo's rule)  
            * `epsilon` :  
                epsilon (parameter for Armijo's rule)  
            * `alpha1` :  
                steepest descent restart parameter 1  
            * `alpha2` :  
                steepest descent restart parameter 2  
            * `p` :  
                steepest descent restart exponent  
            * `sleSolver` :  
                reference to linear solver for solving the linear systems (Hessian as
                coefficient matrix)  

        * `Newton(f, fHessian, maxItCount=DEFAULT_N, beta=DEFAULT_BETA,
            gamma=DEFAULT_GAMMA, tolerance=DEFAULT_TOLERANCE, epsilon=DEFAULT_EPSILON,
            alpha1=DEFAULT_ALPHA1, alpha2=DEFAULT_ALPHA2, p=DEFAULT_P)`  

            Constructor.  

            By default, GaussianElimination is used to solve the linear systems.  

            Parameters:  
            * `f` :  
                objective function  
            * `fHessian` :  
                objective function Hessian  
            * `maxItCount` :  
                maximal number of iterations  
            * `beta` :  
                beta (parameter for Armijo's rule)  
            * `gamma` :  
                gamma (parameter for Armijo's rule)  
            * `tolerance` :  
                tolerance (parameter for Armijo's rule)  
            * `epsilon` :  
                epsilon (parameter for Armijo's rule)  
            * `alpha1` :  
                steepest descent restart parameter 1  
            * `alpha2` :  
                steepest descent restart parameter 2  
            * `p` :  
                steepest descent restart exponent  

        * `Newton(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        """
        _pysgpp_swig.OptNewton_swiginit(self, _pysgpp_swig.new_OptNewton(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptNewton

    def getBeta(self) -> "double":
        r"""


        Returns
        -------
        beta (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNewton_getBeta(self)

    def setBeta(self, beta: "double") -> "void":
        r"""


        Parameters
        ----------
        * `beta` :  
            beta (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNewton_setBeta(self, beta)

    def getGamma(self) -> "double":
        r"""


        Returns
        -------
        gamma (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNewton_getGamma(self)

    def setGamma(self, gamma: "double") -> "void":
        r"""


        Parameters
        ----------
        * `gamma` :  
            gamma (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNewton_setGamma(self, gamma)

    def getTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNewton_getTolerance(self)

    def setTolerance(self, tolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `tolerance` :  
            tolerance (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNewton_setTolerance(self, tolerance)

    def getEpsilon(self) -> "double":
        r"""


        Returns
        -------
        epsilon (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNewton_getEpsilon(self)

    def setEpsilon(self, epsilon: "double") -> "void":
        r"""


        Parameters
        ----------
        * `epsilon` :  
            epsilon (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNewton_setEpsilon(self, epsilon)

    def getAlpha1(self) -> "double":
        r"""


        Returns
        -------
        steepest descent restart parameter 1  

        """
        return _pysgpp_swig.OptNewton_getAlpha1(self)

    def setAlpha1(self, alpha1: "double") -> "void":
        r"""


        Parameters
        ----------
        * `alpha1` :  
            steepest descent restart parameter 1  

        """
        return _pysgpp_swig.OptNewton_setAlpha1(self, alpha1)

    def getAlpha2(self) -> "double":
        r"""


        Returns
        -------
        steepest descent restart parameter 2  

        """
        return _pysgpp_swig.OptNewton_getAlpha2(self)

    def setAlpha2(self, alpha2: "double") -> "void":
        r"""


        Parameters
        ----------
        * `alpha2` :  
            steepest descent restart parameter 2  

        """
        return _pysgpp_swig.OptNewton_setAlpha2(self, alpha2)

    def getP(self) -> "double":
        r"""


        Returns
        -------
        steepest descent restart exponent  

        """
        return _pysgpp_swig.OptNewton_getP(self)

    def setP(self, p: "double") -> "void":
        r"""


        Parameters
        ----------
        * `p` :  
            steepest descent restart exponent  

        """
        return _pysgpp_swig.OptNewton_setP(self, p)

# Register OptNewton in _pysgpp_swig:
_pysgpp_swig.OptNewton_swigregister(OptNewton)

class OptNLCG(OptUnconstrainedOptimizer):
    r"""

    `NLCG(f, fGradient, maxItCount=DEFAULT_N, beta=DEFAULT_BETA,
        gamma=DEFAULT_GAMMA, tolerance=DEFAULT_TOLERANCE, epsilon=DEFAULT_EPSILON,
        restartThreshold=DEFAULT_RESTART_THRESHOLD)`  
    `NLCG(other)`  

    Gradient-based nonlinear conjugate gradient method.  

    The method is restarted with the steepest descent direction if the normalized
    absolute value of the inner product of two successive gradients exceeds a
    "restart threshold" $\alpha$.  

    Constructors
    ------------
    * `NLCG(f, fGradient, maxItCount=DEFAULT_N, beta=DEFAULT_BETA,
        gamma=DEFAULT_GAMMA, tolerance=DEFAULT_TOLERANCE, epsilon=DEFAULT_EPSILON,
        restartThreshold=DEFAULT_RESTART_THRESHOLD)`  

        Constructor.  

        Parameters:  
        * `f` :  
            objective function  
        * `fGradient` :  
            objective function gradient  
        * `maxItCount` :  
            maximal number of iterations  
        * `beta` :  
            beta (parameter for Armijo's rule)  
        * `gamma` :  
            gamma (parameter for Armijo's rule)  
        * `tolerance` :  
            tolerance (parameter for Armijo's rule)  
        * `epsilon` :  
            epsilon (parameter for Armijo's rule)  
        * `restartThreshold` :  
            restart threshold  

    * `NLCG(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: NLCG.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_BETA = _pysgpp_swig.OptNLCG_DEFAULT_BETA
    DEFAULT_GAMMA = _pysgpp_swig.OptNLCG_DEFAULT_GAMMA
    DEFAULT_TOLERANCE = _pysgpp_swig.OptNLCG_DEFAULT_TOLERANCE
    DEFAULT_EPSILON = _pysgpp_swig.OptNLCG_DEFAULT_EPSILON
    DEFAULT_RESTART_THRESHOLD = _pysgpp_swig.OptNLCG_DEFAULT_RESTART_THRESHOLD

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `NLCG(f, fGradient, maxItCount=DEFAULT_N, beta=DEFAULT_BETA,
            gamma=DEFAULT_GAMMA, tolerance=DEFAULT_TOLERANCE, epsilon=DEFAULT_EPSILON,
            restartThreshold=DEFAULT_RESTART_THRESHOLD)`  

            Constructor.  

            Parameters:  
            * `f` :  
                objective function  
            * `fGradient` :  
                objective function gradient  
            * `maxItCount` :  
                maximal number of iterations  
            * `beta` :  
                beta (parameter for Armijo's rule)  
            * `gamma` :  
                gamma (parameter for Armijo's rule)  
            * `tolerance` :  
                tolerance (parameter for Armijo's rule)  
            * `epsilon` :  
                epsilon (parameter for Armijo's rule)  
            * `restartThreshold` :  
                restart threshold  

        * `NLCG(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        """
        _pysgpp_swig.OptNLCG_swiginit(self, _pysgpp_swig.new_OptNLCG(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptNLCG

    def getBeta(self) -> "double":
        r"""


        Returns
        -------
        beta (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNLCG_getBeta(self)

    def setBeta(self, beta: "double") -> "void":
        r"""


        Parameters
        ----------
        * `beta` :  
            beta (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNLCG_setBeta(self, beta)

    def getGamma(self) -> "double":
        r"""


        Returns
        -------
        gamma (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNLCG_getGamma(self)

    def setGamma(self, gamma: "double") -> "void":
        r"""


        Parameters
        ----------
        * `gamma` :  
            gamma (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNLCG_setGamma(self, gamma)

    def getTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNLCG_getTolerance(self)

    def setTolerance(self, tolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `tolerance` :  
            tolerance (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNLCG_setTolerance(self, tolerance)

    def getEpsilon(self) -> "double":
        r"""


        Returns
        -------
        epsilon (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNLCG_getEpsilon(self)

    def setEpsilon(self, epsilon: "double") -> "void":
        r"""


        Parameters
        ----------
        * `epsilon` :  
            epsilon (parameter for Armijo's rule)  

        """
        return _pysgpp_swig.OptNLCG_setEpsilon(self, epsilon)

    def getRestartThreshold(self) -> "double":
        r"""


        Returns
        -------
        restart threshold  

        """
        return _pysgpp_swig.OptNLCG_getRestartThreshold(self)

    def setRestartThreshold(self, restartThreshold: "double") -> "void":
        r"""


        Parameters
        ----------
        * `restartThreshold` :  
            restart threshold  

        """
        return _pysgpp_swig.OptNLCG_setRestartThreshold(self, restartThreshold)

# Register OptNLCG in _pysgpp_swig:
_pysgpp_swig.OptNLCG_swigregister(OptNLCG)

class OptRprop(OptUnconstrainedOptimizer):
    r"""

    `Rprop(f, fGradient, maxItCount=DEFAULT_N, tolerance=DEFAULT_TOLERANCE,
        initialStepSize=DEFAULT_INITIAL_STEP_SIZE,
        stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
        stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR)`  
    `Rprop(other)`  

    Rprop method for unconstrained optimization.  

    Constructors
    ------------
    * `Rprop(f, fGradient, maxItCount=DEFAULT_N, tolerance=DEFAULT_TOLERANCE,
        initialStepSize=DEFAULT_INITIAL_STEP_SIZE,
        stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
        stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR)`  

        Constructor.  

        Parameters:  
        * `f` :  
            objective function  
        * `fGradient` :  
            objective function gradient  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `tolerance` :  
            tolerance  
        * `initialStepSize` :  
            initial step size  
        * `stepSizeIncreaseFactor` :  
            step size increase factor  
        * `stepSizeDecreaseFactor` :  
            step size decrease factor  

    * `Rprop(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: Rprop.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_TOLERANCE = _pysgpp_swig.OptRprop_DEFAULT_TOLERANCE
    DEFAULT_INITIAL_STEP_SIZE = _pysgpp_swig.OptRprop_DEFAULT_INITIAL_STEP_SIZE
    DEFAULT_STEP_SIZE_INCREASE_FACTOR = _pysgpp_swig.OptRprop_DEFAULT_STEP_SIZE_INCREASE_FACTOR
    DEFAULT_STEP_SIZE_DECREASE_FACTOR = _pysgpp_swig.OptRprop_DEFAULT_STEP_SIZE_DECREASE_FACTOR

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `Rprop(f, fGradient, maxItCount=DEFAULT_N, tolerance=DEFAULT_TOLERANCE,
            initialStepSize=DEFAULT_INITIAL_STEP_SIZE,
            stepSizeIncreaseFactor=DEFAULT_STEP_SIZE_INCREASE_FACTOR,
            stepSizeDecreaseFactor=DEFAULT_STEP_SIZE_DECREASE_FACTOR)`  

            Constructor.  

            Parameters:  
            * `f` :  
                objective function  
            * `fGradient` :  
                objective function gradient  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `tolerance` :  
                tolerance  
            * `initialStepSize` :  
                initial step size  
            * `stepSizeIncreaseFactor` :  
                step size increase factor  
            * `stepSizeDecreaseFactor` :  
                step size decrease factor  

        * `Rprop(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        """
        _pysgpp_swig.OptRprop_swiginit(self, _pysgpp_swig.new_OptRprop(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptRprop

    def getTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance  

        """
        return _pysgpp_swig.OptRprop_getTolerance(self)

    def setTolerance(self, tolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `tolerance` :  
            tolerance  

        """
        return _pysgpp_swig.OptRprop_setTolerance(self, tolerance)

    def getInitialStepSize(self) -> "double":
        r"""


        Returns
        -------
        initial step size  

        """
        return _pysgpp_swig.OptRprop_getInitialStepSize(self)

    def setInitialStepSize(self, initialStepSize: "double") -> "void":
        r"""


        Parameters
        ----------
        * `initialStepSize` :  
            initial step size  

        """
        return _pysgpp_swig.OptRprop_setInitialStepSize(self, initialStepSize)

    def getStepSizeIncreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        step size increase factor  

        """
        return _pysgpp_swig.OptRprop_getStepSizeIncreaseFactor(self)

    def setStepSizeIncreaseFactor(self, stepSizeIncreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `stepSizeIncreaseFactor` :  
            step size increase factor  

        """
        return _pysgpp_swig.OptRprop_setStepSizeIncreaseFactor(self, stepSizeIncreaseFactor)

    def getStepSizeDecreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        step size decrease factor  

        """
        return _pysgpp_swig.OptRprop_getStepSizeDecreaseFactor(self)

    def setStepSizeDecreaseFactor(self, stepSizeDecreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `stepSizeDecreaseFactor` :  
            step size decrease factor  

        """
        return _pysgpp_swig.OptRprop_setStepSizeDecreaseFactor(self, stepSizeDecreaseFactor)

# Register OptRprop in _pysgpp_swig:
_pysgpp_swig.OptRprop_swigregister(OptRprop)

class OptLeastSquaresOptimizer(object):
    r"""

    `LeastSquaresOptimizer(phi, N=DEFAULT_N)`  
    `LeastSquaresOptimizer(other)`  

    Abstract class for solving non-linear least squares problems.  

    Constructors
    ------------
    * `LeastSquaresOptimizer(phi, N=DEFAULT_N)`  

        Constructor.  

        The starting point is set to $(0.5, \dotsc, 0.5)^{\mathrm{T}}$.  

        Parameters:  
        * `phi` :  
            phi function  
        * `N` :  
            maximal number of iterations or function evaluations (depending on the
            implementation)  

    * `LeastSquaresOptimizer(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: LeastSquaresOptimizer.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DEFAULT_N = _pysgpp_swig.OptLeastSquaresOptimizer_DEFAULT_N
    __swig_destroy__ = _pysgpp_swig.delete_OptLeastSquaresOptimizer

    def optimize(self) -> "void":
        r"""


        Pure virtual method for optimization of the objective function.  

        The result of the optimization process can be obtained by member functions,
        e.g., getOptimalPoint() and getOptimalValue().  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_optimize(self)

    def getPhiFunction(self) -> "sgpp::base::VectorFunction &":
        r"""


        Returns
        -------
        phi  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_getPhiFunction(self)

    def setPhiFunction(self, phi: "VectorFunction") -> "void":
        r"""


        Parameters
        ----------
        * `phi` :  
            phi  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_setPhiFunction(self, phi)

    def getN(self) -> "size_t":
        r"""


        Returns
        -------
        maximal number of iterations or function evaluations  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_getN(self)

    def setN(self, N: "size_t") -> "void":
        r"""


        Parameters
        ----------
        * `N` :  
            maximal number of iterations or function evaluations  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_setN(self, N)

    def getStartingPoint(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        starting point  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_getStartingPoint(self)

    def setStartingPoint(self, startingPoint: "DataVector") -> "void":
        r"""


        Parameters
        ----------
        * `startingPoint` :  
            starting point  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_setStartingPoint(self, startingPoint)

    def getOptimalPoint(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        result of optimization (location of optimum), empty vector on error  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_getOptimalPoint(self)

    def getOptimalValue(self) -> "double":
        r"""


        Returns
        -------
        result of optimization (optimal function value), NAN on error  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_getOptimalValue(self)

    def getHistoryOfOptimalPoints(self) -> "sgpp::base::DataMatrix const &":
        r"""


        Returns
        -------
        tall matrix (d columns) in which the k-th row indicates the best point after k
        iterations of the optimization, empty matrix on error or if not supported  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_getHistoryOfOptimalPoints(self)

    def getHistoryOfOptimalValues(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        vector in which the k-th entry indicates the best function value after k
        iterations of the optimization, empty vector on error or if not supported  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_getHistoryOfOptimalValues(self)

    def clone(self, clone: "std::unique_ptr< sgpp::optimization::optimizer::LeastSquaresOptimizer > &") -> "void":
        r"""


        Pure virtual method for cloning the optimizer.  

        It should generate a pointer to the cloned object and it's used for parallel
        computations.  

        Parameters
        ----------
        * `clone` :  
            pointer to cloned object  

        """
        return _pysgpp_swig.OptLeastSquaresOptimizer_clone(self, clone)

# Register OptLeastSquaresOptimizer in _pysgpp_swig:
_pysgpp_swig.OptLeastSquaresOptimizer_swigregister(OptLeastSquaresOptimizer)

class OptLevenbergMarquardt(OptLeastSquaresOptimizer):
    r"""

    `LevenbergMarquardt(phi, phiGradient, maxItCount, tolerance, initialDamping,
        acceptanceThreshold, effectivenessThreshold, sleSolver)`  
    `LevenbergMarquardt(phi, phiGradient, maxItCount=DEFAULT_N,
        tolerance=DEFAULT_TOLERANCE, initialDamping=DEFAULT_INITIAL_DAMPING,
        acceptanceThreshold=DEFAULT_ACCEPTANCE_THRESHOLD,
        effectivenessThreshold=DEFAULT_EFFECTIVENESS_THRESHOLD)`  
    `LevenbergMarquardt(other)`  

    Levenberg-Marquardt algorithm for least squares optimization.  

    Constructors
    ------------
    * `LevenbergMarquardt(phi, phiGradient, maxItCount, tolerance, initialDamping,
        acceptanceThreshold, effectivenessThreshold, sleSolver)`  

        Constructor.  

        Do not destruct the solver before this object!  

        Parameters:  
        * `phi` :  
            phi function  
        * `phiGradient` :  
            Jacobian of phi  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `tolerance` :  
            tolerance  
        * `initialDamping` :  
            initial damping  
        * `acceptanceThreshold` :  
            acceptance threshold  
        * `effectivenessThreshold` :  
            effectiveness threshold  
        * `sleSolver` :  
            reference to linear solver for solving the linear systems  

    * `LevenbergMarquardt(phi, phiGradient, maxItCount=DEFAULT_N,
        tolerance=DEFAULT_TOLERANCE, initialDamping=DEFAULT_INITIAL_DAMPING,
        acceptanceThreshold=DEFAULT_ACCEPTANCE_THRESHOLD,
        effectivenessThreshold=DEFAULT_EFFECTIVENESS_THRESHOLD)`  

        Constructor.  

        By default, GaussianElimination is used to solve the linear systems.  

        Parameters:  
        * `phi` :  
            base function  
        * `phiGradient` :  
            Jacobian of phi  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `tolerance` :  
            tolerance  
        * `initialDamping` :  
            initial damping  
        * `acceptanceThreshold` :  
            acceptance threshold  
        * `effectivenessThreshold` :  
            effectiveness threshold  

    * `LevenbergMarquardt(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    C++ includes: LevenbergMarquardt.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_TOLERANCE = _pysgpp_swig.OptLevenbergMarquardt_DEFAULT_TOLERANCE
    DEFAULT_INITIAL_DAMPING = _pysgpp_swig.OptLevenbergMarquardt_DEFAULT_INITIAL_DAMPING
    DEFAULT_ACCEPTANCE_THRESHOLD = _pysgpp_swig.OptLevenbergMarquardt_DEFAULT_ACCEPTANCE_THRESHOLD
    DEFAULT_EFFECTIVENESS_THRESHOLD = _pysgpp_swig.OptLevenbergMarquardt_DEFAULT_EFFECTIVENESS_THRESHOLD

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `LevenbergMarquardt(phi, phiGradient, maxItCount, tolerance, initialDamping,
            acceptanceThreshold, effectivenessThreshold, sleSolver)`  

            Constructor.  

            Do not destruct the solver before this object!  

            Parameters:  
            * `phi` :  
                phi function  
            * `phiGradient` :  
                Jacobian of phi  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `tolerance` :  
                tolerance  
            * `initialDamping` :  
                initial damping  
            * `acceptanceThreshold` :  
                acceptance threshold  
            * `effectivenessThreshold` :  
                effectiveness threshold  
            * `sleSolver` :  
                reference to linear solver for solving the linear systems  

        * `LevenbergMarquardt(phi, phiGradient, maxItCount=DEFAULT_N,
            tolerance=DEFAULT_TOLERANCE, initialDamping=DEFAULT_INITIAL_DAMPING,
            acceptanceThreshold=DEFAULT_ACCEPTANCE_THRESHOLD,
            effectivenessThreshold=DEFAULT_EFFECTIVENESS_THRESHOLD)`  

            Constructor.  

            By default, GaussianElimination is used to solve the linear systems.  

            Parameters:  
            * `phi` :  
                base function  
            * `phiGradient` :  
                Jacobian of phi  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `tolerance` :  
                tolerance  
            * `initialDamping` :  
                initial damping  
            * `acceptanceThreshold` :  
                acceptance threshold  
            * `effectivenessThreshold` :  
                effectiveness threshold  

        * `LevenbergMarquardt(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        """
        _pysgpp_swig.OptLevenbergMarquardt_swiginit(self, _pysgpp_swig.new_OptLevenbergMarquardt(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptLevenbergMarquardt

    def getPhiGradient(self) -> "sgpp::base::VectorFunctionGradient &":
        r"""


        Returns
        -------
        phi gradient  

        """
        return _pysgpp_swig.OptLevenbergMarquardt_getPhiGradient(self)

    def getTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance  

        """
        return _pysgpp_swig.OptLevenbergMarquardt_getTolerance(self)

    def setTolerance(self, tolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `tolerance` :  
            tolerance  

        """
        return _pysgpp_swig.OptLevenbergMarquardt_setTolerance(self, tolerance)

    def getInitialDamping(self) -> "double":
        r"""


        Returns
        -------
        initial damping  

        """
        return _pysgpp_swig.OptLevenbergMarquardt_getInitialDamping(self)

    def setInitialDamping(self, initialDamping: "double") -> "void":
        r"""


        Parameters
        ----------
        * `initialDamping` :  
            initial damping  

        """
        return _pysgpp_swig.OptLevenbergMarquardt_setInitialDamping(self, initialDamping)

    def getAcceptanceThreshold(self) -> "double":
        r"""


        Returns
        -------
        acceptanceThreshold  

        """
        return _pysgpp_swig.OptLevenbergMarquardt_getAcceptanceThreshold(self)

    def setAcceptanceThreshold(self, acceptanceThreshold: "double") -> "void":
        r"""


        Parameters
        ----------
        * `acceptanceThreshold` :  
            acceptance threshold  

        """
        return _pysgpp_swig.OptLevenbergMarquardt_setAcceptanceThreshold(self, acceptanceThreshold)

    def getEffectivenessThreshold(self) -> "double":
        r"""


        Returns
        -------
        effectiveness threshold  

        """
        return _pysgpp_swig.OptLevenbergMarquardt_getEffectivenessThreshold(self)

    def setEffectivenessThreshold(self, effectivenessThreshold: "double") -> "void":
        r"""


        Parameters
        ----------
        * `effectivenessThreshold` :  
            effectiveness threshold  

        """
        return _pysgpp_swig.OptLevenbergMarquardt_setEffectivenessThreshold(self, effectivenessThreshold)

# Register OptLevenbergMarquardt in _pysgpp_swig:
_pysgpp_swig.OptLevenbergMarquardt_swigregister(OptLevenbergMarquardt)

class OptConstrainedOptimizer(OptUnconstrainedOptimizer):
    r"""

    `ConstrainedOptimizer(f, fGradient, g, gGradient, h, hGradient, N=DEFAULT_N)`  
    `ConstrainedOptimizer(f, g, h, N=DEFAULT_N)`  
    `ConstrainedOptimizer(other)`  
    `ConstrainedOptimizer(unconstrainedOptimizer, g, gGradient, h, hGradient,
        N=DEFAULT_N)`  

    Abstract class for solving constrained optimization problems.  

    Constructors
    ------------
    * `ConstrainedOptimizer(f, fGradient, g, gGradient, h, hGradient, N=DEFAULT_N)`  

        Constructor.  

        By default, adaptive gradient descent is used as optimization algorithm
        (gradient-based). The starting point is set to $(0.5, \dotsc,
        0.5)^{\mathrm{T}}$. Depending on the implementation $g$ and/or $h$ may be
        ignored (if only equality or inequality constraints can be handled by the
        underlying algorithm).  

        Parameters:  
        * `f` :  
            function to optimize  
        * `fGradient` :  
            gradient of f  
        * `g` :  
            inequality constraint function ( $g(\vec{x}) \le 0$)  
        * `gGradient` :  
            gradient of g  
        * `h` :  
            equality constraint function ( $h(\vec{x}) = 0$)  
        * `hGradient` :  
            gradient of h  
        * `N` :  
            maximal number of iterations or objective function evaluations
            (depending on the implementation)  

    * `ConstrainedOptimizer(f, g, h, N=DEFAULT_N)`  

        Constructor.  

        By default, Nelder-Mead is used as optimization algorithm (gradient-free).
        The starting point is set to $(0.5, \dotsc, 0.5)^{\mathrm{T}}$. Depending
        on the implementation $g$ and/or $h$ may be ignored (if only equality or
        inequality constraints can be handled by the underlying algorithm).  

        Parameters:  
        * `f` :  
            function to optimize  
        * `g` :  
            inequality constraint function ( $g(\vec{x}) \le 0$)  
        * `h` :  
            equality constraint function ( $h(\vec{x}) = 0$)  
        * `N` :  
            maximal number of iterations or objective function evaluations
            (depending on the implementation)  

    * `ConstrainedOptimizer(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    * `ConstrainedOptimizer(unconstrainedOptimizer, g, gGradient, h, hGradient,
        N=DEFAULT_N)`  

        Constructor with custom unconstrained optimization algorithm (gradient-free
        or gradient-based).  

        The starting point is set to $(0.5, \dotsc, 0.5)^{\mathrm{T}}$. Depending
        on the implementation $g$ and/or $h$ may be ignored (if only equality or
        inequality constraints can be handled by the underlying algorithm).  

        Parameters:  
        * `unconstrainedOptimizer` :  
            unconstrained optimizer  
        * `g` :  
            inequality constraint function ( $g(\vec{x}) \le 0$)  
        * `gGradient` :  
            gradient of g (nullptr to omit)  
        * `h` :  
            equality constraint function ( $h(\vec{x}) = 0$)  
        * `hGradient` :  
            gradient of h (nullptr to omit)  
        * `N` :  
            maximal number of iterations or objective function evaluations
            (depending on the implementation)  

    C++ includes: ConstrainedOptimizer.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OptConstrainedOptimizer

    def getInequalityConstraintFunction(self) -> "sgpp::base::VectorFunction &":
        r"""


        Returns
        -------
        inequality constraint function  

        """
        return _pysgpp_swig.OptConstrainedOptimizer_getInequalityConstraintFunction(self)

    def setInequalityConstraintFunction(self, g: "VectorFunction") -> "void":
        r"""


        Parameters
        ----------
        * `g` :  
            inequality constraint function  

        """
        return _pysgpp_swig.OptConstrainedOptimizer_setInequalityConstraintFunction(self, g)

    def getInequalityConstraintGradient(self) -> "sgpp::base::VectorFunctionGradient *":
        r"""


        Returns
        -------
        inequality constraint function gradient  

        """
        return _pysgpp_swig.OptConstrainedOptimizer_getInequalityConstraintGradient(self)

    def setInequalityConstraintGradient(self, gGradient: "VectorFunctionGradient") -> "void":
        r"""


        Parameters
        ----------
        * `gGradient` :  
            inequality constraint function gradient  

        """
        return _pysgpp_swig.OptConstrainedOptimizer_setInequalityConstraintGradient(self, gGradient)

    def getEqualityConstraintFunction(self) -> "sgpp::base::VectorFunction &":
        r"""


        Returns
        -------
        equality constraint function  

        """
        return _pysgpp_swig.OptConstrainedOptimizer_getEqualityConstraintFunction(self)

    def setEqualityConstraintFunction(self, h: "VectorFunction") -> "void":
        r"""


        Parameters
        ----------
        * `h` :  
            equality constraint function  

        """
        return _pysgpp_swig.OptConstrainedOptimizer_setEqualityConstraintFunction(self, h)

    def getEqualityConstraintGradient(self) -> "sgpp::base::VectorFunctionGradient *":
        r"""


        Returns
        -------
        equality constraint function gradient  

        """
        return _pysgpp_swig.OptConstrainedOptimizer_getEqualityConstraintGradient(self)

    def setEqualityConstraintGradient(self, hGradient: "VectorFunctionGradient") -> "void":
        r"""


        Parameters
        ----------
        * `hGradient` :  
            equality constraint function gradient  

        """
        return _pysgpp_swig.OptConstrainedOptimizer_setEqualityConstraintGradient(self, hGradient)

# Register OptConstrainedOptimizer in _pysgpp_swig:
_pysgpp_swig.OptConstrainedOptimizer_swigregister(OptConstrainedOptimizer)

class OptAugmentedLagrangian(OptConstrainedOptimizer):
    r"""

    `AugmentedLagrangian(other)`  
    `AugmentedLagrangian(f, fGradient, g, gGradient, h, hGradient,
        maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  
    `AugmentedLagrangian(f, g, h, maxItCount=DEFAULT_N,
        xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  
    `AugmentedLagrangian(unconstrainedOptimizer, g, gGradient, h, hGradient,
        maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

    Augmented Lagrangian method for constrained optimization.  

    Constructors
    ------------
    * `AugmentedLagrangian(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    * `AugmentedLagrangian(f, fGradient, g, gGradient, h, hGradient,
        maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

        Constructor with adaptive gradient descent as optimization algorithm
        (gradient-based).  

        Parameters:  
        * `f` :  
            objective function  
        * `fGradient` :  
            objective function gradient  
        * `g` :  
            inequality constraint  
        * `gGradient` :  
            inequality constraint gradient  
        * `h` :  
            equality constraint  
        * `hGradient` :  
            equality constraint gradient  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `xTolerance` :  
            point tolerance  
        * `constraintTolerance` :  
            constraint tolerance  
        * `penaltyStartValue` :  
            penalty start value  
        * `penaltyIncreaseFactor` :  
            penalty increase factor  

    * `AugmentedLagrangian(f, g, h, maxItCount=DEFAULT_N,
        xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

        Constructor with Nelder-Mead as optimization algorithm (gradient-free).  

        Parameters:  
        * `f` :  
            objective function  
        * `g` :  
            inequality constraint  
        * `h` :  
            equality constraint  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `xTolerance` :  
            point tolerance  
        * `constraintTolerance` :  
            constraint tolerance  
        * `penaltyStartValue` :  
            penalty start value  
        * `penaltyIncreaseFactor` :  
            penalty increase factor  

    * `AugmentedLagrangian(unconstrainedOptimizer, g, gGradient, h, hGradient,
        maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

        Constructor with custom unconstrained optimization algorithm (gradient-free
        or gradient-based).  

        Parameters:  
        * `unconstrainedOptimizer` :  
            unconstrained optimization algorithm  
        * `g` :  
            inequality constraint  
        * `gGradient` :  
            inequality constraint gradient (nullptr to omit)  
        * `h` :  
            equality constraint  
        * `hGradient` :  
            equality constraint gradient (nullptr to omit)  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `xTolerance` :  
            point tolerance  
        * `constraintTolerance` :  
            constraint tolerance  
        * `penaltyStartValue` :  
            penalty start value  
        * `penaltyIncreaseFactor` :  
            penalty increase factor  

    C++ includes: AugmentedLagrangian.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_X_TOLERANCE = _pysgpp_swig.OptAugmentedLagrangian_DEFAULT_X_TOLERANCE
    DEFAULT_CONSTRAINT_TOLERANCE = _pysgpp_swig.OptAugmentedLagrangian_DEFAULT_CONSTRAINT_TOLERANCE
    DEFAULT_PENALTY_START_VALUE = _pysgpp_swig.OptAugmentedLagrangian_DEFAULT_PENALTY_START_VALUE
    DEFAULT_PENALTY_INCREASE_FACTOR = _pysgpp_swig.OptAugmentedLagrangian_DEFAULT_PENALTY_INCREASE_FACTOR

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `AugmentedLagrangian(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        * `AugmentedLagrangian(f, fGradient, g, gGradient, h, hGradient,
            maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
            constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
            penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
            penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

            Constructor with adaptive gradient descent as optimization algorithm
            (gradient-based).  

            Parameters:  
            * `f` :  
                objective function  
            * `fGradient` :  
                objective function gradient  
            * `g` :  
                inequality constraint  
            * `gGradient` :  
                inequality constraint gradient  
            * `h` :  
                equality constraint  
            * `hGradient` :  
                equality constraint gradient  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `xTolerance` :  
                point tolerance  
            * `constraintTolerance` :  
                constraint tolerance  
            * `penaltyStartValue` :  
                penalty start value  
            * `penaltyIncreaseFactor` :  
                penalty increase factor  

        * `AugmentedLagrangian(f, g, h, maxItCount=DEFAULT_N,
            xTolerance=DEFAULT_X_TOLERANCE,
            constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
            penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
            penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

            Constructor with Nelder-Mead as optimization algorithm (gradient-free).  

            Parameters:  
            * `f` :  
                objective function  
            * `g` :  
                inequality constraint  
            * `h` :  
                equality constraint  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `xTolerance` :  
                point tolerance  
            * `constraintTolerance` :  
                constraint tolerance  
            * `penaltyStartValue` :  
                penalty start value  
            * `penaltyIncreaseFactor` :  
                penalty increase factor  

        * `AugmentedLagrangian(unconstrainedOptimizer, g, gGradient, h, hGradient,
            maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
            constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
            penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
            penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

            Constructor with custom unconstrained optimization algorithm (gradient-free
            or gradient-based).  

            Parameters:  
            * `unconstrainedOptimizer` :  
                unconstrained optimization algorithm  
            * `g` :  
                inequality constraint  
            * `gGradient` :  
                inequality constraint gradient (nullptr to omit)  
            * `h` :  
                equality constraint  
            * `hGradient` :  
                equality constraint gradient (nullptr to omit)  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `xTolerance` :  
                point tolerance  
            * `constraintTolerance` :  
                constraint tolerance  
            * `penaltyStartValue` :  
                penalty start value  
            * `penaltyIncreaseFactor` :  
                penalty increase factor  

        """
        _pysgpp_swig.OptAugmentedLagrangian_swiginit(self, _pysgpp_swig.new_OptAugmentedLagrangian(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptAugmentedLagrangian

    def findFeasiblePoint(self) -> "sgpp::base::DataVector":
        r"""


        Try to find a feasible initial point by solving an auxiliary problem.  

        However, it is not guaranteed that the method works, i.e., it should be checked
        afterwards that the returned point is actually feasible.  

        Returns
        -------
        feasible point in $[0, 1]^d$  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_findFeasiblePoint(self)

    def getXTolerance(self) -> "double":
        r"""


        Returns
        -------
        point tolerance  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_getXTolerance(self)

    def setXTolerance(self, xTolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `xTolerance` :  
            point tolerance  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_setXTolerance(self, xTolerance)

    def getConstraintTolerance(self) -> "double":
        r"""


        Returns
        -------
        constraint tolerance  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_getConstraintTolerance(self)

    def setConstraintTolerance(self, constraintTolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `constraintTolerance` :  
            constraint tolerance  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_setConstraintTolerance(self, constraintTolerance)

    def getPenaltyStartValue(self) -> "double":
        r"""


        Returns
        -------
        penalty start value  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_getPenaltyStartValue(self)

    def setPenaltyStartValue(self, penaltyStartValue: "double") -> "void":
        r"""


        Parameters
        ----------
        * `penaltyStartValue` :  
            penalty start value  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_setPenaltyStartValue(self, penaltyStartValue)

    def getPenaltyIncreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        penalty increase factor  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_getPenaltyIncreaseFactor(self)

    def setPenaltyIncreaseFactor(self, penaltyIncreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `penaltyIncreaseFactor` :  
            penalty increase factor  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_setPenaltyIncreaseFactor(self, penaltyIncreaseFactor)

    def getHistoryOfInnerIterationPoints(self) -> "sgpp::base::DataMatrix const &":
        r"""


        Returns
        -------
        tall matrix (d columns) in which the history of optimal points of the iterations
        are concatenated  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_getHistoryOfInnerIterationPoints(self)

    def getHistoryOfInnerIterationNumbers(self) -> "std::vector< size_t,std::allocator< size_t > > const &":
        r"""


        Returns
        -------
        vector in which the k-th entry indicates the number of inner iterations in the
        k-th (outer) iteration, empty vector on error  

        """
        return _pysgpp_swig.OptAugmentedLagrangian_getHistoryOfInnerIterationNumbers(self)

# Register OptAugmentedLagrangian in _pysgpp_swig:
_pysgpp_swig.OptAugmentedLagrangian_swigregister(OptAugmentedLagrangian)

class OptLogBarrier(OptConstrainedOptimizer):
    r"""

    `LogBarrier(f, fGradient, g, gGradient, maxItCount=DEFAULT_N,
        tolerance=DEFAULT_TOLERANCE, barrierStartValue=DEFAULT_BARRIER_START_VALUE,
        barrierDecreaseFactor=DEFAULT_BARRIER_DECREASE_FACTOR)`  
    `LogBarrier(f, g, maxItCount=DEFAULT_N, tolerance=DEFAULT_TOLERANCE,
        barrierStartValue=DEFAULT_BARRIER_START_VALUE,
        barrierDecreaseFactor=DEFAULT_BARRIER_DECREASE_FACTOR)`  
    `LogBarrier(other)`  
    `LogBarrier(unconstrainedOptimizer, g, gGradient, maxItCount=DEFAULT_N,
        tolerance=DEFAULT_TOLERANCE, barrierStartValue=DEFAULT_BARRIER_START_VALUE,
        barrierDecreaseFactor=DEFAULT_BARRIER_DECREASE_FACTOR)`  

    Log Barrier method for constrained optimization.  

    Constructors
    ------------
    * `LogBarrier(f, fGradient, g, gGradient, maxItCount=DEFAULT_N,
        tolerance=DEFAULT_TOLERANCE, barrierStartValue=DEFAULT_BARRIER_START_VALUE,
        barrierDecreaseFactor=DEFAULT_BARRIER_DECREASE_FACTOR)`  

        Constructor with adaptive gradient descent as optimization algorithm
        (gradient-based).  

        Parameters:  
        * `f` :  
            objective function  
        * `fGradient` :  
            objective function gradient  
        * `g` :  
            inequality constraint  
        * `gGradient` :  
            inequality constraint gradient  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `tolerance` :  
            tolerance  
        * `barrierStartValue` :  
            barrier start value  
        * `barrierDecreaseFactor` :  
            barrier decrease factor  

    * `LogBarrier(f, g, maxItCount=DEFAULT_N, tolerance=DEFAULT_TOLERANCE,
        barrierStartValue=DEFAULT_BARRIER_START_VALUE,
        barrierDecreaseFactor=DEFAULT_BARRIER_DECREASE_FACTOR)`  

        Constructor with Nelder-Mead as optimization algorithm (gradient-free).  

        Parameters:  
        * `f` :  
            objective function  
        * `g` :  
            inequality constraint  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `tolerance` :  
            tolerance  
        * `barrierStartValue` :  
            barrier start value  
        * `barrierDecreaseFactor` :  
            barrier decrease factor  

    * `LogBarrier(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    * `LogBarrier(unconstrainedOptimizer, g, gGradient, maxItCount=DEFAULT_N,
        tolerance=DEFAULT_TOLERANCE, barrierStartValue=DEFAULT_BARRIER_START_VALUE,
        barrierDecreaseFactor=DEFAULT_BARRIER_DECREASE_FACTOR)`  

        Constructor with custom unconstrained optimization algorithm (gradient-free
        or gradient-based).  

        Parameters:  
        * `unconstrainedOptimizer` :  
            unconstrained optimization algorithm  
        * `g` :  
            inequality constraint  
        * `gGradient` :  
            inequality constraint gradient (nullptr to omit)  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `tolerance` :  
            tolerance  
        * `barrierStartValue` :  
            barrier start value  
        * `barrierDecreaseFactor` :  
            barrier decrease factor  

    C++ includes: LogBarrier.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_TOLERANCE = _pysgpp_swig.OptLogBarrier_DEFAULT_TOLERANCE
    DEFAULT_BARRIER_START_VALUE = _pysgpp_swig.OptLogBarrier_DEFAULT_BARRIER_START_VALUE
    DEFAULT_BARRIER_DECREASE_FACTOR = _pysgpp_swig.OptLogBarrier_DEFAULT_BARRIER_DECREASE_FACTOR

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `LogBarrier(f, fGradient, g, gGradient, maxItCount=DEFAULT_N,
            tolerance=DEFAULT_TOLERANCE, barrierStartValue=DEFAULT_BARRIER_START_VALUE,
            barrierDecreaseFactor=DEFAULT_BARRIER_DECREASE_FACTOR)`  

            Constructor with adaptive gradient descent as optimization algorithm
            (gradient-based).  

            Parameters:  
            * `f` :  
                objective function  
            * `fGradient` :  
                objective function gradient  
            * `g` :  
                inequality constraint  
            * `gGradient` :  
                inequality constraint gradient  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `tolerance` :  
                tolerance  
            * `barrierStartValue` :  
                barrier start value  
            * `barrierDecreaseFactor` :  
                barrier decrease factor  

        * `LogBarrier(f, g, maxItCount=DEFAULT_N, tolerance=DEFAULT_TOLERANCE,
            barrierStartValue=DEFAULT_BARRIER_START_VALUE,
            barrierDecreaseFactor=DEFAULT_BARRIER_DECREASE_FACTOR)`  

            Constructor with Nelder-Mead as optimization algorithm (gradient-free).  

            Parameters:  
            * `f` :  
                objective function  
            * `g` :  
                inequality constraint  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `tolerance` :  
                tolerance  
            * `barrierStartValue` :  
                barrier start value  
            * `barrierDecreaseFactor` :  
                barrier decrease factor  

        * `LogBarrier(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        * `LogBarrier(unconstrainedOptimizer, g, gGradient, maxItCount=DEFAULT_N,
            tolerance=DEFAULT_TOLERANCE, barrierStartValue=DEFAULT_BARRIER_START_VALUE,
            barrierDecreaseFactor=DEFAULT_BARRIER_DECREASE_FACTOR)`  

            Constructor with custom unconstrained optimization algorithm (gradient-free
            or gradient-based).  

            Parameters:  
            * `unconstrainedOptimizer` :  
                unconstrained optimization algorithm  
            * `g` :  
                inequality constraint  
            * `gGradient` :  
                inequality constraint gradient (nullptr to omit)  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `tolerance` :  
                tolerance  
            * `barrierStartValue` :  
                barrier start value  
            * `barrierDecreaseFactor` :  
                barrier decrease factor  

        """
        _pysgpp_swig.OptLogBarrier_swiginit(self, _pysgpp_swig.new_OptLogBarrier(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptLogBarrier

    def getTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance  

        """
        return _pysgpp_swig.OptLogBarrier_getTolerance(self)

    def setTolerance(self, tolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `tolerance` :  
            tolerance  

        """
        return _pysgpp_swig.OptLogBarrier_setTolerance(self, tolerance)

    def getBarrierStartValue(self) -> "double":
        r"""


        Returns
        -------
        barrier start value  

        """
        return _pysgpp_swig.OptLogBarrier_getBarrierStartValue(self)

    def setBarrierStartValue(self, barrierStartValue: "double") -> "void":
        r"""


        Parameters
        ----------
        * `barrierStartValue` :  
            barrier start value  

        """
        return _pysgpp_swig.OptLogBarrier_setBarrierStartValue(self, barrierStartValue)

    def getBarrierDecreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        barrier decrease factor  

        """
        return _pysgpp_swig.OptLogBarrier_getBarrierDecreaseFactor(self)

    def setBarrierDecreaseFactor(self, barrierDecreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `barrierDecreaseFactor` :  
            barrier decrease factor  

        """
        return _pysgpp_swig.OptLogBarrier_setBarrierDecreaseFactor(self, barrierDecreaseFactor)

    def getHistoryOfInnerIterationPoints(self) -> "sgpp::base::DataMatrix const &":
        r"""


        Returns
        -------
        tall matrix (d columns) in which the history of optimal points of the iterations
        are concatenated  

        """
        return _pysgpp_swig.OptLogBarrier_getHistoryOfInnerIterationPoints(self)

    def getHistoryOfInnerIterationNumbers(self) -> "std::vector< size_t,std::allocator< size_t > > const &":
        r"""


        Returns
        -------
        vector in which the k-th entry indicates the number of inner iterations in the
        k-th (outer) iteration, empty vector on error  

        """
        return _pysgpp_swig.OptLogBarrier_getHistoryOfInnerIterationNumbers(self)

# Register OptLogBarrier in _pysgpp_swig:
_pysgpp_swig.OptLogBarrier_swigregister(OptLogBarrier)

class OptSquaredPenalty(OptConstrainedOptimizer):
    r"""

    `SquaredPenalty(f, fGradient, g, gGradient, h, hGradient, maxItCount=DEFAULT_N,
        xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  
    `SquaredPenalty(f, g, h, maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  
    `SquaredPenalty(other)`  
    `SquaredPenalty(unconstrainedOptimizer, g, gGradient, h, hGradient,
        maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

    Squared Penalty method for constrained optimization.  

    Constructors
    ------------
    * `SquaredPenalty(f, fGradient, g, gGradient, h, hGradient,
        maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

        Constructor with adaptive gradient descent as optimization algorithm
        (gradient-based).  

        Parameters:  
        * `f` :  
            objective function  
        * `fGradient` :  
            objective function gradient  
        * `g` :  
            inequality constraint  
        * `gGradient` :  
            inequality constraint gradient  
        * `h` :  
            equality constraint  
        * `hGradient` :  
            equality constraint gradient  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `xTolerance` :  
            point tolerance  
        * `constraintTolerance` :  
            constraint tolerance  
        * `penaltyStartValue` :  
            penalty start value  
        * `penaltyIncreaseFactor` :  
            penalty increase factor  

    * `SquaredPenalty(f, g, h, maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

        Constructor with Nelder-Mead as optimization algorithm (gradient-free).  

        Parameters:  
        * `f` :  
            objective function  
        * `g` :  
            inequality constraint  
        * `h` :  
            equality constraint  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `xTolerance` :  
            point tolerance  
        * `constraintTolerance` :  
            constraint tolerance  
        * `penaltyStartValue` :  
            penalty start value  
        * `penaltyIncreaseFactor` :  
            penalty increase factor  

    * `SquaredPenalty(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            optimizer to be copied  

    * `SquaredPenalty(unconstrainedOptimizer, g, gGradient, h, hGradient,
        maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
        constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
        penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
        penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

        Constructor with custom unconstrained optimization algorithm (gradient-free
        or gradient-based).  

        Parameters:  
        * `unconstrainedOptimizer` :  
            unconstrained optimization algorithm  
        * `g` :  
            inequality constraint  
        * `gGradient` :  
            inequality constraint gradient (nullptr to omit)  
        * `h` :  
            equality constraint  
        * `hGradient` :  
            equality constraint gradient (nullptr to omit)  
        * `maxItCount` :  
            maximal number of function evaluations  
        * `xTolerance` :  
            point tolerance  
        * `constraintTolerance` :  
            constraint tolerance  
        * `penaltyStartValue` :  
            penalty start value  
        * `penaltyIncreaseFactor` :  
            penalty increase factor  

    C++ includes: SquaredPenalty.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_X_TOLERANCE = _pysgpp_swig.OptSquaredPenalty_DEFAULT_X_TOLERANCE
    DEFAULT_CONSTRAINT_TOLERANCE = _pysgpp_swig.OptSquaredPenalty_DEFAULT_CONSTRAINT_TOLERANCE
    DEFAULT_PENALTY_START_VALUE = _pysgpp_swig.OptSquaredPenalty_DEFAULT_PENALTY_START_VALUE
    DEFAULT_PENALTY_INCREASE_FACTOR = _pysgpp_swig.OptSquaredPenalty_DEFAULT_PENALTY_INCREASE_FACTOR

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `SquaredPenalty(f, fGradient, g, gGradient, h, hGradient,
            maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
            constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
            penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
            penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

            Constructor with adaptive gradient descent as optimization algorithm
            (gradient-based).  

            Parameters:  
            * `f` :  
                objective function  
            * `fGradient` :  
                objective function gradient  
            * `g` :  
                inequality constraint  
            * `gGradient` :  
                inequality constraint gradient  
            * `h` :  
                equality constraint  
            * `hGradient` :  
                equality constraint gradient  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `xTolerance` :  
                point tolerance  
            * `constraintTolerance` :  
                constraint tolerance  
            * `penaltyStartValue` :  
                penalty start value  
            * `penaltyIncreaseFactor` :  
                penalty increase factor  

        * `SquaredPenalty(f, g, h, maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
            constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
            penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
            penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

            Constructor with Nelder-Mead as optimization algorithm (gradient-free).  

            Parameters:  
            * `f` :  
                objective function  
            * `g` :  
                inequality constraint  
            * `h` :  
                equality constraint  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `xTolerance` :  
                point tolerance  
            * `constraintTolerance` :  
                constraint tolerance  
            * `penaltyStartValue` :  
                penalty start value  
            * `penaltyIncreaseFactor` :  
                penalty increase factor  

        * `SquaredPenalty(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                optimizer to be copied  

        * `SquaredPenalty(unconstrainedOptimizer, g, gGradient, h, hGradient,
            maxItCount=DEFAULT_N, xTolerance=DEFAULT_X_TOLERANCE,
            constraintTolerance=DEFAULT_CONSTRAINT_TOLERANCE,
            penaltyStartValue=DEFAULT_PENALTY_START_VALUE,
            penaltyIncreaseFactor=DEFAULT_PENALTY_INCREASE_FACTOR)`  

            Constructor with custom unconstrained optimization algorithm (gradient-free
            or gradient-based).  

            Parameters:  
            * `unconstrainedOptimizer` :  
                unconstrained optimization algorithm  
            * `g` :  
                inequality constraint  
            * `gGradient` :  
                inequality constraint gradient (nullptr to omit)  
            * `h` :  
                equality constraint  
            * `hGradient` :  
                equality constraint gradient (nullptr to omit)  
            * `maxItCount` :  
                maximal number of function evaluations  
            * `xTolerance` :  
                point tolerance  
            * `constraintTolerance` :  
                constraint tolerance  
            * `penaltyStartValue` :  
                penalty start value  
            * `penaltyIncreaseFactor` :  
                penalty increase factor  

        """
        _pysgpp_swig.OptSquaredPenalty_swiginit(self, _pysgpp_swig.new_OptSquaredPenalty(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptSquaredPenalty

    def getXTolerance(self) -> "double":
        r"""


        Returns
        -------
        point tolerance  

        """
        return _pysgpp_swig.OptSquaredPenalty_getXTolerance(self)

    def setXTolerance(self, xTolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `xTolerance` :  
            point tolerance  

        """
        return _pysgpp_swig.OptSquaredPenalty_setXTolerance(self, xTolerance)

    def getConstraintTolerance(self) -> "double":
        r"""


        Returns
        -------
        constraint tolerance  

        """
        return _pysgpp_swig.OptSquaredPenalty_getConstraintTolerance(self)

    def setConstraintTolerance(self, constraintTolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `constraintTolerance` :  
            constraint tolerance  

        """
        return _pysgpp_swig.OptSquaredPenalty_setConstraintTolerance(self, constraintTolerance)

    def getPenaltyStartValue(self) -> "double":
        r"""


        Returns
        -------
        penalty start value  

        """
        return _pysgpp_swig.OptSquaredPenalty_getPenaltyStartValue(self)

    def setPenaltyStartValue(self, penaltyStartValue: "double") -> "void":
        r"""


        Parameters
        ----------
        * `penaltyStartValue` :  
            penalty start value  

        """
        return _pysgpp_swig.OptSquaredPenalty_setPenaltyStartValue(self, penaltyStartValue)

    def getPenaltyIncreaseFactor(self) -> "double":
        r"""


        Returns
        -------
        penalty increase factor  

        """
        return _pysgpp_swig.OptSquaredPenalty_getPenaltyIncreaseFactor(self)

    def setPenaltyIncreaseFactor(self, penaltyIncreaseFactor: "double") -> "void":
        r"""


        Parameters
        ----------
        * `penaltyIncreaseFactor` :  
            penalty increase factor  

        """
        return _pysgpp_swig.OptSquaredPenalty_setPenaltyIncreaseFactor(self, penaltyIncreaseFactor)

    def getHistoryOfInnerIterationPoints(self) -> "sgpp::base::DataMatrix const &":
        r"""


        Returns
        -------
        tall matrix (d columns) in which the history of optimal points of the iterations
        are concatenated  

        """
        return _pysgpp_swig.OptSquaredPenalty_getHistoryOfInnerIterationPoints(self)

    def getHistoryOfInnerIterationNumbers(self) -> "std::vector< size_t,std::allocator< size_t > > const &":
        r"""


        Returns
        -------
        vector in which the k-th entry indicates the number of inner iterations in the
        k-th (outer) iteration, empty vector on error  

        """
        return _pysgpp_swig.OptSquaredPenalty_getHistoryOfInnerIterationNumbers(self)

# Register OptSquaredPenalty in _pysgpp_swig:
_pysgpp_swig.OptSquaredPenalty_swigregister(OptSquaredPenalty)

class OptFuzzyExtensionPrinciple(object):
    r"""

    `FuzzyExtensionPrinciple(f,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  
    `FuzzyExtensionPrinciple(other)`  

    Abstract class for Zadeh's fuzzy extension principle to propagate fuzzy input
    uncertainties through a function to obtain a fuzzy output uncertainty.  

    Subclasses have to specify how the output confidence intervals are determined.  

    Literature: W. Andreas Klimke. Uncertainty Modeling using Fuzzy Arithmetic and
    Sparse Grids. PhD thesis, University of Stuttgart, IANS, 2006.  

    Constructors
    ------------
    * `FuzzyExtensionPrinciple(f,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  

        Constructor.  

        Parameters:  
        * `f` :  
            function through which to propagate the uncertainties  
        * `numberOfAlphaSegments` :  
            number of $\alpha$ segments  

    * `FuzzyExtensionPrinciple(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            other fuzzy extension principle  

    C++ includes: FuzzyExtensionPrinciple.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DEFAULT_NUMBER_OF_ALPHA_SEGMENTS = _pysgpp_swig.OptFuzzyExtensionPrinciple_DEFAULT_NUMBER_OF_ALPHA_SEGMENTS
    __swig_destroy__ = _pysgpp_swig.delete_OptFuzzyExtensionPrinciple

    def apply(self, xFuzzy: "OptFuzzyIntervalVector") -> "sgpp::optimization::FuzzyInterval *":
        r"""


        Apply the fuzzy extension principle to fuzzy input intervals.  

        Parameters
        ----------
        * `xFuzzy` :  
            vector of fuzzy input intervals  

        Returns
        -------
        fuzzy output interval; plain pointer due to the Python interface; wrap return
        value with smart pointer  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_apply(self, xFuzzy)

    def getNumberOfAlphaSegments(self) -> "size_t":
        r"""


        Returns
        -------
        number of $\alpha$ segments  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_getNumberOfAlphaSegments(self)

    def setNumberOfAlphaSegments(self, numberOfAlphaSegments: "size_t") -> "void":
        r"""


        Parameters
        ----------
        * `numberOfAlphaSegments` :  
            number of $\alpha$ segments  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_setNumberOfAlphaSegments(self, numberOfAlphaSegments)

    def getAlphaLevels(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        vector of $\alpha$ levels (after `apply` call)  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_getAlphaLevels(self)

    def getOptimizationDomainsLowerBounds(self) -> "std::vector< sgpp::base::DataVector,std::allocator< sgpp::base::DataVector > > const &":
        r"""


        Returns
        -------
        vector of lower bounds of input confidence intervals (after `apply` call)  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_getOptimizationDomainsLowerBounds(self)

    def getOptimizationDomainsUpperBounds(self) -> "std::vector< sgpp::base::DataVector,std::allocator< sgpp::base::DataVector > > const &":
        r"""


        Returns
        -------
        vector of upper bounds of input confidence intervals (after `apply` call)  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_getOptimizationDomainsUpperBounds(self)

    def getMinimumPoints(self) -> "std::vector< sgpp::base::DataVector,std::allocator< sgpp::base::DataVector > > const &":
        r"""


        Returns
        -------
        vector of minimum points (after `apply` call)  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_getMinimumPoints(self)

    def getMinimumValues(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        vector of minimum function values (after `apply` call)  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_getMinimumValues(self)

    def getMaximumPoints(self) -> "std::vector< sgpp::base::DataVector,std::allocator< sgpp::base::DataVector > > const &":
        r"""


        Returns
        -------
        vector of maximum points (after `apply` call)  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_getMaximumPoints(self)

    def getMaximumValues(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        vector of maximum function values (after `apply` call)  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_getMaximumValues(self)

    def clone(self, clone: "std::unique_ptr< sgpp::optimization::FuzzyExtensionPrinciple > &") -> "void":
        r"""


        Pure virtual method for cloning the fuzzy extension principle.  

        It should generate a pointer to the cloned object and it's used for parallel
        computations (the optimizeForSingleAlphaLevel() method might not be thread-
        safe).  

        Parameters
        ----------
        * `clone` :  
            pointer to cloned object  

        """
        return _pysgpp_swig.OptFuzzyExtensionPrinciple_clone(self, clone)

# Register OptFuzzyExtensionPrinciple in _pysgpp_swig:
_pysgpp_swig.OptFuzzyExtensionPrinciple_swigregister(OptFuzzyExtensionPrinciple)

class OptFuzzyExtensionPrincipleViaOptimization(OptFuzzyExtensionPrinciple):
    r"""

    `FuzzyExtensionPrincipleViaOptimization(f,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  
    `FuzzyExtensionPrincipleViaOptimization(other)`  
    `FuzzyExtensionPrincipleViaOptimization(optimizer,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  

    Zadeh's fuzzy extension principle by solving optimization problems for each
    $\alpha$ level.  

    Constructors
    ------------
    * `FuzzyExtensionPrincipleViaOptimization(f,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  

        Constructor.  

        By default, MultiStart is used as optimization algorithm.  

        Parameters:  
        * `f` :  
            function through which to propagate the uncertainties  
        * `numberOfAlphaSegments` :  
            number of $\alpha$ segments  

    * `FuzzyExtensionPrincipleViaOptimization(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            other fuzzy extension principle  

    * `FuzzyExtensionPrincipleViaOptimization(optimizer,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  

        Constructor with custom optimization algorithm.  

        Parameters:  
        * `optimizer` :  
            optimization algorithm and function through which to propagate the
            uncertainties  
        * `numberOfAlphaSegments` :  
            number of $\alpha$ segments  

    C++ includes: FuzzyExtensionPrincipleViaOptimization.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `FuzzyExtensionPrincipleViaOptimization(f,
            numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  

            Constructor.  

            By default, MultiStart is used as optimization algorithm.  

            Parameters:  
            * `f` :  
                function through which to propagate the uncertainties  
            * `numberOfAlphaSegments` :  
                number of $\alpha$ segments  

        * `FuzzyExtensionPrincipleViaOptimization(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                other fuzzy extension principle  

        * `FuzzyExtensionPrincipleViaOptimization(optimizer,
            numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  

            Constructor with custom optimization algorithm.  

            Parameters:  
            * `optimizer` :  
                optimization algorithm and function through which to propagate the
                uncertainties  
            * `numberOfAlphaSegments` :  
                number of $\alpha$ segments  

        """
        _pysgpp_swig.OptFuzzyExtensionPrincipleViaOptimization_swiginit(self, _pysgpp_swig.new_OptFuzzyExtensionPrincipleViaOptimization(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptFuzzyExtensionPrincipleViaOptimization

# Register OptFuzzyExtensionPrincipleViaOptimization in _pysgpp_swig:
_pysgpp_swig.OptFuzzyExtensionPrincipleViaOptimization_swigregister(OptFuzzyExtensionPrincipleViaOptimization)

class OptFuzzyExtensionPrincipleViaTransformation(OptFuzzyExtensionPrincipleViaOptimization):
    r"""

    `FuzzyExtensionPrincipleViaTransformation(f,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  
    `FuzzyExtensionPrincipleViaTransformation(other)`  

    Zadeh's fuzzy extension principle by the transformation method, where the
    optimization problems are solved by sampling the optimization domains and taking
    the best points.  

    The transformation method produces inaccurate results if the fuzzy input
    intervals are not fuzzy numbers, i.e., if the confidence intervals for $\alpha
    = 1$ contain more than one point.  

    Constructors
    ------------
    * `FuzzyExtensionPrincipleViaTransformation(f,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  

        Constructor.  

        Parameters:  
        * `f` :  
            function through which to propagate the uncertainties  
        * `numberOfAlphaSegments` :  
            number of $\alpha$ segments  

    * `FuzzyExtensionPrincipleViaTransformation(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            other fuzzy extension principle  

    C++ includes: FuzzyExtensionPrincipleViaTransformation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `FuzzyExtensionPrincipleViaTransformation(f,
            numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  

            Constructor.  

            Parameters:  
            * `f` :  
                function through which to propagate the uncertainties  
            * `numberOfAlphaSegments` :  
                number of $\alpha$ segments  

        * `FuzzyExtensionPrincipleViaTransformation(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                other fuzzy extension principle  

        """
        _pysgpp_swig.OptFuzzyExtensionPrincipleViaTransformation_swiginit(self, _pysgpp_swig.new_OptFuzzyExtensionPrincipleViaTransformation(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptFuzzyExtensionPrincipleViaTransformation

# Register OptFuzzyExtensionPrincipleViaTransformation in _pysgpp_swig:
_pysgpp_swig.OptFuzzyExtensionPrincipleViaTransformation_swigregister(OptFuzzyExtensionPrincipleViaTransformation)

class OptFuzzyExtensionPrincipleViaVertexMethod(OptFuzzyExtensionPrincipleViaOptimization):
    r"""

    `FuzzyExtensionPrincipleViaVertexMethod(f,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  
    `FuzzyExtensionPrincipleViaVertexMethod(other)`  

    Zadeh's fuzzy extension principle by the vertex method, where the optimization
    problems are solved by simply taking the best corners of the confidence
    intervals.  

    Constructors
    ------------
    * `FuzzyExtensionPrincipleViaVertexMethod(f,
        numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  

        Constructor.  

        Parameters:  
        * `f` :  
            function through which to propagate the uncertainties  
        * `numberOfAlphaSegments` :  
            number of $\alpha$ segments  

    * `FuzzyExtensionPrincipleViaVertexMethod(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            other fuzzy extension principle  

    C++ includes: FuzzyExtensionPrincipleViaVertexMethod.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `FuzzyExtensionPrincipleViaVertexMethod(f,
            numberOfAlphaSegments=DEFAULT_NUMBER_OF_ALPHA_SEGMENTS)`  

            Constructor.  

            Parameters:  
            * `f` :  
                function through which to propagate the uncertainties  
            * `numberOfAlphaSegments` :  
                number of $\alpha$ segments  

        * `FuzzyExtensionPrincipleViaVertexMethod(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                other fuzzy extension principle  

        """
        _pysgpp_swig.OptFuzzyExtensionPrincipleViaVertexMethod_swiginit(self, _pysgpp_swig.new_OptFuzzyExtensionPrincipleViaVertexMethod(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptFuzzyExtensionPrincipleViaVertexMethod

# Register OptFuzzyExtensionPrincipleViaVertexMethod in _pysgpp_swig:
_pysgpp_swig.OptFuzzyExtensionPrincipleViaVertexMethod_swigregister(OptFuzzyExtensionPrincipleViaVertexMethod)

class OptFuzzyIntervalViaConfidenceInterval(OptFuzzyInterval):
    r"""

    `FuzzyIntervalViaConfidenceInterval(other)`  
    `FuzzyIntervalViaConfidenceInterval(supportLowerBound, supportUpperBound,
        numberOfIntegralSamples=DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES,
        binarySearchTolerance=DEFAULT_BINARY_SEARCH_TOLERANCE)`  

    Abstract class for a fuzzy interval which is defined by stating its confidence
    intervals $(\tilde{x})_\alpha$ for all $\alpha \in [0, 1]$.  

    Constructors
    ------------
    * `FuzzyIntervalViaConfidenceInterval(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            other fuzzy interval  

    * `FuzzyIntervalViaConfidenceInterval(supportLowerBound, supportUpperBound,
        numberOfIntegralSamples=DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES,
        binarySearchTolerance=DEFAULT_BINARY_SEARCH_TOLERANCE)`  

        Constructor.  

        Needs the support of the fuzzy interval (which is always a closed interval,
        so it suffices to supply lower and upper bound).  

        Parameters:  
        * `supportLowerBound` :  
            lower bound of the support  
        * `supportUpperBound` :  
            upper bound of the support  
        * `numberOfIntegralSamples` :  
            number of samples to compute norms  
        * `binarySearchTolerance` :  
            tolerance for the binary search  

    C++ includes: FuzzyIntervalViaConfidenceInterval.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_BINARY_SEARCH_TOLERANCE = _pysgpp_swig.OptFuzzyIntervalViaConfidenceInterval_DEFAULT_BINARY_SEARCH_TOLERANCE

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `FuzzyIntervalViaConfidenceInterval(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                other fuzzy interval  

        * `FuzzyIntervalViaConfidenceInterval(supportLowerBound, supportUpperBound,
            numberOfIntegralSamples=DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES,
            binarySearchTolerance=DEFAULT_BINARY_SEARCH_TOLERANCE)`  

            Constructor.  

            Needs the support of the fuzzy interval (which is always a closed interval,
            so it suffices to supply lower and upper bound).  

            Parameters:  
            * `supportLowerBound` :  
                lower bound of the support  
            * `supportUpperBound` :  
                upper bound of the support  
            * `numberOfIntegralSamples` :  
                number of samples to compute norms  
            * `binarySearchTolerance` :  
                tolerance for the binary search  

        """
        if self.__class__ == OptFuzzyIntervalViaConfidenceInterval:
            _self = None
        else:
            _self = self
        _pysgpp_swig.OptFuzzyIntervalViaConfidenceInterval_swiginit(self, _pysgpp_swig.new_OptFuzzyIntervalViaConfidenceInterval(_self, *args))
    __swig_destroy__ = _pysgpp_swig.delete_OptFuzzyIntervalViaConfidenceInterval

    def evaluateMembershipFunction(self, x: "double") -> "double":
        r"""


        Evaluate the membership function.  

        Parameters
        ----------
        * `x` :  
            $x \in X$  

        Returns
        -------
        $\mu_{\tilde{x}}(x) \in [0, 1]$  

        """
        return _pysgpp_swig.OptFuzzyIntervalViaConfidenceInterval_evaluateMembershipFunction(self, x)

    def getBinarySearchTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance for the binary search  

        """
        return _pysgpp_swig.OptFuzzyIntervalViaConfidenceInterval_getBinarySearchTolerance(self)

    def setBinarySearchTolerance(self, binarySearchTolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `binarySearchTolerance` :  
            tolerance for the binary search  

        """
        return _pysgpp_swig.OptFuzzyIntervalViaConfidenceInterval_setBinarySearchTolerance(self, binarySearchTolerance)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_OptFuzzyIntervalViaConfidenceInterval(self)
        return weakref.proxy(self)

# Register OptFuzzyIntervalViaConfidenceInterval in _pysgpp_swig:
_pysgpp_swig.OptFuzzyIntervalViaConfidenceInterval_swigregister(OptFuzzyIntervalViaConfidenceInterval)

class OptFuzzyIntervalViaMembershipFunction(OptFuzzyInterval):
    r"""

    `FuzzyIntervalViaMembershipFunction(other)`  
    `FuzzyIntervalViaMembershipFunction(supportLowerBound, supportUpperBound,
        coreLowerBound, coreUpperBound,
        numberOfIntegralSamples=DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES,
        binarySearchTolerance=DEFAULT_BINARY_SEARCH_TOLERANCE)`  

    Abstract class for a fuzzy interval which is defined by stating its membership
    function $\mu_{\tilde{x}}\colon X \to [0, 1]$.  

    Constructors
    ------------
    * `FuzzyIntervalViaMembershipFunction(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            other fuzzy interval  

    * `FuzzyIntervalViaMembershipFunction(supportLowerBound, supportUpperBound,
        coreLowerBound, coreUpperBound,
        numberOfIntegralSamples=DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES,
        binarySearchTolerance=DEFAULT_BINARY_SEARCH_TOLERANCE)`  

        Constructor.  

        Needs the support of the fuzzy interval and its core, i.e.,
        $(\tilde{x})_\alpha$ for $alpha = 0$ and for $\alpha = 1$, (which are
        always closed intervals, so it suffices to supply lower and upper bounds).
        The core is needed since the binary search cannot be performed for $\alpha
        = 1$.  

        Parameters:  
        * `supportLowerBound` :  
            lower bound of the support  
        * `supportUpperBound` :  
            upper bound of the support  
        * `coreLowerBound` :  
            lower bound of the core  
        * `coreUpperBound` :  
            upper bound of the core  
        * `numberOfIntegralSamples` :  
            number of samples to compute norms  
        * `binarySearchTolerance` :  
            tolerance for the binary search  

    C++ includes: FuzzyIntervalViaMembershipFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DEFAULT_BINARY_SEARCH_TOLERANCE = _pysgpp_swig.OptFuzzyIntervalViaMembershipFunction_DEFAULT_BINARY_SEARCH_TOLERANCE

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `FuzzyIntervalViaMembershipFunction(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                other fuzzy interval  

        * `FuzzyIntervalViaMembershipFunction(supportLowerBound, supportUpperBound,
            coreLowerBound, coreUpperBound,
            numberOfIntegralSamples=DEFAULT_NUMBER_OF_INTEGRAL_SAMPLES,
            binarySearchTolerance=DEFAULT_BINARY_SEARCH_TOLERANCE)`  

            Constructor.  

            Needs the support of the fuzzy interval and its core, i.e.,
            $(\tilde{x})_\alpha$ for $alpha = 0$ and for $\alpha = 1$, (which are
            always closed intervals, so it suffices to supply lower and upper bounds).
            The core is needed since the binary search cannot be performed for $\alpha
            = 1$.  

            Parameters:  
            * `supportLowerBound` :  
                lower bound of the support  
            * `supportUpperBound` :  
                upper bound of the support  
            * `coreLowerBound` :  
                lower bound of the core  
            * `coreUpperBound` :  
                upper bound of the core  
            * `numberOfIntegralSamples` :  
                number of samples to compute norms  
            * `binarySearchTolerance` :  
                tolerance for the binary search  

        """
        if self.__class__ == OptFuzzyIntervalViaMembershipFunction:
            _self = None
        else:
            _self = self
        _pysgpp_swig.OptFuzzyIntervalViaMembershipFunction_swiginit(self, _pysgpp_swig.new_OptFuzzyIntervalViaMembershipFunction(_self, *args))
    __swig_destroy__ = _pysgpp_swig.delete_OptFuzzyIntervalViaMembershipFunction

    def evaluateConfidenceIntervalLowerBound(self, alpha: "double") -> "double":
        r"""


        Evaluate the lower bound of a confidence interval, which is always a closed
        interval $(\tilde{x})_\alpha = [a, b]$.  

        Parameters
        ----------
        * `alpha` :  
            $\alpha \in [0, 1]$  

        Returns
        -------
        $a \in X$  

        """
        return _pysgpp_swig.OptFuzzyIntervalViaMembershipFunction_evaluateConfidenceIntervalLowerBound(self, alpha)

    def evaluateConfidenceIntervalUpperBound(self, alpha: "double") -> "double":
        r"""


        Evaluate the upper bound of a confidence interval, which is always a closed
        interval $(\tilde{x})_\alpha = [a, b]$.  

        Parameters
        ----------
        * `alpha` :  
            $\alpha \in [0, 1]$  

        Returns
        -------
        $b \in X$  

        """
        return _pysgpp_swig.OptFuzzyIntervalViaMembershipFunction_evaluateConfidenceIntervalUpperBound(self, alpha)

    def getCoreLowerBound(self) -> "double":
        r"""


        Returns
        -------
        lower bound of the core  

        """
        return _pysgpp_swig.OptFuzzyIntervalViaMembershipFunction_getCoreLowerBound(self)

    def getCoreUpperBound(self) -> "double":
        r"""


        Returns
        -------
        upper bound of the core  

        """
        return _pysgpp_swig.OptFuzzyIntervalViaMembershipFunction_getCoreUpperBound(self)

    def getBinarySearchTolerance(self) -> "double":
        r"""


        Returns
        -------
        tolerance for the binary search  

        """
        return _pysgpp_swig.OptFuzzyIntervalViaMembershipFunction_getBinarySearchTolerance(self)

    def setBinarySearchTolerance(self, binarySearchTolerance: "double") -> "void":
        r"""


        Parameters
        ----------
        * `binarySearchTolerance` :  
            tolerance for the binary search  

        """
        return _pysgpp_swig.OptFuzzyIntervalViaMembershipFunction_setBinarySearchTolerance(self, binarySearchTolerance)
    def __disown__(self):
        self.this.disown()
        _pysgpp_swig.disown_OptFuzzyIntervalViaMembershipFunction(self)
        return weakref.proxy(self)

# Register OptFuzzyIntervalViaMembershipFunction in _pysgpp_swig:
_pysgpp_swig.OptFuzzyIntervalViaMembershipFunction_swigregister(OptFuzzyIntervalViaMembershipFunction)

class OptInterpolatedFuzzyInterval(OptFuzzyIntervalViaMembershipFunction):
    r"""

    `InterpolatedFuzzyInterval(xData, alphaData)`  
    `InterpolatedFuzzyInterval(other)`  

    Fuzzy interval by piecewise linear interpolation of sample points $(x_i,
    \alpha_i)$ of the membership function $\mu_{\tilde{x}}$, i.e.,
    $\mu_{\tilde{x}}(x_i) = \alpha_i$ ( $i = 1, \dotsc, n$).  

    The data must fulfill the following:  

    *   $x_i < x_{i+1}$ for $i = 1, \dotsc, n-1$  
    *   $\alpha_1 = 0 = \alpha_n$  
    *   There are some $1 < j \le k < n$ such that:
        -   $\alpha_i = 1$ for $i = j, \dotsc, k$  
        -   $\alpha_i < \alpha_{i+1}$ for $i = 1, \dotsc, j-1$  
        -   $\alpha_i > \alpha_{i+1}$ for $i = k, \dotsc, n-1$  

    Constructors
    ------------
    * `InterpolatedFuzzyInterval(xData, alphaData)`  

        Constructor.  

        Parameters:  
        * `xData` :  
            $x$ data of sample points  
        * `alphaData` :  
            $\alpha$ data of sample points  

    * `InterpolatedFuzzyInterval(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            other interpolated fuzzy interval  

    C++ includes: InterpolatedFuzzyInterval.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def getCoreLowerBound(xData: "DataVector", alphaData: "DataVector") -> "double":
        r"""


        Compute the lower bound of the core (i.e., the area where the membership
        function equals 1).  

        Parameters
        ----------
        * `xData` :  
            $x$ data of sample points  
        * `alphaData` :  
            $\alpha$ data of sample points  

        """
        return _pysgpp_swig.OptInterpolatedFuzzyInterval_getCoreLowerBound(xData, alphaData)

    @staticmethod
    def getCoreUpperBound(xData: "DataVector", alphaData: "DataVector") -> "double":
        r"""


        Compute the upper bound of the core (i.e., the area where the membership
        function equals 1).  

        Parameters
        ----------
        * `xData` :  
            $x$ data of sample points  
        * `alphaData` :  
            $\alpha$ data of sample points  

        """
        return _pysgpp_swig.OptInterpolatedFuzzyInterval_getCoreUpperBound(xData, alphaData)

    @staticmethod
    def tryDowncast(fuzzyInterval: "OptFuzzyInterval") -> "sgpp::optimization::InterpolatedFuzzyInterval *":
        r"""


        Try to cast a FuzzyInterval to an InterpolatedFuzzyInterval (`dynamic_cast`),
        needed for the Python interface.  

        Parameters
        ----------
        * `fuzzyInterval` :  
            FuzzyInterval to cast  

        Returns
        -------
        pointer to InterpolatedFuzzyInterval if succesful, nullptr otherwise  

        """
        return _pysgpp_swig.OptInterpolatedFuzzyInterval_tryDowncast(fuzzyInterval)

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `InterpolatedFuzzyInterval(xData, alphaData)`  

            Constructor.  

            Parameters:  
            * `xData` :  
                $x$ data of sample points  
            * `alphaData` :  
                $\alpha$ data of sample points  

        * `InterpolatedFuzzyInterval(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                other interpolated fuzzy interval  

        """
        _pysgpp_swig.OptInterpolatedFuzzyInterval_swiginit(self, _pysgpp_swig.new_OptInterpolatedFuzzyInterval(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptInterpolatedFuzzyInterval

    def getXData(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        $x$ data of sample points  

        """
        return _pysgpp_swig.OptInterpolatedFuzzyInterval_getXData(self)

    def getAlphaData(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        $\alpha$ data of sample points  

        """
        return _pysgpp_swig.OptInterpolatedFuzzyInterval_getAlphaData(self)

# Register OptInterpolatedFuzzyInterval in _pysgpp_swig:
_pysgpp_swig.OptInterpolatedFuzzyInterval_swigregister(OptInterpolatedFuzzyInterval)

def OptInterpolatedFuzzyInterval_getCoreLowerBound(xData: "DataVector", alphaData: "DataVector") -> "double":
    r"""


    Compute the lower bound of the core (i.e., the area where the membership
    function equals 1).  

    Parameters
    ----------
    * `xData` :  
        $x$ data of sample points  
    * `alphaData` :  
        $\alpha$ data of sample points  

    """
    return _pysgpp_swig.OptInterpolatedFuzzyInterval_getCoreLowerBound(xData, alphaData)

def OptInterpolatedFuzzyInterval_getCoreUpperBound(xData: "DataVector", alphaData: "DataVector") -> "double":
    r"""


    Compute the upper bound of the core (i.e., the area where the membership
    function equals 1).  

    Parameters
    ----------
    * `xData` :  
        $x$ data of sample points  
    * `alphaData` :  
        $\alpha$ data of sample points  

    """
    return _pysgpp_swig.OptInterpolatedFuzzyInterval_getCoreUpperBound(xData, alphaData)

def OptInterpolatedFuzzyInterval_tryDowncast(fuzzyInterval: "OptFuzzyInterval") -> "sgpp::optimization::InterpolatedFuzzyInterval *":
    r"""


    Try to cast a FuzzyInterval to an InterpolatedFuzzyInterval (`dynamic_cast`),
    needed for the Python interface.  

    Parameters
    ----------
    * `fuzzyInterval` :  
        FuzzyInterval to cast  

    Returns
    -------
    pointer to InterpolatedFuzzyInterval if succesful, nullptr otherwise  

    """
    return _pysgpp_swig.OptInterpolatedFuzzyInterval_tryDowncast(fuzzyInterval)

class OptQuasiGaussianFuzzyNumber(OptFuzzyIntervalViaMembershipFunction):
    r"""

    `QuasiGaussianFuzzyNumber(other)`  
    `QuasiGaussianFuzzyNumber(mean, stdev, cutoff)`  

    Quasi-Gaussian fuzzy number.  

    A fuzzy number is a fuzzy interval where $\{x \in X \mid \mu_{\tilde{x}}(x)
    = 1\} = \{a\}$ for some $a \in X$. Quasi-Gaussian fuzzy numbers have a cut-
    off Gaussian function as membership function, which is parametrized by its mean,
    the standard deviation, and the cut-off point.  

    Constructors
    ------------
    * `QuasiGaussianFuzzyNumber(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            other quasi-Gaussian fuzzy number  

    * `QuasiGaussianFuzzyNumber(mean, stdev, cutoff)`  

        Constructor.  

        Parameters:  
        * `mean` :  
            mean  
        * `stdev` :  
            standard deviation  
        * `cutoff` :  
            cut-off point (multiples of the standard deviation)  

    C++ includes: QuasiGaussianFuzzyNumber.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `QuasiGaussianFuzzyNumber(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                other quasi-Gaussian fuzzy number  

        * `QuasiGaussianFuzzyNumber(mean, stdev, cutoff)`  

            Constructor.  

            Parameters:  
            * `mean` :  
                mean  
            * `stdev` :  
                standard deviation  
            * `cutoff` :  
                cut-off point (multiples of the standard deviation)  

        """
        _pysgpp_swig.OptQuasiGaussianFuzzyNumber_swiginit(self, _pysgpp_swig.new_OptQuasiGaussianFuzzyNumber(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptQuasiGaussianFuzzyNumber

    def getMean(self) -> "double":
        r"""


        Returns
        -------
        mean  

        """
        return _pysgpp_swig.OptQuasiGaussianFuzzyNumber_getMean(self)

    def getStdev(self) -> "double":
        r"""


        Returns
        -------
        standard deviation  

        """
        return _pysgpp_swig.OptQuasiGaussianFuzzyNumber_getStdev(self)

    def getCutoff(self) -> "double":
        r"""


        Returns
        -------
        cut-off point (multiples of the standard deviation)  

        """
        return _pysgpp_swig.OptQuasiGaussianFuzzyNumber_getCutoff(self)

# Register OptQuasiGaussianFuzzyNumber in _pysgpp_swig:
_pysgpp_swig.OptQuasiGaussianFuzzyNumber_swigregister(OptQuasiGaussianFuzzyNumber)

class OptTriangularFuzzyInterval(OptFuzzyInterval):
    r"""

    `TriangularFuzzyInterval(other)`  
    `TriangularFuzzyInterval(leftMean, rightMean, leftSpread, rightSpread)`  
    `TriangularFuzzyInterval(mean, leftSpread, rightSpread)`  
    `TriangularFuzzyInterval(mean, spread)`  

    Triangular fuzzy interval; its membership function linearly increases from 0 to
    1, stays 1, and linearly decreases back to 0.  

    The core (i.e., the area where the membership function equals 1) is given by
    $[\mathrm{leftMean}, \mathrm{rightMean}]$. The support is given by
    $[\mathrm{leftMean} - \mathrm{leftSpread}, \mathrm{rightMean} +
    \mathrm{rightSpread}]$.  

    Constructors
    ------------
    * `TriangularFuzzyInterval(other)`  

        Copy constructor.  

        Parameters:  
        * `other` :  
            other triangular fuzzy interval  

    * `TriangularFuzzyInterval(leftMean, rightMean, leftSpread, rightSpread)`  

        Constructor.  

        Parameters:  
        * `leftMean` :  
            left mean  
        * `rightMean` :  
            right mean  
        * `leftSpread` :  
            left spread  
        * `rightSpread` :  
            right spread  

    * `TriangularFuzzyInterval(mean, leftSpread, rightSpread)`  

        Constructor.  

        Parameters:  
        * `mean` :  
            left mean = right mean  
        * `leftSpread` :  
            left spread  
        * `rightSpread` :  
            right spread  

    * `TriangularFuzzyInterval(mean, spread)`  

        Constructor.  

        Parameters:  
        * `mean` :  
            left mean = right mean  
        * `spread` :  
            left spread = right spread  

    C++ includes: TriangularFuzzyInterval.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `TriangularFuzzyInterval(other)`  

            Copy constructor.  

            Parameters:  
            * `other` :  
                other triangular fuzzy interval  

        * `TriangularFuzzyInterval(leftMean, rightMean, leftSpread, rightSpread)`  

            Constructor.  

            Parameters:  
            * `leftMean` :  
                left mean  
            * `rightMean` :  
                right mean  
            * `leftSpread` :  
                left spread  
            * `rightSpread` :  
                right spread  

        * `TriangularFuzzyInterval(mean, leftSpread, rightSpread)`  

            Constructor.  

            Parameters:  
            * `mean` :  
                left mean = right mean  
            * `leftSpread` :  
                left spread  
            * `rightSpread` :  
                right spread  

        * `TriangularFuzzyInterval(mean, spread)`  

            Constructor.  

            Parameters:  
            * `mean` :  
                left mean = right mean  
            * `spread` :  
                left spread = right spread  

        """
        _pysgpp_swig.OptTriangularFuzzyInterval_swiginit(self, _pysgpp_swig.new_OptTriangularFuzzyInterval(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OptTriangularFuzzyInterval

    def getLeftMean(self) -> "double":
        r"""


        Returns
        -------
        left mean  

        """
        return _pysgpp_swig.OptTriangularFuzzyInterval_getLeftMean(self)

    def getRightMean(self) -> "double":
        r"""


        Returns
        -------
        right mean  

        """
        return _pysgpp_swig.OptTriangularFuzzyInterval_getRightMean(self)

    def getLeftSpread(self) -> "double":
        r"""


        Returns
        -------
        left spread  

        """
        return _pysgpp_swig.OptTriangularFuzzyInterval_getLeftSpread(self)

    def getRightSpread(self) -> "double":
        r"""


        Returns
        -------
        right spread  

        """
        return _pysgpp_swig.OptTriangularFuzzyInterval_getRightSpread(self)

# Register OptTriangularFuzzyInterval in _pysgpp_swig:
_pysgpp_swig.OptTriangularFuzzyInterval_swigregister(OptTriangularFuzzyInterval)

class OptTestScalarFunction(ScalarFunction):
    r"""

    `TestScalarFunction(d)`  

    Base class for analytical objective function examples ("test functions").  

    This class differs from ScalarFunction in the way that evaluation point
    $\vec{x}$ are pseudorandomly displaced when calling the eval() function.
    Evaluting the undisplaced function must be implemented in evalUndisplaced. The
    displaced function is $\vec{x} \mapsto f(\vec{x} + \vec{d})$ for a vector
    $\vec{d}$ ("displacement").  

    Taking the average of results of multiple runs with different displacements
    makes results more robust and significant.  

    Constructors
    ------------
    * `TestScalarFunction(d)`  

        Constructor.  

        The displacement is set to all zeros, so to displace the function call
        generateDisplacement() afterwards.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: TestScalarFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OptTestScalarFunction

    def evalUndisplaced(self, x: "DataVector") -> "double":
        r"""


        Pure virtual method for evaluating the undisplaced function.  

        Parameters
        ----------
        * `x` :  
            point $\vec{x} \in \mathbb{R}^d$  

        Returns
        -------
        $f(\vec{x})$  

        """
        return _pysgpp_swig.OptTestScalarFunction_evalUndisplaced(self, x)

    def getDisplacement(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        currently used displacement  

        """
        return _pysgpp_swig.OptTestScalarFunction_getDisplacement(self)

    def setDisplacement(self, displacement: "DataVector") -> "void":
        r"""


        Parameters
        ----------
        * `displacement` :  
            currently used displacement  

        """
        return _pysgpp_swig.OptTestScalarFunction_setDisplacement(self, displacement)

# Register OptTestScalarFunction in _pysgpp_swig:
_pysgpp_swig.OptTestScalarFunction_swigregister(OptTestScalarFunction)

class OptTestVectorFunction(VectorFunction):
    r"""

    `TestVectorFunction(d, m)`  

    Base class for analytical constraint function examples ("test functions").  

    This class differs from VectorFunction in the way that evaluation point
    $\vec{x}$ are pseudorandomly displaced when calling the eval() function.
    Evaluting the undisplaced function must be implemented in evalUndisplaced. The
    displaced function is $\vec{x} \mapsto \vec{f}(\vec{x} + \vec{d})$ for a
    vector $\vec{d}$ ("displacement").  

    Constructors
    ------------
    * `TestVectorFunction(d, m)`  

        Constructor.  

        The displacement is set to all zeros, so to displace the function call
        generateDisplacement() afterwards.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `m` :  
            number of components  

    C++ includes: TestVectorFunction.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OptTestVectorFunction

    def evalUndisplaced(self, x: "DataVector", value: "DataVector") -> "void":
        r"""


        Pure virtual method for evaluating the undisplaced function.  

        Parameters
        ----------
        * `x` :  
            point $\vec{x} \in \mathbb{R}^d$  
        * `value` :  
            $\vec{f}(\vec{x})$  

        """
        return _pysgpp_swig.OptTestVectorFunction_evalUndisplaced(self, x, value)

    def getDisplacement(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        currently used displacement  

        """
        return _pysgpp_swig.OptTestVectorFunction_getDisplacement(self)

    def setDisplacement(self, displacement: "DataVector") -> "void":
        r"""


        Parameters
        ----------
        * `displacement` :  
            currently used displacement  

        """
        return _pysgpp_swig.OptTestVectorFunction_setDisplacement(self, displacement)

# Register OptTestVectorFunction in _pysgpp_swig:
_pysgpp_swig.OptTestVectorFunction_swigregister(OptTestVectorFunction)

class OptUnconstrainedTestProblem(object):
    r"""

    `UnconstrainedTestProblem(d)`  

    Base class for analytical, unconstrained test problems.  

    This class essentially manages an objective function, generates a Gaussian
    displacement vector, and contains the location of the optimal point.  

    Constructors
    ------------
    * `UnconstrainedTestProblem(d)`  

        Constructor.  

        The displacement is set to all zeros, so to displace the function call
        generateDisplacement() afterwards.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: UnconstrainedTestProblem.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DEFAULT_STANDARD_DEVIATION = _pysgpp_swig.OptUnconstrainedTestProblem_DEFAULT_STANDARD_DEVIATION
    __swig_destroy__ = _pysgpp_swig.delete_OptUnconstrainedTestProblem

    def getObjectiveFunction(self) -> "sgpp::optimization::test_problems::TestScalarFunction &":
        r"""


        Returns
        -------
        objective function of the test problem  

        """
        return _pysgpp_swig.OptUnconstrainedTestProblem_getObjectiveFunction(self)

    def getOptimalPoint(self, x: "DataVector") -> "double":
        r"""


        Returns the minimal point of the displaced function.  

        Parameters
        ----------
        * `x` :  
            reverse displaced minimal point $\vec{x}_\opt - \vec{d}$  

        Returns
        -------
        minimal function value $f(\vec{x}_\opt)$  

        """
        return _pysgpp_swig.OptUnconstrainedTestProblem_getOptimalPoint(self, x)

    def getOptimalPointUndisplaced(self, x: "DataVector") -> "double":
        r"""


        Pure virtual method returning the minimal point (or one of the minimal points,
        if there are multiple of them) of the test function.  

        Parameters
        ----------
        * `x` :  
            minimal point $\vec{x}_\opt$  

        Returns
        -------
        minimal function value $f(\vec{x}_\opt)$  

        """
        return _pysgpp_swig.OptUnconstrainedTestProblem_getOptimalPointUndisplaced(self, x)

    def generateDisplacement(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `generateDisplacement()`  

            Generate normally distributed pseudorandom displacement with default
            standard deviation.  

            This method also sets the new displacement in the objective function.  

        * `generateDisplacement(stdDev)`  

            Generate normally distributed pseudorandom displacement.  

            This method also sets the new displacement in the objective function.  

            Parameters:  
            * `stdDev` :  
                standard deviation of the displacement coordinates  

        """
        return _pysgpp_swig.OptUnconstrainedTestProblem_generateDisplacement(self, *args)

    def getDisplacement(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        currently used displacement  

        """
        return _pysgpp_swig.OptUnconstrainedTestProblem_getDisplacement(self)

    def setDisplacement(self, displacement: "DataVector") -> "void":
        r"""


        Sets the displacement vector.  

        This method also sets the new displacement in the objective function.  

        Parameters
        ----------
        * `displacement` :  
            currently used displacement  

        """
        return _pysgpp_swig.OptUnconstrainedTestProblem_setDisplacement(self, displacement)

# Register OptUnconstrainedTestProblem in _pysgpp_swig:
_pysgpp_swig.OptUnconstrainedTestProblem_swigregister(OptUnconstrainedTestProblem)

class AbsoluteValueObjective(OptTestScalarFunction):
    r"""

    `AbsoluteValueObjective(d)`  

    Absolute value objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \sum_{t=1}^d |\bar{x}_t -
    2^{-t}|\]  

    Constructors
    ------------
    * `AbsoluteValueObjective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: AbsoluteValue.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.AbsoluteValueObjective_swiginit(self, _pysgpp_swig.new_AbsoluteValueObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_AbsoluteValueObjective

# Register AbsoluteValueObjective in _pysgpp_swig:
_pysgpp_swig.AbsoluteValueObjective_swigregister(AbsoluteValueObjective)

class OptAbsoluteValueObjective(OptUnconstrainedTestProblem):
    r"""

    `AbsoluteValue(d)`  

    Absolute value unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [0, 1]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (2^{-t})_{t=1}^d$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `AbsoluteValue(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: AbsoluteValue.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptAbsoluteValueObjective_swiginit(self, _pysgpp_swig.new_OptAbsoluteValueObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptAbsoluteValueObjective

# Register OptAbsoluteValueObjective in _pysgpp_swig:
_pysgpp_swig.OptAbsoluteValueObjective_swigregister(OptAbsoluteValueObjective)

class OptAckleyObjective(OptTestScalarFunction):
    r"""

    `AckleyObjective(d)`  

    Ackley objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := 20 + \mathrm{e} - 20
    \exp\!\left(-\frac{\norm{\bar{\vec{x}}}_2}{5\sqrt{d}}\right) -
    \exp\!\left(\frac{1}{d} \sum_{t=1}^d \cos(2\pi \bar{x}_t)\right)\]  

    Constructors
    ------------
    * `AckleyObjective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Ackley.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptAckleyObjective_swiginit(self, _pysgpp_swig.new_OptAckleyObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptAckleyObjective

# Register OptAckleyObjective in _pysgpp_swig:
_pysgpp_swig.OptAckleyObjective_swigregister(OptAckleyObjective)

class OptAckley(OptUnconstrainedTestProblem):
    r"""

    `Ackley(d)`  

    Ackley unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [1.5, 6.5]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = 0.0948903972968234 \cdot
        \vec{1}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        6.559645375627878$  

    Constructors
    ------------
    * `Ackley(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Ackley.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptAckley_swiginit(self, _pysgpp_swig.new_OptAckley(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptAckley

# Register OptAckley in _pysgpp_swig:
_pysgpp_swig.OptAckley_swigregister(OptAckley)

class OptAlpine02Objective(OptTestScalarFunction):
    r"""

    `Alpine02Objective(d)`  

    Alpine02 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := -\prod_{t=1}^d \sqrt{\bar{x}_t}
    \sin(\bar{x}_t)\]  

    Constructors
    ------------
    * `Alpine02Objective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Alpine02.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptAlpine02Objective_swiginit(self, _pysgpp_swig.new_OptAlpine02Objective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptAlpine02Objective

# Register OptAlpine02Objective in _pysgpp_swig:
_pysgpp_swig.OptAlpine02Objective_swigregister(OptAlpine02Objective)

class OptAlpine02(OptUnconstrainedTestProblem):
    r"""

    `Alpine02(d)`  

    Alpine02 unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [2, 10]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = 7.917052684666 \cdot
        \vec{1}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -2.8081311800070^d$  

    Constructors
    ------------
    * `Alpine02(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Alpine02.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptAlpine02_swiginit(self, _pysgpp_swig.new_OptAlpine02(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptAlpine02

# Register OptAlpine02 in _pysgpp_swig:
_pysgpp_swig.OptAlpine02_swigregister(OptAlpine02)

class OptBealeObjective(OptTestScalarFunction):
    r"""

    `BealeObjective()`  

    Beale objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := (1.5 - \bar{x}_1 (1 -
    \bar{x}_2))^2 + (2.25 - \bar{x}_1 (1 - \bar{x}_2^2))^2 + (2.625 - \bar{x}_1
    (1 - \bar{x}_2^3))^2\],  

    Constructors
    ------------
    * `BealeObjective()`  

        Constructor.  

    C++ includes: Beale.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptBealeObjective_swiginit(self, _pysgpp_swig.new_OptBealeObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptBealeObjective

# Register OptBealeObjective in _pysgpp_swig:
_pysgpp_swig.OptBealeObjective_swigregister(OptBealeObjective)

class OptBeale(OptUnconstrainedTestProblem):
    r"""

    `Beale()`  

    Beale unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [-5, 5]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (3, 1/2)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `Beale()`  

        Constructor.  

    C++ includes: Beale.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptBeale_swiginit(self, _pysgpp_swig.new_OptBeale())
    __swig_destroy__ = _pysgpp_swig.delete_OptBeale

# Register OptBeale in _pysgpp_swig:
_pysgpp_swig.OptBeale_swigregister(OptBeale)

class OptBranin01Objective(OptTestScalarFunction):
    r"""

    `Branin01Objective()`  

    Branin01 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \left(\bar{x}_2 - 5.1
    \bar{x}_1^2/(4\pi^2) + 5 \bar{x}_1/\pi - 6\right)^2 + 10 \left(1 -
    1/(8\pi)\right) \cos \bar{x}_1 + 10\]  

    Constructors
    ------------
    * `Branin01Objective()`  

        Constructor.  

    C++ includes: Branin01.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptBranin01Objective_swiginit(self, _pysgpp_swig.new_OptBranin01Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptBranin01Objective

# Register OptBranin01Objective in _pysgpp_swig:
_pysgpp_swig.OptBranin01Objective_swigregister(OptBranin01Objective)

class OptBranin01(OptUnconstrainedTestProblem):
    r"""

    `Branin01()`  

    Branin01 unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [-5, 10] \times [0, 15]$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} \in \{(-\pi, 491/40),
        (\pi, 91/40), (3\pi, 99/40)\}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        5/(4\pi)$  

    Constructors
    ------------
    * `Branin01()`  

        Constructor.  

    C++ includes: Branin01.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptBranin01_swiginit(self, _pysgpp_swig.new_OptBranin01())
    __swig_destroy__ = _pysgpp_swig.delete_OptBranin01

# Register OptBranin01 in _pysgpp_swig:
_pysgpp_swig.OptBranin01_swigregister(OptBranin01)

class OptBranin02Objective(OptTestScalarFunction):
    r"""

    `Branin02Objective()`  

    Branin02 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \left(\bar{x}_2 - 5.1
    \bar{x}_1^2/(4\pi^2) + 5 \bar{x}_1/\pi - 6\right)^2 + 10 \left(1 -
    1/(8\pi)\right) \cos \bar{x}_1 \cos \bar{x}_2 + \ln(\bar{x}_1^2 +
    \bar{x}_2^2 + 1) + 10\]  

    Constructors
    ------------
    * `Branin02Objective()`  

        Constructor.  

    C++ includes: Branin02.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptBranin02Objective_swiginit(self, _pysgpp_swig.new_OptBranin02Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptBranin02Objective

# Register OptBranin02Objective in _pysgpp_swig:
_pysgpp_swig.OptBranin02Objective_swigregister(OptBranin02Objective)

class OptBranin02(OptUnconstrainedTestProblem):
    r"""

    `Branin02()`  

    Branin02 unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [-5, 15]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (-3.196988424804,
        12.52625788532)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        5.559037320859$  

    Constructors
    ------------
    * `Branin02()`  

        Constructor.  

    C++ includes: Branin02.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptBranin02_swiginit(self, _pysgpp_swig.new_OptBranin02())
    __swig_destroy__ = _pysgpp_swig.delete_OptBranin02

# Register OptBranin02 in _pysgpp_swig:
_pysgpp_swig.OptBranin02_swigregister(OptBranin02)

class OptBubbleWrapObjective(OptTestScalarFunction):
    r"""

    `BubbleWrapObjective(d)`  

    Bubble wrap objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := 1 - \prod_{t=1}^d (9/10 -
    |\bar{x}_t| + \cos(10\pi \bar{x}_t)/10)\]  

    Constructors
    ------------
    * `BubbleWrapObjective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: BubbleWrap.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptBubbleWrapObjective_swiginit(self, _pysgpp_swig.new_OptBubbleWrapObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptBubbleWrapObjective

# Register OptBubbleWrapObjective in _pysgpp_swig:
_pysgpp_swig.OptBubbleWrapObjective_swigregister(OptBubbleWrapObjective)

class OptBubbleWrap(OptUnconstrainedTestProblem):
    r"""

    `BubbleWrap(d)`  

    Bubble wrap unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = \vec{0}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `BubbleWrap(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: BubbleWrap.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptBubbleWrap_swiginit(self, _pysgpp_swig.new_OptBubbleWrap(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptBubbleWrap

# Register OptBubbleWrap in _pysgpp_swig:
_pysgpp_swig.OptBubbleWrap_swigregister(OptBubbleWrap)

class OptEasomYangObjective(OptTestScalarFunction):
    r"""

    `EasomYangObjective(d)`  

    Easom-Yang objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := -\exp(-\norm{\bar{\vec{x}} -
    \pi \cdot \vec{1}}_2^2) \cdot \prod_{t=1}^d (-\cos \bar{x}_t)\]  

    Constructors
    ------------
    * `EasomYangObjective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: EasomYang.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptEasomYangObjective_swiginit(self, _pysgpp_swig.new_OptEasomYangObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptEasomYangObjective

# Register OptEasomYangObjective in _pysgpp_swig:
_pysgpp_swig.OptEasomYangObjective_swigregister(OptEasomYangObjective)

class OptEasomYang(OptUnconstrainedTestProblem):
    r"""

    `EasomYang(d)`  

    Easom-Yang unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [-2\pi, 2\pi]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = \pi \cdot \vec{1}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = -1$  

    Constructors
    ------------
    * `EasomYang(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: EasomYang.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptEasomYang_swiginit(self, _pysgpp_swig.new_OptEasomYang(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptEasomYang

# Register OptEasomYang in _pysgpp_swig:
_pysgpp_swig.OptEasomYang_swigregister(OptEasomYang)

class OptEggholderObjective(OptTestScalarFunction):
    r"""

    `EggholderObjective()`  

    Eggholder objective function.  

    Definition: \[\bar{f}(\bar{\vec{x})} := -(\bar{x}_2 + 47)
    \sin\!\left(\sqrt{ \left|\bar{x}_1/2 + \bar{x}_2 + 47\right|}\right) -
    \bar{x}_1 \sin\!\left(\sqrt{ \left|\bar{x}_1 - \bar{x}_2 -
    47\right|}\right)\]  

    Constructors
    ------------
    * `EggholderObjective()`  

        Constructor.  

    C++ includes: Eggholder.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptEggholderObjective_swiginit(self, _pysgpp_swig.new_OptEggholderObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptEggholderObjective

# Register OptEggholderObjective in _pysgpp_swig:
_pysgpp_swig.OptEggholderObjective_swigregister(OptEggholderObjective)

class OptEggholder(OptUnconstrainedTestProblem):
    r"""

    `Eggholder()`  

    Eggholder unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [-512, 512]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (512, 404.2318)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -959.6407$  

    The displacement is restricted because the minimal point lies on the boundary of
    $[0, 1]^2$.  

    Constructors
    ------------
    * `Eggholder()`  

        Constructor.  

    C++ includes: Eggholder.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptEggholder_swiginit(self, _pysgpp_swig.new_OptEggholder())
    __swig_destroy__ = _pysgpp_swig.delete_OptEggholder

# Register OptEggholder in _pysgpp_swig:
_pysgpp_swig.OptEggholder_swigregister(OptEggholder)

class OptGoldsteinPriceObjective(OptTestScalarFunction):
    r"""

    `GoldsteinPriceObjective()`  

    Goldstein-Price objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := 10^{-4} \cdot (1 +
    (\bar{x}_1+\bar{x}_2+1)^2 (19 - 14\bar{x}_1 + 3\bar{x}_1^2 - 14\bar{x}_2 +
    6\bar{x}_1 \bar{x}_2 + 3\bar{x}_2^2)) \cdot (30 + (2\bar{x}_1 -
    3\bar{x}_2)^2 (18 - 32\bar{x}_1 + 12\bar{x}_1^2 + 48\bar{x}_2 - 36\bar{x}_1
    \bar{x}_2 + 27\bar{x}_2^2))\]  

    Constructors
    ------------
    * `GoldsteinPriceObjective()`  

        Constructor.  

    C++ includes: GoldsteinPrice.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptGoldsteinPriceObjective_swiginit(self, _pysgpp_swig.new_OptGoldsteinPriceObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptGoldsteinPriceObjective

# Register OptGoldsteinPriceObjective in _pysgpp_swig:
_pysgpp_swig.OptGoldsteinPriceObjective_swigregister(OptGoldsteinPriceObjective)

class OptGoldsteinPrice(OptUnconstrainedTestProblem):
    r"""

    `GoldsteinPrice()`  

    Goldstein-Price unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [-2, 2]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (0, -1)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0.0003$  

    Constructors
    ------------
    * `GoldsteinPrice()`  

        Constructor.  

    C++ includes: GoldsteinPrice.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptGoldsteinPrice_swiginit(self, _pysgpp_swig.new_OptGoldsteinPrice())
    __swig_destroy__ = _pysgpp_swig.delete_OptGoldsteinPrice

# Register OptGoldsteinPrice in _pysgpp_swig:
_pysgpp_swig.OptGoldsteinPrice_swigregister(OptGoldsteinPrice)

class OptGriewankObjective(OptTestScalarFunction):
    r"""

    `GriewankObjective(d)`  

    Griewank objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := 1 +
    \frac{\norm{\bar{\vec{x}}}_2^2}{4000} - \prod_{t=1}^d
    \cos\!\left(\frac{\bar{x}_t}{\sqrt{t}}\right)\]  

    Constructors
    ------------
    * `GriewankObjective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Griewank.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptGriewankObjective_swiginit(self, _pysgpp_swig.new_OptGriewankObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptGriewankObjective

# Register OptGriewankObjective in _pysgpp_swig:
_pysgpp_swig.OptGriewankObjective_swigregister(OptGriewankObjective)

class OptGriewank(OptUnconstrainedTestProblem):
    r"""

    `Griewank(d)`  

    Griewank unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [-600, 600]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = \vec{0}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `Griewank(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Griewank.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptGriewank_swiginit(self, _pysgpp_swig.new_OptGriewank(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptGriewank

# Register OptGriewank in _pysgpp_swig:
_pysgpp_swig.OptGriewank_swigregister(OptGriewank)

class OptHartman3Objective(OptTestScalarFunction):
    r"""

    `Hartman3Objective()`  

    Hartman3 objective function.  

    Definition: \begin{gather*} \bar{f}(\bar{\vec{x}}) := -\sum_{i=1}^4 a_i
    \exp\!\left(-\sum_{t=1}^3 b_{i,t} (\bar{x}_t - c_{i,t})^2\right),\\
    \vec{a} = \begin{pmatrix}1\\1.2\\3\\3.2\end{pmatrix},\qquad B :=
    \begin{pmatrix} 3 & 10 & 30\\ 0.1 & 10 & 35\\ 3 & 10 & 30\\ 0.1 & 10 & 35
    \end{pmatrix},\qquad C := \begin{pmatrix} 0.3689 & 0.1170 & 0.2673\\ 0.4699
    & 0.4387 & 0.7470\\ 0.1091 & 0.8732 & 0.5547\\ 0.0382 & 0.5743 & 0.8828
    \end{pmatrix}\end{gather*}  

    Constructors
    ------------
    * `Hartman3Objective()`  

        Constructor.  

    C++ includes: Hartman3.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptHartman3Objective_swiginit(self, _pysgpp_swig.new_OptHartman3Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptHartman3Objective

# Register OptHartman3Objective in _pysgpp_swig:
_pysgpp_swig.OptHartman3Objective_swigregister(OptHartman3Objective)

class OptHartman3(OptUnconstrainedTestProblem):
    r"""

    `Hartman3()`  

    Hartman3 unconstrained test problem.  

    *   Number of parameters: 3  
    *   Domain: $\bar{\vec{x}} \in [0, 1]^3$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (0.1146398, 0.5556488,
        0.8525470)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -3.862785$  

    Constructors
    ------------
    * `Hartman3()`  

        Constructor.  

    C++ includes: Hartman3.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptHartman3_swiginit(self, _pysgpp_swig.new_OptHartman3())
    __swig_destroy__ = _pysgpp_swig.delete_OptHartman3

# Register OptHartman3 in _pysgpp_swig:
_pysgpp_swig.OptHartman3_swigregister(OptHartman3)

class OptHartman6Objective(OptTestScalarFunction):
    r"""

    `Hartman6Objective()`  

    Hartman6 objective function.  

    Definition: \begin{gather*} \bar{f}(\bar{\vec{x}}) := -\sum_{i=1}^4 a_i
    \exp\!\left(-\sum_{t=1}^6 b_{i,t} (\bar{x}_t - c_{i,t})^2\right),\\
    \vec{a} = \begin{pmatrix}1\\1.2\\3\\3.2\end{pmatrix},\qquad B :=
    \begin{pmatrix} 10 & 3 & 17 & 3.5 & 1.7 & 8\\ 0.05 & 10 & 17 & 0.1 & 8 &
    14\\ 3 & 3.5 & 1.7 & 10 & 17 & 8\\ 17 & 8 & 0.05 & 10 & 0.1 & 14
    \end{pmatrix},\\ C := \begin{pmatrix} 0.1312 & 0.1696 & 0.5569 & 0.0124 &
    0.8283 & 0.5886\\ 0.2329 & 0.4135 & 0.8307 & 0.3736 & 0.1004 & 0.9991\\
    0.2348 & 0.1451 & 0.3522 & 0.2883 & 0.3047 & 0.6650\\ 0.4047 & 0.8828 & 0.8732
    & 0.5743 & 0.1091 & 0.0381 \end{pmatrix}\end{gather*}  

    Constructors
    ------------
    * `Hartman6Objective()`  

        Constructor.  

    C++ includes: Hartman6.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptHartman6Objective_swiginit(self, _pysgpp_swig.new_OptHartman6Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptHartman6Objective

# Register OptHartman6Objective in _pysgpp_swig:
_pysgpp_swig.OptHartman6Objective_swigregister(OptHartman6Objective)

class OptHartman6(OptUnconstrainedTestProblem):
    r"""

    `Hartman6()`  

    Hartman6 unconstrained test problem.  

    *   Number of parameters: 6  
    *   Domain: $\bar{\vec{x}} \in $  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (0.2016895, 0.1500107,
        0.4768740, 0.2753324, 0.3116516, 0.6573005)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -3.322368$  

    Constructors
    ------------
    * `Hartman6()`  

        Constructor.  

    C++ includes: Hartman6.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptHartman6_swiginit(self, _pysgpp_swig.new_OptHartman6())
    __swig_destroy__ = _pysgpp_swig.delete_OptHartman6

# Register OptHartman6 in _pysgpp_swig:
_pysgpp_swig.OptHartman6_swigregister(OptHartman6)

class OptHimmelblauObjective(OptTestScalarFunction):
    r"""

    `HimmelblauObjective()`  

    Himmelblau objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := (\bar{x}_1^2 + \bar{x}_2 - 11)^2 +
    (\bar{x}_1 + \bar{x}_2^2 - 7)^2\]  

    Constructors
    ------------
    * `HimmelblauObjective()`  

        Constructor.  

    C++ includes: Himmelblau.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptHimmelblauObjective_swiginit(self, _pysgpp_swig.new_OptHimmelblauObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptHimmelblauObjective

# Register OptHimmelblauObjective in _pysgpp_swig:
_pysgpp_swig.OptHimmelblauObjective_swigregister(OptHimmelblauObjective)

class OptHimmelblau(OptUnconstrainedTestProblem):
    r"""

    `Himmelblau()`  

    Himmelblau unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [-5, 5]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} \in \{(3, 2), (-2.805118,
        3.131313), (-3.779310, -3.283186), (3.584428, -1.848127)\}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `Himmelblau()`  

        Constructor.  

    C++ includes: Himmelblau.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptHimmelblau_swiginit(self, _pysgpp_swig.new_OptHimmelblau())
    __swig_destroy__ = _pysgpp_swig.delete_OptHimmelblau

# Register OptHimmelblau in _pysgpp_swig:
_pysgpp_swig.OptHimmelblau_swigregister(OptHimmelblau)

class OptHoelderTableObjective(OptTestScalarFunction):
    r"""

    `HoelderTableObjective()`  

    Hoelder table objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := -\left|\sin \bar{x}_1 \cos
    \bar{x}_2 \exp\!\left(\left|1 -
    \frac{\norm{\bar{\vec{x}}}_2}{\pi}\right|\right)\right|\],  

    Constructors
    ------------
    * `HoelderTableObjective()`  

        Constructor.  

    C++ includes: HoelderTable.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptHoelderTableObjective_swiginit(self, _pysgpp_swig.new_OptHoelderTableObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptHoelderTableObjective

# Register OptHoelderTableObjective in _pysgpp_swig:
_pysgpp_swig.OptHoelderTableObjective_swigregister(OptHoelderTableObjective)

class OptHoelderTable(OptUnconstrainedTestProblem):
    r"""

    `HoelderTable()`  

    Hoelder table unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [-10, 10]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} \in \{(8.055023, \pm
        9.664590), (-8.055023, \pm 9.664590)\}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -19.20850$  

    The displacement is restricted because the minimal points lie near the corners
    of $[0, 1]^2$.  

    Constructors
    ------------
    * `HoelderTable()`  

        Constructor.  

    C++ includes: HoelderTable.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptHoelderTable_swiginit(self, _pysgpp_swig.new_OptHoelderTable())
    __swig_destroy__ = _pysgpp_swig.delete_OptHoelderTable

# Register OptHoelderTable in _pysgpp_swig:
_pysgpp_swig.OptHoelderTable_swigregister(OptHoelderTable)

class OptIncreasingPowerObjective(OptTestScalarFunction):
    r"""

    `IncreasingPowerObjective(d)`  

    Increasing power objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \sum_{t=1}^d |\bar{x}_t -
    2^{-t}|^{t+1}\]  

    Constructors
    ------------
    * `IncreasingPowerObjective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: IncreasingPower.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptIncreasingPowerObjective_swiginit(self, _pysgpp_swig.new_OptIncreasingPowerObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptIncreasingPowerObjective

# Register OptIncreasingPowerObjective in _pysgpp_swig:
_pysgpp_swig.OptIncreasingPowerObjective_swigregister(OptIncreasingPowerObjective)

class OptIncreasingPower(OptUnconstrainedTestProblem):
    r"""

    `IncreasingPower(d)`  

    Increasing power unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [0, 1]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (2^{-t})_{t=1}^d$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `IncreasingPower(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: IncreasingPower.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptIncreasingPower_swiginit(self, _pysgpp_swig.new_OptIncreasingPower(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptIncreasingPower

# Register OptIncreasingPower in _pysgpp_swig:
_pysgpp_swig.OptIncreasingPower_swigregister(OptIncreasingPower)

class OptMichalewiczObjective(OptTestScalarFunction):
    r"""

    `MichalewiczObjective()`  

    Michalewicz objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := -\sin \bar{x}_1
    \sin^{20}\!\left(\bar{x}_1^2/\pi\right) - \sin \bar{x}_2
    \sin^{20}\!\left(2\bar{x}_2^2/\pi\right)\]  

    Constructors
    ------------
    * `MichalewiczObjective()`  

        Constructor.  

    C++ includes: Michalewicz.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptMichalewiczObjective_swiginit(self, _pysgpp_swig.new_OptMichalewiczObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptMichalewiczObjective

# Register OptMichalewiczObjective in _pysgpp_swig:
_pysgpp_swig.OptMichalewiczObjective_swigregister(OptMichalewiczObjective)

class OptMichalewicz(OptUnconstrainedTestProblem):
    r"""

    `Michalewicz()`  

    Michalewicz unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [0, 5]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (2.202906, \pi/2)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -1.801303$  

    Constructors
    ------------
    * `Michalewicz()`  

        Constructor.  

    C++ includes: Michalewicz.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptMichalewicz_swiginit(self, _pysgpp_swig.new_OptMichalewicz())
    __swig_destroy__ = _pysgpp_swig.delete_OptMichalewicz

# Register OptMichalewicz in _pysgpp_swig:
_pysgpp_swig.OptMichalewicz_swigregister(OptMichalewicz)

class OptMladineoObjective(OptTestScalarFunction):
    r"""

    `MladineoObjective()`  

    Mladineo objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := 1 + \frac{1}{2}
    \norm{\bar{\vec{x}}}_2^2 - \cos(10 \ln(2\bar{x}_1)) \cos(10
    \ln(3\bar{x}_2))\]  

    Constructors
    ------------
    * `MladineoObjective()`  

        Constructor.  

    C++ includes: Mladineo.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptMladineoObjective_swiginit(self, _pysgpp_swig.new_OptMladineoObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptMladineoObjective

# Register OptMladineoObjective in _pysgpp_swig:
_pysgpp_swig.OptMladineoObjective_swigregister(OptMladineoObjective)

class OptMladineo(OptUnconstrainedTestProblem):
    r"""

    `Mladineo()`  

    Mladineo unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [0.01, 1]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (0.01152704, 0.01440461)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        0.0001701830$  

    Constructors
    ------------
    * `Mladineo()`  

        Constructor.  

    C++ includes: Mladineo.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptMladineo_swiginit(self, _pysgpp_swig.new_OptMladineo())
    __swig_destroy__ = _pysgpp_swig.delete_OptMladineo

# Register OptMladineo in _pysgpp_swig:
_pysgpp_swig.OptMladineo_swigregister(OptMladineo)

class OptPermObjective(OptTestScalarFunction):
    r"""

    `PermObjective(d)`  

    Perm objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \sum_{i=1}^d \left(\sum_{t=1}^d
    (t^i + 1) \left(\left(\frac{\bar{x}_t}{t}\right)^i - 1\right)\right)\]  

    Constructors
    ------------
    * `PermObjective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Perm.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptPermObjective_swiginit(self, _pysgpp_swig.new_OptPermObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptPermObjective

# Register OptPermObjective in _pysgpp_swig:
_pysgpp_swig.OptPermObjective_swigregister(OptPermObjective)

class OptPerm(OptUnconstrainedTestProblem):
    r"""

    `Perm(d)`  

    Perm unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [-d, d]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (t)_{t=1}^d$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `Perm(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Perm.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptPerm_swiginit(self, _pysgpp_swig.new_OptPerm(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptPerm

# Register OptPerm in _pysgpp_swig:
_pysgpp_swig.OptPerm_swigregister(OptPerm)

class OptRastriginObjective(OptTestScalarFunction):
    r"""

    `RastriginObjective(d)`  

    Rastrigin objective function.  

    Definition: \[f(\vec{x}) := 10d + \norm{\bar{\vec{x}}}_2^2 - 10
    \sum_{t=1}^d \cos(2\pi \bar{x}_t)\]  

    Constructors
    ------------
    * `RastriginObjective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Rastrigin.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptRastriginObjective_swiginit(self, _pysgpp_swig.new_OptRastriginObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptRastriginObjective

# Register OptRastriginObjective in _pysgpp_swig:
_pysgpp_swig.OptRastriginObjective_swigregister(OptRastriginObjective)

class OptRastrigin(OptUnconstrainedTestProblem):
    r"""

    `Rastrigin(d)`  

    Rastrigin unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [-2, 8]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = \vec{0}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `Rastrigin(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Rastrigin.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptRastrigin_swiginit(self, _pysgpp_swig.new_OptRastrigin(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptRastrigin

# Register OptRastrigin in _pysgpp_swig:
_pysgpp_swig.OptRastrigin_swigregister(OptRastrigin)

class OptRosenbrockObjective(OptTestScalarFunction):
    r"""

    `RosenbrockObjective(d)`  

    Rosenbrock objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \sum_{t=1}^{d-1} \left(100
    (\bar{x}_{t+1} - \bar{x}_t^2)^2 + (1 - \bar{x}_t)^2\right)\]  

    Constructors
    ------------
    * `RosenbrockObjective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Rosenbrock.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptRosenbrockObjective_swiginit(self, _pysgpp_swig.new_OptRosenbrockObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptRosenbrockObjective

# Register OptRosenbrockObjective in _pysgpp_swig:
_pysgpp_swig.OptRosenbrockObjective_swigregister(OptRosenbrockObjective)

class OptRosenbrock(OptUnconstrainedTestProblem):
    r"""

    `Rosenbrock(d)`  

    Rosenbrock unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [-5, 10]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = \vec{1}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `Rosenbrock(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Rosenbrock.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptRosenbrock_swiginit(self, _pysgpp_swig.new_OptRosenbrock(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptRosenbrock

# Register OptRosenbrock in _pysgpp_swig:
_pysgpp_swig.OptRosenbrock_swigregister(OptRosenbrock)

class OptSHCBObjective(OptTestScalarFunction):
    r"""

    `SHCBObjective()`  

    SHCB objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \bar{x}_1^2 \left(4 - 2.1
    \bar{x}_1^2 + \bar{x}_1^4/3\right) + \bar{x}_1 \bar{x}_2 + 4 \bar{x}_2^2
    \left(\bar{x}_2^2 - 1\right)\]  

    Constructors
    ------------
    * `SHCBObjective()`  

        Constructor.  

    C++ includes: SHCB.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSHCBObjective_swiginit(self, _pysgpp_swig.new_OptSHCBObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptSHCBObjective

# Register OptSHCBObjective in _pysgpp_swig:
_pysgpp_swig.OptSHCBObjective_swigregister(OptSHCBObjective)

class OptSHCB(OptUnconstrainedTestProblem):
    r"""

    `SHCB()`  

    SHCB unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [-5, 5]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} \in \{(0.08984247,
        -0.7126564), (-0.08984247, 0.7126564)\}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -1.031628$  

    Constructors
    ------------
    * `SHCB()`  

        Constructor.  

    C++ includes: SHCB.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSHCB_swiginit(self, _pysgpp_swig.new_OptSHCB())
    __swig_destroy__ = _pysgpp_swig.delete_OptSHCB

# Register OptSHCB in _pysgpp_swig:
_pysgpp_swig.OptSHCB_swigregister(OptSHCB)

class OptSchwefel06Objective(OptTestScalarFunction):
    r"""

    `Schwefel06Objective()`  

    Schwefel06 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \max(|\bar{x}_1 + 2 \bar{x}_2 -
    7|, |2 \bar{x}_1 + \bar{x}_2 - 5|)\]  

    Constructors
    ------------
    * `Schwefel06Objective()`  

        Constructor.  

    C++ includes: Schwefel06.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSchwefel06Objective_swiginit(self, _pysgpp_swig.new_OptSchwefel06Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptSchwefel06Objective

# Register OptSchwefel06Objective in _pysgpp_swig:
_pysgpp_swig.OptSchwefel06Objective_swigregister(OptSchwefel06Objective)

class OptSchwefel06(OptUnconstrainedTestProblem):
    r"""

    `Schwefel06()`  

    Schwefel06 unconstrained test problem.  

    *   Number of parameters: 2  
    *   Domain: $\bar{\vec{x}} \in [-100, 100]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (1, 3)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `Schwefel06()`  

        Constructor.  

    C++ includes: Schwefel06.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSchwefel06_swiginit(self, _pysgpp_swig.new_OptSchwefel06())
    __swig_destroy__ = _pysgpp_swig.delete_OptSchwefel06

# Register OptSchwefel06 in _pysgpp_swig:
_pysgpp_swig.OptSchwefel06_swigregister(OptSchwefel06)

class OptSchwefel22Objective(OptTestScalarFunction):
    r"""

    `Schwefel22Objective(d)`  

    Schwefel22 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \sum_{t=1}^d |\bar{x}_t| +
    \prod_{t=1}^d |\bar{x}_t|\]  

    Constructors
    ------------
    * `Schwefel22Objective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Schwefel22.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptSchwefel22Objective_swiginit(self, _pysgpp_swig.new_OptSchwefel22Objective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptSchwefel22Objective

# Register OptSchwefel22Objective in _pysgpp_swig:
_pysgpp_swig.OptSchwefel22Objective_swigregister(OptSchwefel22Objective)

class OptSchwefel22(OptUnconstrainedTestProblem):
    r"""

    `Schwefel22(d)`  

    Schwefel22 unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [-3, 7]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = \vec{0}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `Schwefel22(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Schwefel22.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptSchwefel22_swiginit(self, _pysgpp_swig.new_OptSchwefel22(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptSchwefel22

# Register OptSchwefel22 in _pysgpp_swig:
_pysgpp_swig.OptSchwefel22_swigregister(OptSchwefel22)

class OptSchwefel26Objective(OptTestScalarFunction):
    r"""

    `Schwefel26Objective(d)`  

    Schwefel26 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := -\sum_{t=1}^d \bar{x}_t \sin
    \sqrt{|\bar{x}_t|}\]  

    Constructors
    ------------
    * `Schwefel26Objective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Schwefel26.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptSchwefel26Objective_swiginit(self, _pysgpp_swig.new_OptSchwefel26Objective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptSchwefel26Objective

# Register OptSchwefel26Objective in _pysgpp_swig:
_pysgpp_swig.OptSchwefel26Objective_swigregister(OptSchwefel26Objective)

class OptSchwefel26(OptUnconstrainedTestProblem):
    r"""

    `Schwefel26(d)`  

    Schwefel26 unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [-500, 500]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = 420.9687 \cdot \vec{1}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -418.9829d$  

    Constructors
    ------------
    * `Schwefel26(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Schwefel26.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptSchwefel26_swiginit(self, _pysgpp_swig.new_OptSchwefel26(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptSchwefel26

# Register OptSchwefel26 in _pysgpp_swig:
_pysgpp_swig.OptSchwefel26_swigregister(OptSchwefel26)

class OptSphereObjective(OptTestScalarFunction):
    r"""

    `SphereObjective(d)`  

    Sphere objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \norm{\bar{\vec{x}}}_2^2\]  

    Constructors
    ------------
    * `SphereObjective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Sphere.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptSphereObjective_swiginit(self, _pysgpp_swig.new_OptSphereObjective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptSphereObjective

# Register OptSphereObjective in _pysgpp_swig:
_pysgpp_swig.OptSphereObjective_swigregister(OptSphereObjective)

class OptSphere(OptUnconstrainedTestProblem):
    r"""

    `Sphere(d)`  

    Sphere unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [-1, 9]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = \vec{0}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `Sphere(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: Sphere.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  

        """
        _pysgpp_swig.OptSphere_swiginit(self, _pysgpp_swig.new_OptSphere(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptSphere

# Register OptSphere in _pysgpp_swig:
_pysgpp_swig.OptSphere_swigregister(OptSphere)

class OptTremblingParabolaObjective(OptTestScalarFunction):
    r"""

    `TremblingParabolaObjective(d, p)`  

    Trembling parabola objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \sum_{t=1}^d \left(\bar{x}_t^2/10
    + \frac{|\bar{x}_t|}{2} \left(\frac{g^p(\bar{x}_t)}{g^p(0)} +
    1\right)\right),\qquad g^p(x) := \sum_{k \sim x} (-1)^k b^p(x - k +
    (p+1)/2)\] with $b^p$ being the B-spline with knots $(0, 1, \dotsc, p + 1)$
    (degree $p$) and the sum running over all $k$ for which the summand doesn't
    vanish  

    Constructors
    ------------
    * `TremblingParabolaObjective(d, p)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `p` :  
            smoothness of the function ( $p$ times continuously differentiable)  

    C++ includes: TremblingParabola.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", p: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `p` :  
            smoothness of the function ( $p$ times continuously differentiable)  

        """
        _pysgpp_swig.OptTremblingParabolaObjective_swiginit(self, _pysgpp_swig.new_OptTremblingParabolaObjective(d, p))
    __swig_destroy__ = _pysgpp_swig.delete_OptTremblingParabolaObjective

# Register OptTremblingParabolaObjective in _pysgpp_swig:
_pysgpp_swig.OptTremblingParabolaObjective_swigregister(OptTremblingParabolaObjective)

class OptTremblingParabola(OptUnconstrainedTestProblem):
    r"""

    `TremblingParabola(d, p)`  

    Trembling parabola unconstrained test problem.  

    *   Number of parameters: $d$  
    *   Domain: $\bar{\vec{x}} \in [-4, 16]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = \vec{0}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 0$  

    Constructors
    ------------
    * `TremblingParabola(d, p)`  

        Constructor.  

        Parameters:  
        * `d` :  
            dimension of the domain  
        * `p` :  
            smoothness of the function ( $p$ times continuously differentiable)  

    C++ includes: TremblingParabola.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t", p: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            dimension of the domain  
        * `p` :  
            smoothness of the function ( $p$ times continuously differentiable)  

        """
        _pysgpp_swig.OptTremblingParabola_swiginit(self, _pysgpp_swig.new_OptTremblingParabola(d, p))
    __swig_destroy__ = _pysgpp_swig.delete_OptTremblingParabola

# Register OptTremblingParabola in _pysgpp_swig:
_pysgpp_swig.OptTremblingParabola_swigregister(OptTremblingParabola)

class OptConstrainedTestProblem(object):
    r"""

    `ConstrainedTestProblem(d)`  

    Base class for analytical, constrained test problems.  

    This class essentially manages an objective function and two constraint
    functions (one inequality and one equality constraint function), generates a
    Gaussian displacement vector, and contains the location of the optimal point.  

    Constructors
    ------------
    * `ConstrainedTestProblem(d)`  

        Constructor.  

        The displacement is set to all zeros, so to displace the function call
        generateDisplacement() afterwards.  

        Parameters:  
        * `d` :  
            dimension of the domain  

    C++ includes: ConstrainedTestProblem.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DEFAULT_STANDARD_DEVIATION = _pysgpp_swig.OptConstrainedTestProblem_DEFAULT_STANDARD_DEVIATION
    __swig_destroy__ = _pysgpp_swig.delete_OptConstrainedTestProblem

    def getObjectiveFunction(self) -> "sgpp::optimization::test_problems::TestScalarFunction &":
        r"""


        Returns
        -------
        objective function of the test problem  

        """
        return _pysgpp_swig.OptConstrainedTestProblem_getObjectiveFunction(self)

    def getInequalityConstraintFunction(self) -> "sgpp::optimization::test_problems::TestVectorFunction &":
        r"""


        Returns
        -------
        inequality constraint function of the test problem  

        """
        return _pysgpp_swig.OptConstrainedTestProblem_getInequalityConstraintFunction(self)

    def getEqualityConstraintFunction(self) -> "sgpp::optimization::test_problems::TestVectorFunction &":
        r"""


        Returns
        -------
        equality constraint function of the test problem  

        """
        return _pysgpp_swig.OptConstrainedTestProblem_getEqualityConstraintFunction(self)

    def getOptimalPoint(self, x: "DataVector") -> "double":
        r"""


        Returns the minimal point of the displaced function.  

        Parameters
        ----------
        * `x` :  
            reverse displaced minimal point $\vec{x}_\opt - \vec{d}$  

        Returns
        -------
        minimal function value $f(\vec{x}_\opt)$  

        """
        return _pysgpp_swig.OptConstrainedTestProblem_getOptimalPoint(self, x)

    def getOptimalPointUndisplaced(self, x: "DataVector") -> "double":
        r"""


        Pure virtual method returning the minimal point (or one of the minimal points,
        if there are multiple of them) of the test function.  

        Parameters
        ----------
        * `x` :  
            minimal point $\vec{x}_\opt$  

        Returns
        -------
        minimal function value $f(\vec{x}_\opt)$  

        """
        return _pysgpp_swig.OptConstrainedTestProblem_getOptimalPointUndisplaced(self, x)

    def generateDisplacement(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `generateDisplacement()`  

            Generate normally distributed pseudorandom displacement with default
            standard deviation.  

            This method also sets the new displacement in the objective function and the
            constraint functions.  

        * `generateDisplacement(stdDev)`  

            Generate normally distributed pseudorandom displacement.  

            This method also sets the new displacement in the objective function and the
            constraint functions.  

            Parameters:  
            * `stdDev` :  
                standard deviation of the displacement coordinates  

        """
        return _pysgpp_swig.OptConstrainedTestProblem_generateDisplacement(self, *args)

    def getDisplacement(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        currently used displacement  

        """
        return _pysgpp_swig.OptConstrainedTestProblem_getDisplacement(self)

    def setDisplacement(self, displacement: "DataVector") -> "void":
        r"""


        Returns the displacement vector.  

        This method also sets the new displacement in the objective function and the
        constraint functions.  

        Parameters
        ----------
        * `displacement` :  
            currently used displacement  

        """
        return _pysgpp_swig.OptConstrainedTestProblem_setDisplacement(self, displacement)

# Register OptConstrainedTestProblem in _pysgpp_swig:
_pysgpp_swig.OptConstrainedTestProblem_swigregister(OptConstrainedTestProblem)

class OptFloudasObjective(OptTestScalarFunction):
    r"""

    `FloudasObjective()`  

    Floudas objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := -\bar{x}_1 - \bar{x}_2\]  

    Constructors
    ------------
    * `FloudasObjective()`  

        Constructor.  

    C++ includes: Floudas.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptFloudasObjective_swiginit(self, _pysgpp_swig.new_OptFloudasObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptFloudasObjective

# Register OptFloudasObjective in _pysgpp_swig:
_pysgpp_swig.OptFloudasObjective_swigregister(OptFloudasObjective)

class OptFloudasInequalityConstraint(OptTestVectorFunction):
    r"""

    `FloudasInequalityConstraint()`  

    Floudas inequality constraint function.  

    Definition: \[\vec{\bar{g}}(\bar{\vec{x}}) := \begin{pmatrix} \bar{x}_2 -
    2 \bar{x}_1^4 + 8 \bar{x}_1^3 - 8 \bar{x}_1^2 - 2\\ \bar{x}_2 - 4
    \bar{x}_1^4 + 32 \bar{x}_1^3 - 88 \bar{x}_1^2 + 96 \bar{x}_1 - 36
    \end{pmatrix}\]  

    Constructors
    ------------
    * `FloudasInequalityConstraint()`  

        Constructor.  

    C++ includes: Floudas.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptFloudasInequalityConstraint_swiginit(self, _pysgpp_swig.new_OptFloudasInequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptFloudasInequalityConstraint

# Register OptFloudasInequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptFloudasInequalityConstraint_swigregister(OptFloudasInequalityConstraint)

class OptFloudasEqualityConstraint(OptTestVectorFunction):
    r"""

    `FloudasEqualityConstraint()`  

    Floudas equality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `FloudasEqualityConstraint()`  

        Constructor.  

    C++ includes: Floudas.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptFloudasEqualityConstraint_swiginit(self, _pysgpp_swig.new_OptFloudasEqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptFloudasEqualityConstraint

# Register OptFloudasEqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptFloudasEqualityConstraint_swigregister(OptFloudasEqualityConstraint)

class OptFloudas(OptConstrainedTestProblem):
    r"""

    `Floudas()`  

    Floudas constrained test problem.  

    *   Number of parameters: 2  
    *   Number of inequality constraints: 2  
    *   Number of equality constraints: 0  
    *   Domain: $\bar{\vec{x}} \in [0, 3] \times [0, 4]$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (2.329520, 3.178493)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -5.508013$  

    Constructors
    ------------
    * `Floudas()`  

        Constructor.  

    C++ includes: Floudas.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptFloudas_swiginit(self, _pysgpp_swig.new_OptFloudas())
    __swig_destroy__ = _pysgpp_swig.delete_OptFloudas

# Register OptFloudas in _pysgpp_swig:
_pysgpp_swig.OptFloudas_swigregister(OptFloudas)

class OptG03Objective(OptTestScalarFunction):
    r"""

    `G03Objective(d)`  

    G03 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := -\prod_{t=1}^d \bar{x}_t\]  

    Constructors
    ------------
    * `G03Objective(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            number of parameters  

    C++ includes: G03.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            number of parameters  

        """
        _pysgpp_swig.OptG03Objective_swiginit(self, _pysgpp_swig.new_OptG03Objective(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptG03Objective

# Register OptG03Objective in _pysgpp_swig:
_pysgpp_swig.OptG03Objective_swigregister(OptG03Objective)

class OptG03InequalityConstraint(OptTestVectorFunction):
    r"""

    `G03InequalityConstraint(d)`  

    G03 inequality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `G03InequalityConstraint(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            number of parameters  

    C++ includes: G03.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            number of parameters  

        """
        _pysgpp_swig.OptG03InequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG03InequalityConstraint(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptG03InequalityConstraint

# Register OptG03InequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG03InequalityConstraint_swigregister(OptG03InequalityConstraint)

class OptG03EqualityConstraint(OptTestVectorFunction):
    r"""

    `G03EqualityConstraint(d)`  

    G03 equality constraint function.  

    Definition: \[\bar{h}(\bar{\vec{x}}) := \norm{\bar{\vec{x}}}_2^2 - 1\]  

    Constructors
    ------------
    * `G03EqualityConstraint(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            number of parameters  

    C++ includes: G03.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            number of parameters  

        """
        _pysgpp_swig.OptG03EqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG03EqualityConstraint(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptG03EqualityConstraint

# Register OptG03EqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG03EqualityConstraint_swigregister(OptG03EqualityConstraint)

class OptG03(OptConstrainedTestProblem):
    r"""

    `G03(d)`  

    G03 constrained test problem.  

    *   Number of parameters: $d$  
    *   Number of inequality constraints: 0  
    *   Number of equality constraints: 1  
    *   Domain: $\bar{\vec{x}} \in [0, 1]^d$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = d^{-1/2} \cdot \vec{1}$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -d^{-d/2}$  

    Constructors
    ------------
    * `G03(d)`  

        Constructor.  

        Parameters:  
        * `d` :  
            number of parameters  

    C++ includes: G03.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, d: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `d` :  
            number of parameters  

        """
        _pysgpp_swig.OptG03_swiginit(self, _pysgpp_swig.new_OptG03(d))
    __swig_destroy__ = _pysgpp_swig.delete_OptG03

# Register OptG03 in _pysgpp_swig:
_pysgpp_swig.OptG03_swigregister(OptG03)

class OptG04Objective(OptTestScalarFunction):
    r"""

    `G04Objective()`  

    G04 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := 5.3578547 \bar{x}_3^2 + 0.8356891
    \bar{x}_1 \bar{x}_5 + 37.293239 \bar{x}_1 - 40792.141\]  

    Constructors
    ------------
    * `G04Objective()`  

        Constructor.  

    C++ includes: G04.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG04Objective_swiginit(self, _pysgpp_swig.new_OptG04Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptG04Objective

# Register OptG04Objective in _pysgpp_swig:
_pysgpp_swig.OptG04Objective_swigregister(OptG04Objective)

class OptG04InequalityConstraint(OptTestVectorFunction):
    r"""

    `G04InequalityConstraint()`  

    G04 inequality constraint function.  

    Definition: \[\bar{\vec{g}}(\bar{\vec{x}}) := \begin{pmatrix} 85.334407 +
    0.0056858 \bar{x}_2 \bar{x}_5 + 0.0006262 \bar{x}_1 \bar{x}_4 - 0.0022053
    \bar{x}_3 \bar{x}_5 - 92\\ -85.334407 - 0.0056858 \bar{x}_2 \bar{x}_5 -
    0.0006262 \bar{x}_1 \bar{x}_4 + 0.0022053 \bar{x}_3 \bar{x}_5\\ 80.51249 +
    0.0071317 \bar{x}_2 \bar{x}_5 + 0.0029955 \bar{x}_1 \bar{x}_2 + 0.0021813
    \bar{x}_3^2 - 110\\ -80.51249 - 0.0071317 \bar{x}_2 \bar{x}_5 - 0.0029955
    \bar{x}_1 \bar{x}_2 - 0.0021813 \bar{x}_3^2 + 90\\ 9.300961 + 0.0047026
    \bar{x}_3 \bar{x}_5 + 0.0012547 \bar{x}_1 \bar{x}_3 + 0.0019085 \bar{x}_3
    \bar{x}_4 - 25\\ -9.300961 - 0.0047026 \bar{x}_3 \bar{x}_5 - 0.0012547
    \bar{x}_1 \bar{x}_3 - 0.0019085 \bar{x}_3 \bar{x}_4 + 20 \end{pmatrix}\]  

    Constructors
    ------------
    * `G04InequalityConstraint()`  

        Constructor.  

    C++ includes: G04.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG04InequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG04InequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG04InequalityConstraint

# Register OptG04InequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG04InequalityConstraint_swigregister(OptG04InequalityConstraint)

class OptG04EqualityConstraint(OptTestVectorFunction):
    r"""

    `G04EqualityConstraint()`  

    G04 equality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `G04EqualityConstraint()`  

        Constructor.  

    C++ includes: G04.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG04EqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG04EqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG04EqualityConstraint

# Register OptG04EqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG04EqualityConstraint_swigregister(OptG04EqualityConstraint)

class OptG04(OptConstrainedTestProblem):
    r"""

    `G04()`  

    G04 constrained test problem.  

    *   Number of parameters: 5  
    *   Number of inequality constraints: 6  
    *   Number of equality constraints: 0  
    *   Domain: $\bar{\vec{x}} \in [78, 102] \times [33, 45] \times [27, 45]^3$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (78, 33, 29.99526, 45,
        36.77581)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -30665.54$  

    Constructors
    ------------
    * `G04()`  

        Constructor.  

    C++ includes: G04.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG04_swiginit(self, _pysgpp_swig.new_OptG04())
    __swig_destroy__ = _pysgpp_swig.delete_OptG04

# Register OptG04 in _pysgpp_swig:
_pysgpp_swig.OptG04_swigregister(OptG04)

class OptG04SquaredObjective(OptTestScalarFunction):
    r"""

    `G04SquaredObjective()`  

    G04Squared objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := (5.3578547 \bar{x}_3^2 + 0.8356891
    \bar{x}_1 \bar{x}_5 + 37.293239 \bar{x}_1 - 10120)^2\]  

    Constructors
    ------------
    * `G04SquaredObjective()`  

        Constructor.  

    C++ includes: G04Squared.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG04SquaredObjective_swiginit(self, _pysgpp_swig.new_OptG04SquaredObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptG04SquaredObjective

# Register OptG04SquaredObjective in _pysgpp_swig:
_pysgpp_swig.OptG04SquaredObjective_swigregister(OptG04SquaredObjective)

class OptG04SquaredInequalityConstraint(OptTestVectorFunction):
    r"""

    `G04SquaredInequalityConstraint()`  

    G04Squared inequality constraint function.  

    Definition: \[\bar{\vec{g}}(\bar{\vec{x}}) := \begin{pmatrix} 85.334407 +
    0.0056858 \bar{x}_2 \bar{x}_5 + 0.0006262 \bar{x}_1 \bar{x}_4 - 0.0022053
    \bar{x}_3 \bar{x}_5 - 92\\ -85.334407 - 0.0056858 \bar{x}_2 \bar{x}_5 -
    0.0006262 \bar{x}_1 \bar{x}_4 + 0.0022053 \bar{x}_3 \bar{x}_5\\ 80.51249 +
    0.0071317 \bar{x}_2 \bar{x}_5 + 0.0029955 \bar{x}_1 \bar{x}_2 + 0.0021813
    \bar{x}_3^2 - 110\\ -80.51249 - 0.0071317 \bar{x}_2 \bar{x}_5 - 0.0029955
    \bar{x}_1 \bar{x}_2 - 0.0021813 \bar{x}_3^2 + 90\\ 9.300961 + 0.0047026
    \bar{x}_3 \bar{x}_5 + 0.0012547 \bar{x}_1 \bar{x}_3 + 0.0019085 \bar{x}_3
    \bar{x}_4 - 25\\ -9.300961 - 0.0047026 \bar{x}_3 \bar{x}_5 - 0.0012547
    \bar{x}_1 \bar{x}_3 - 0.0019085 \bar{x}_3 \bar{x}_4 + 20 \end{pmatrix}\]  

    Constructors
    ------------
    * `G04SquaredInequalityConstraint()`  

        Constructor.  

    C++ includes: G04Squared.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG04SquaredInequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG04SquaredInequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG04SquaredInequalityConstraint

# Register OptG04SquaredInequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG04SquaredInequalityConstraint_swigregister(OptG04SquaredInequalityConstraint)

class OptG04SquaredEqualityConstraint(OptTestVectorFunction):
    r"""

    `G04SquaredEqualityConstraint()`  

    G04Squared equality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `G04SquaredEqualityConstraint()`  

        Constructor.  

    C++ includes: G04Squared.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG04SquaredEqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG04SquaredEqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG04SquaredEqualityConstraint

# Register OptG04SquaredEqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG04SquaredEqualityConstraint_swigregister(OptG04SquaredEqualityConstraint)

class OptG04Squared(OptConstrainedTestProblem):
    r"""

    `G04Squared()`  

    G04Squared constrained test problem.  

    *   Number of parameters: 5  
    *   Number of inequality constraints: 6  
    *   Number of equality constraints: 0  
    *   Domain: $\bar{\vec{x}} \in [78, 102] \times [33, 45] \times [27, 45]^3$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (78, 33, 29.99526, 45,
        36.77581)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        43.590738$  

    Constructors
    ------------
    * `G04Squared()`  

        Constructor.  

    C++ includes: G04Squared.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG04Squared_swiginit(self, _pysgpp_swig.new_OptG04Squared())
    __swig_destroy__ = _pysgpp_swig.delete_OptG04Squared

# Register OptG04Squared in _pysgpp_swig:
_pysgpp_swig.OptG04Squared_swigregister(OptG04Squared)

class OptG05Objective(OptTestScalarFunction):
    r"""

    `G05Objective()`  

    G05 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := 3 \bar{x}_1 +
    \left(\frac{\bar{x}_1}{100}\right)^3 + \frac{2}{3}
    \left(\frac{\bar{x}_2}{100}\right)^3\]  

    Constructors
    ------------
    * `G05Objective()`  

        Constructor.  

    C++ includes: G05.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG05Objective_swiginit(self, _pysgpp_swig.new_OptG05Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptG05Objective

# Register OptG05Objective in _pysgpp_swig:
_pysgpp_swig.OptG05Objective_swigregister(OptG05Objective)

class OptG05InequalityConstraint(OptTestVectorFunction):
    r"""

    `G05InequalityConstraint()`  

    G05 inequality constraint function.  

    Definition: \[\bar{\vec{g}}(\bar{\vec{x}}) := \begin{pmatrix} -\bar{x}_4
    + \bar{x}_3 - 11/20\\ -\bar{x}_3 + \bar{x}_4 - 11/20 \end{pmatrix}\]  

    Constructors
    ------------
    * `G05InequalityConstraint()`  

        Constructor.  

    C++ includes: G05.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG05InequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG05InequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG05InequalityConstraint

# Register OptG05InequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG05InequalityConstraint_swigregister(OptG05InequalityConstraint)

class OptG05EqualityConstraint(OptTestVectorFunction):
    r"""

    `G05EqualityConstraint()`  

    G05 equality constraint function.  

    Definition: \[\bar{\vec{h}}(\bar{\vec{x}}) := \begin{pmatrix} 1000
    \sin(-\bar{x}_3 - 1/4) + 1000 \sin(-\bar{x}_4 - 1/4) + 894.8 -
    \bar{x}_1\\ 1000 \sin(\bar{x}_3 - 1/4) + 1000 \sin(\bar{x}_3 - \bar{x}_4
    - 1/4) + 894.8 - \bar{x}_2\\ 1000 \sin(\bar{x}_4 - 1/4) + 1000
    \sin(\bar{x}_4 - \bar{x}_3 - 1/4) + 1294.8 \end{pmatrix}\]  

    Constructors
    ------------
    * `G05EqualityConstraint()`  

        Constructor.  

    C++ includes: G05.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG05EqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG05EqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG05EqualityConstraint

# Register OptG05EqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG05EqualityConstraint_swigregister(OptG05EqualityConstraint)

class OptG05(OptConstrainedTestProblem):
    r"""

    `G05()`  

    G05 constrained test problem.  

    *   Number of parameters: 4  
    *   Number of inequality constraints: 2  
    *   Number of equality constraints: 3  
    *   Domain: $\bar{\vec{x}} \in [0, 1200]^2 \times [-0.55, 0.55]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (679.9453, 1026.067,
        0.1188764, -0.3962336)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 5126.498$  

    Constructors
    ------------
    * `G05()`  

        Constructor.  

    C++ includes: G05.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG05_swiginit(self, _pysgpp_swig.new_OptG05())
    __swig_destroy__ = _pysgpp_swig.delete_OptG05

# Register OptG05 in _pysgpp_swig:
_pysgpp_swig.OptG05_swigregister(OptG05)

class OptG06Objective(OptTestScalarFunction):
    r"""

    `G06Objective()`  

    G06 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := (\bar{x}_1 - 10)^3 + (\bar{x}_2 -
    20)^3\]  

    Constructors
    ------------
    * `G06Objective()`  

        Constructor.  

    C++ includes: G06.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG06Objective_swiginit(self, _pysgpp_swig.new_OptG06Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptG06Objective

# Register OptG06Objective in _pysgpp_swig:
_pysgpp_swig.OptG06Objective_swigregister(OptG06Objective)

class OptG06InequalityConstraint(OptTestVectorFunction):
    r"""

    `G06InequalityConstraint()`  

    G06 inequality constraint function.  

    Definition: \[\bar{\vec{g}}(\bar{\vec{x}}) := \begin{pmatrix} -(\bar{x}_1
    - 5)^2 - (\bar{x}_2 - 5)^2 + 100\\ (\bar{x}_1 - 6)^2 + (\bar{x}_2 - 5)^2 -
    82.81 \end{pmatrix}\]  

    Constructors
    ------------
    * `G06InequalityConstraint()`  

        Constructor.  

    C++ includes: G06.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG06InequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG06InequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG06InequalityConstraint

# Register OptG06InequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG06InequalityConstraint_swigregister(OptG06InequalityConstraint)

class OptG06EqualityConstraint(OptTestVectorFunction):
    r"""

    `G06EqualityConstraint()`  

    G06 equality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `G06EqualityConstraint()`  

        Constructor.  

    C++ includes: G06.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG06EqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG06EqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG06EqualityConstraint

# Register OptG06EqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG06EqualityConstraint_swigregister(OptG06EqualityConstraint)

class OptG06(OptConstrainedTestProblem):
    r"""

    `G06()`  

    G06 constrained test problem.  

    *   Number of parameters: 2  
    *   Number of inequality constraints: 2  
    *   Number of equality constraints: 0  
    *   Domain: $\bar{\vec{x}} \in [13, 100] \times [0, 100]$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (2819/200, 0.8429608)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -6961.814$  

    Constructors
    ------------
    * `G06()`  

        Constructor.  

    C++ includes: G06.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG06_swiginit(self, _pysgpp_swig.new_OptG06())
    __swig_destroy__ = _pysgpp_swig.delete_OptG06

# Register OptG06 in _pysgpp_swig:
_pysgpp_swig.OptG06_swigregister(OptG06)

class OptG08Objective(OptTestScalarFunction):
    r"""

    `G08Objective()`  

    G08 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := -\frac{\sin^3(2\pi \bar{x}_1)
    \sin(2\pi \bar{x}_2)}{\bar{x}_1^3 (\bar{x}_1 + \bar{x}_2)}\]  

    Constructors
    ------------
    * `G08Objective()`  

        Constructor.  

    C++ includes: G08.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG08Objective_swiginit(self, _pysgpp_swig.new_OptG08Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptG08Objective

# Register OptG08Objective in _pysgpp_swig:
_pysgpp_swig.OptG08Objective_swigregister(OptG08Objective)

class OptG08InequalityConstraint(OptTestVectorFunction):
    r"""

    `G08InequalityConstraint()`  

    G08 inequality constraint function.  

    Definition: \[\bar{\vec{g}}(\bar{\vec{x}}) := \begin{pmatrix} \bar{x}_1^2
    - \bar{x}_2 + 1\\ 1 - \bar{x}_1 + (\bar{x}_2 - 4)^2 \end{pmatrix}\]  

    Constructors
    ------------
    * `G08InequalityConstraint()`  

        Constructor.  

    C++ includes: G08.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG08InequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG08InequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG08InequalityConstraint

# Register OptG08InequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG08InequalityConstraint_swigregister(OptG08InequalityConstraint)

class OptG08EqualityConstraint(OptTestVectorFunction):
    r"""

    `G08EqualityConstraint()`  

    G08 equality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `G08EqualityConstraint()`  

        Constructor.  

    C++ includes: G08.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG08EqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG08EqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG08EqualityConstraint

# Register OptG08EqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG08EqualityConstraint_swigregister(OptG08EqualityConstraint)

class OptG08(OptConstrainedTestProblem):
    r"""

    `G08()`  

    G08 constrained test problem.  

    *   Number of parameters: 2  
    *   Number of inequality constraints: 2  
    *   Number of equality constraints: 0  
    *   Domain: $\bar{\vec{x}} \in [0.5, 2.5] \times [3, 6]$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (1.227971, 4.245373)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -0.09582504$  

    Constructors
    ------------
    * `G08()`  

        Constructor.  

    C++ includes: G08.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG08_swiginit(self, _pysgpp_swig.new_OptG08())
    __swig_destroy__ = _pysgpp_swig.delete_OptG08

# Register OptG08 in _pysgpp_swig:
_pysgpp_swig.OptG08_swigregister(OptG08)

class OptG09Objective(OptTestScalarFunction):
    r"""

    `G09Objective()`  

    G09 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := (\bar{x}_1 - 10)^2 + 5 (\bar{x}_2
    - 12)^2 + \bar{x}_3^4 + 3 (\bar{x}_4 - 11)^2 + 10 \bar{x}_5^6 + 7
    \bar{x}_6^2 + \bar{x}_7^4 - 4 \bar{x}_6 \bar{x}_7 - 10 \bar{x}_6 - 8
    \bar{x}_7\]  

    Constructors
    ------------
    * `G09Objective()`  

        Constructor.  

    C++ includes: G09.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG09Objective_swiginit(self, _pysgpp_swig.new_OptG09Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptG09Objective

# Register OptG09Objective in _pysgpp_swig:
_pysgpp_swig.OptG09Objective_swigregister(OptG09Objective)

class OptG09InequalityConstraint(OptTestVectorFunction):
    r"""

    `G09InequalityConstraint()`  

    G09 inequality constraint function.  

    Definition: \[\bar{\vec{g}}(\bar{\vec{x}}) := \begin{pmatrix} -127 + 2
    \bar{x}_1^2 + 3 \bar{x}_2^4 + \bar{x}_3 + 4 \bar{x}_4^2 + 5 \bar{x}_2\\
    -282 + 7 \bar{x}_1 + 3 \bar{x}_2 + 10 \bar{x}_3^2 + \bar{x}_4 -
    \bar{x}_5\\ -196 + 23 \bar{x}_1 + \bar{x}_2^2 + 6 \bar{x}_6^2 - 8
    \bar{x}_7\\ 4 \bar{x}_1^2 + \bar{x}_2^2 - 3 \bar{x}_1 \bar{x}_2 + 2
    \bar{x}_3^2 + 5 \bar{x}_6 - 11 \bar{x}_7 \end{pmatrix}\]  

    Constructors
    ------------
    * `G09InequalityConstraint()`  

        Constructor.  

    C++ includes: G09.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG09InequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG09InequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG09InequalityConstraint

# Register OptG09InequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG09InequalityConstraint_swigregister(OptG09InequalityConstraint)

class OptG09EqualityConstraint(OptTestVectorFunction):
    r"""

    `G09EqualityConstraint()`  

    G09 equality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `G09EqualityConstraint()`  

        Constructor.  

    C++ includes: G09.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG09EqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG09EqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG09EqualityConstraint

# Register OptG09EqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG09EqualityConstraint_swigregister(OptG09EqualityConstraint)

class OptG09(OptConstrainedTestProblem):
    r"""

    `G09()`  

    G09 constrained test problem.  

    *   Number of parameters: 7  
    *   Number of inequality constraints: 4  
    *   Number of equality constraints: 0  
    *   Domain: $\bar{\vec{x}} \in [-10, 10]^7$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (-2.330499, 1.951372,
        -0.4775414, 4.365726, 1.038131, 1.594227)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 680.6301$  

    Constructors
    ------------
    * `G09()`  

        Constructor.  

    C++ includes: G09.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG09_swiginit(self, _pysgpp_swig.new_OptG09())
    __swig_destroy__ = _pysgpp_swig.delete_OptG09

# Register OptG09 in _pysgpp_swig:
_pysgpp_swig.OptG09_swigregister(OptG09)

class OptG10Objective(OptTestScalarFunction):
    r"""

    `G10Objective()`  

    G10 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \bar{x}_1 + \bar{x}_2 +
    \bar{x}_3\]  

    Constructors
    ------------
    * `G10Objective()`  

        Constructor.  

    C++ includes: G10.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG10Objective_swiginit(self, _pysgpp_swig.new_OptG10Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptG10Objective

# Register OptG10Objective in _pysgpp_swig:
_pysgpp_swig.OptG10Objective_swigregister(OptG10Objective)

class OptG10InequalityConstraint(OptTestVectorFunction):
    r"""

    `G10InequalityConstraint()`  

    G10 inequality constraint function.  

    Definition: \[\bar{\vec{g}}(\bar{\vec{x}}) := \begin{pmatrix} -1 +
    (\bar{x}_4 + \bar{x}_6)/400\\ -1 + (\bar{x}_5 + \bar{x}_7 -
    \bar{x}_4)/400\\ -1 + (\bar{x}_8 - \bar{x}_5)/100\\ -\bar{x}_1
    \bar{x}_6 + 833.33252 \bar{x}_4 + 100 \bar{x}_1 - 83333.333\\ -\bar{x}_2
    \bar{x}_7 + 1250 \bar{x}_5 + \bar{x}_2 \bar{x}_4 - 1250 \bar{x}_4\\
    -\bar{x}_3 \bar{x}_8 + 1250000 + \bar{x}_3 \bar{x}_5 - 2500 \bar{x}_5
    \end{pmatrix}\]  

    Constructors
    ------------
    * `G10InequalityConstraint()`  

        Constructor.  

    C++ includes: G10.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG10InequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG10InequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG10InequalityConstraint

# Register OptG10InequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG10InequalityConstraint_swigregister(OptG10InequalityConstraint)

class OptG10EqualityConstraint(OptTestVectorFunction):
    r"""

    `G10EqualityConstraint()`  

    G10 equality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `G10EqualityConstraint()`  

        Constructor.  

    C++ includes: G10.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG10EqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG10EqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG10EqualityConstraint

# Register OptG10EqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG10EqualityConstraint_swigregister(OptG10EqualityConstraint)

class OptG10(OptConstrainedTestProblem):
    r"""

    `G10()`  

    G10 constrained test problem.  

    *   Number of parameters: 8  
    *   Number of inequality constraints: 6  
    *   Number of equality constraints: 0  
    *   Domain: $\bar{\vec{x}} \in [10^2, 10^4] \times [10^3, 10^4]^2 \times
        [10, 10^3]^5$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (579.3167, 1359.943,
        5110.071, 182.0174, 295.5985, 217.9799, 286.4162, 395.5979)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 7049.331$  

    Constructors
    ------------
    * `G10()`  

        Constructor.  

    C++ includes: G10.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG10_swiginit(self, _pysgpp_swig.new_OptG10())
    __swig_destroy__ = _pysgpp_swig.delete_OptG10

# Register OptG10 in _pysgpp_swig:
_pysgpp_swig.OptG10_swigregister(OptG10)

class OptG11Objective(OptTestScalarFunction):
    r"""

    `G11Objective()`  

    G11 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \bar{x}_1^2 + (\bar{x}_2 - 1)^2\]  

    Constructors
    ------------
    * `G11Objective()`  

        Constructor.  

    C++ includes: G11.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG11Objective_swiginit(self, _pysgpp_swig.new_OptG11Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptG11Objective

# Register OptG11Objective in _pysgpp_swig:
_pysgpp_swig.OptG11Objective_swigregister(OptG11Objective)

class OptG11InequalityConstraint(OptTestVectorFunction):
    r"""

    `G11InequalityConstraint()`  

    G11 inequality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `G11InequalityConstraint()`  

        Constructor.  

    C++ includes: G11.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG11InequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG11InequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG11InequalityConstraint

# Register OptG11InequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG11InequalityConstraint_swigregister(OptG11InequalityConstraint)

class OptG11EqualityConstraint(OptTestVectorFunction):
    r"""

    `G11EqualityConstraint()`  

    G11 equality constraint function.  

    Definition: \[\bar{h}(\bar{\vec{x}}) := \bar{x}_2 - \bar{x}_1^2\]  

    Constructors
    ------------
    * `G11EqualityConstraint()`  

        Constructor.  

    C++ includes: G11.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG11EqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG11EqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG11EqualityConstraint

# Register OptG11EqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG11EqualityConstraint_swigregister(OptG11EqualityConstraint)

class OptG11(OptConstrainedTestProblem):
    r"""

    `G11()`  

    G11 constrained test problem.  

    *   Number of parameters: 2  
    *   Number of inequality constraints: 0  
    *   Number of equality constraints: 1  
    *   Domain: $\bar{\vec{x}} \in [-1, 1]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (\pm 1/\sqrt{2}, 1/2)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = 3/4$  

    Constructors
    ------------
    * `G11()`  

        Constructor.  

    C++ includes: G11.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG11_swiginit(self, _pysgpp_swig.new_OptG11())
    __swig_destroy__ = _pysgpp_swig.delete_OptG11

# Register OptG11 in _pysgpp_swig:
_pysgpp_swig.OptG11_swigregister(OptG11)

class OptG12Objective(OptTestScalarFunction):
    r"""

    `G12Objective()`  

    G12 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \norm{\bar{\vec{x}} -
    \vec{5}}_2^2/100 - 1\]  

    Constructors
    ------------
    * `G12Objective()`  

        Constructor.  

    C++ includes: G12.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG12Objective_swiginit(self, _pysgpp_swig.new_OptG12Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptG12Objective

# Register OptG12Objective in _pysgpp_swig:
_pysgpp_swig.OptG12Objective_swigregister(OptG12Objective)

class OptG12InequalityConstraint(OptTestVectorFunction):
    r"""

    `G12InequalityConstraint()`  

    G12 inequality constraint function.  

    Definition: \[\bar{g}(\bar{\vec{x}}) := \min_{y_1,y_2,y_3 = 1,\dotsc,9}
    \norm{\bar{\vec{x}} - \vec{y}}_2^2 - 1/16\]  

    Constructors
    ------------
    * `G12InequalityConstraint()`  

        Constructor.  

    C++ includes: G12.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG12InequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG12InequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG12InequalityConstraint

# Register OptG12InequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG12InequalityConstraint_swigregister(OptG12InequalityConstraint)

class OptG12EqualityConstraint(OptTestVectorFunction):
    r"""

    `G12EqualityConstraint()`  

    G12 equality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `G12EqualityConstraint()`  

        Constructor.  

    C++ includes: G12.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG12EqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG12EqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG12EqualityConstraint

# Register OptG12EqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG12EqualityConstraint_swigregister(OptG12EqualityConstraint)

class OptG12(OptConstrainedTestProblem):
    r"""

    `G12()`  

    G12 constrained test problem.  

    *   Number of parameters: 3  
    *   Number of inequality constraints: 1  
    *   Number of equality constraints: 0  
    *   Domain: $\bar{\vec{x}} \in [0, 10]^3$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (5, 5, 5)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = -1$  

    Constructors
    ------------
    * `G12()`  

        Constructor.  

    C++ includes: G12.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG12_swiginit(self, _pysgpp_swig.new_OptG12())
    __swig_destroy__ = _pysgpp_swig.delete_OptG12

# Register OptG12 in _pysgpp_swig:
_pysgpp_swig.OptG12_swigregister(OptG12)

class OptG13Objective(OptTestScalarFunction):
    r"""

    `G13Objective()`  

    G13 objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \exp\!\Big(\prod_{t=1}^5
    \bar{x}_t\Big)\]  

    Constructors
    ------------
    * `G13Objective()`  

        Constructor.  

    C++ includes: G13.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG13Objective_swiginit(self, _pysgpp_swig.new_OptG13Objective())
    __swig_destroy__ = _pysgpp_swig.delete_OptG13Objective

# Register OptG13Objective in _pysgpp_swig:
_pysgpp_swig.OptG13Objective_swigregister(OptG13Objective)

class OptG13InequalityConstraint(OptTestVectorFunction):
    r"""

    `G13InequalityConstraint()`  

    G13 inequality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `G13InequalityConstraint()`  

        Constructor.  

    C++ includes: G13.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG13InequalityConstraint_swiginit(self, _pysgpp_swig.new_OptG13InequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG13InequalityConstraint

# Register OptG13InequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG13InequalityConstraint_swigregister(OptG13InequalityConstraint)

class OptG13EqualityConstraint(OptTestVectorFunction):
    r"""

    `G13EqualityConstraint()`  

    G13 equality constraint function.  

    Definition: \[\bar{\vec{h}}(\bar{\vec{x}}) := \begin{pmatrix} -10 +
    \norm{\bar{\vec{x}}}_2^2\\ \bar{x}_2 \bar{x}_3 - 5 \bar{x}_4
    \bar{x}_5\\ \bar{x}_1^3 + \bar{x}_2^3 + 1 \end{pmatrix}\]  

    Constructors
    ------------
    * `G13EqualityConstraint()`  

        Constructor.  

    C++ includes: G13.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG13EqualityConstraint_swiginit(self, _pysgpp_swig.new_OptG13EqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptG13EqualityConstraint

# Register OptG13EqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptG13EqualityConstraint_swigregister(OptG13EqualityConstraint)

class OptG13(OptConstrainedTestProblem):
    r"""

    `G13()`  

    G13 constrained test problem.  

    *   Number of parameters: 5  
    *   Number of inequality constraints: 0  
    *   Number of equality constraints: 3  
    *   Domain: $\bar{\vec{x}} \in [-2.3, 2.3]^2 \times [-3.2, 3.2]^3$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (-1.717143, 1.595709,
        1.827247, -0.7636413, -0.7636446)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        0.05394991$  

    Constructors
    ------------
    * `G13()`  

        Constructor.  

    C++ includes: G13.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptG13_swiginit(self, _pysgpp_swig.new_OptG13())
    __swig_destroy__ = _pysgpp_swig.delete_OptG13

# Register OptG13 in _pysgpp_swig:
_pysgpp_swig.OptG13_swigregister(OptG13)

class OptSimionescuObjective(OptTestScalarFunction):
    r"""

    `SimionescuObjective()`  

    Simionescu objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := \frac{1}{10} \bar{x}_1
    \bar{x}_2\]  

    Constructors
    ------------
    * `SimionescuObjective()`  

        Constructor.  

    C++ includes: Simionescu.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSimionescuObjective_swiginit(self, _pysgpp_swig.new_OptSimionescuObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptSimionescuObjective

# Register OptSimionescuObjective in _pysgpp_swig:
_pysgpp_swig.OptSimionescuObjective_swigregister(OptSimionescuObjective)

class OptSimionescuInequalityConstraint(OptTestVectorFunction):
    r"""

    `SimionescuInequalityConstraint()`  

    Simionescu inequality constraint function.  

    Definition: \[\bar{g}(\bar{\vec{x}}) := \bar{x}_1^2 + \bar{x}_2^2 -
    \left(1 + \frac{1}{5} \cos\!\Big(8
    \arctan(\bar{x}_1/\bar{x}_2)\Big)\right)\]  

    Constructors
    ------------
    * `SimionescuInequalityConstraint()`  

        Constructor.  

    C++ includes: Simionescu.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSimionescuInequalityConstraint_swiginit(self, _pysgpp_swig.new_OptSimionescuInequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptSimionescuInequalityConstraint

# Register OptSimionescuInequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptSimionescuInequalityConstraint_swigregister(OptSimionescuInequalityConstraint)

class OptSimionescuEqualityConstraint(OptTestVectorFunction):
    r"""

    `SimionescuEqualityConstraint()`  

    Simionescu equality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `SimionescuEqualityConstraint()`  

        Constructor.  

    C++ includes: Simionescu.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSimionescuEqualityConstraint_swiginit(self, _pysgpp_swig.new_OptSimionescuEqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptSimionescuEqualityConstraint

# Register OptSimionescuEqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptSimionescuEqualityConstraint_swigregister(OptSimionescuEqualityConstraint)

class OptSimionescu(OptConstrainedTestProblem):
    r"""

    `Simionescu()`  

    Simionescu constrained test problem.  

    *   Number of parameters: 2  
    *   Number of inequality constraints: 1  
    *   Number of equality constraints: 0  
    *   Domain: $\bar{\vec{x}} \in [-5/4, 5/4]^2$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = 3\sqrt{2}/5 \cdot (\pm 1,
        \mp 1)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) = -9/125$  

    Constructors
    ------------
    * `Simionescu()`  

        Constructor.  

    C++ includes: Simionescu.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSimionescu_swiginit(self, _pysgpp_swig.new_OptSimionescu())
    __swig_destroy__ = _pysgpp_swig.delete_OptSimionescu

# Register OptSimionescu in _pysgpp_swig:
_pysgpp_swig.OptSimionescu_swigregister(OptSimionescu)

class OptSolandObjective(OptTestScalarFunction):
    r"""

    `SolandObjective()`  

    Soland objective function.  

    Definition: \[\bar{f}(\bar{\vec{x}}) := -12 \bar{x}_1 - 7 \bar{x}_2 +
    \bar{x}_2^2\]  

    Constructors
    ------------
    * `SolandObjective()`  

        Constructor.  

    C++ includes: Soland.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSolandObjective_swiginit(self, _pysgpp_swig.new_OptSolandObjective())
    __swig_destroy__ = _pysgpp_swig.delete_OptSolandObjective

# Register OptSolandObjective in _pysgpp_swig:
_pysgpp_swig.OptSolandObjective_swigregister(OptSolandObjective)

class OptSolandInequalityConstraint(OptTestVectorFunction):
    r"""

    `SolandInequalityConstraint()`  

    Soland inequality constraint function.  

    Definition: empty, i.e., no constraint  

    Constructors
    ------------
    * `SolandInequalityConstraint()`  

        Constructor.  

    C++ includes: Soland.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSolandInequalityConstraint_swiginit(self, _pysgpp_swig.new_OptSolandInequalityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptSolandInequalityConstraint

# Register OptSolandInequalityConstraint in _pysgpp_swig:
_pysgpp_swig.OptSolandInequalityConstraint_swigregister(OptSolandInequalityConstraint)

class OptSolandEqualityConstraint(OptTestVectorFunction):
    r"""

    `SolandEqualityConstraint()`  

    Soland equality constraint function.  

    Definition: \[\bar{h}(\bar{\vec{x}}) := -2 \bar{x}_1^4 - \bar{x}_2 + 2\]  

    Constructors
    ------------
    * `SolandEqualityConstraint()`  

        Constructor.  

    C++ includes: Soland.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSolandEqualityConstraint_swiginit(self, _pysgpp_swig.new_OptSolandEqualityConstraint())
    __swig_destroy__ = _pysgpp_swig.delete_OptSolandEqualityConstraint

# Register OptSolandEqualityConstraint in _pysgpp_swig:
_pysgpp_swig.OptSolandEqualityConstraint_swigregister(OptSolandEqualityConstraint)

class OptSoland(OptConstrainedTestProblem):
    r"""

    `Soland()`  

    Soland constrained test problem.  

    *   Number of parameters: 2  
    *   Number of inequality constraints: 0  
    *   Number of equality constraints: 1  
    *   Domain: $\bar{\vec{x}} \in [0, 2] \times [0, 3]$  
    *   Optimal point: $\bar{\vec{x}}_{\text{opt}} = (0.7175362, 1.469842)$  
    *   Optimal function value: $\bar{f}(\bar{\vec{x}}_{\text{opt}}) =
        -16.73889$  

    Constructors
    ------------
    * `Soland()`  

        Constructor.  

    C++ includes: Soland.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Constructor.  

        """
        _pysgpp_swig.OptSoland_swiginit(self, _pysgpp_swig.new_OptSoland())
    __swig_destroy__ = _pysgpp_swig.delete_OptSoland

# Register OptSoland in _pysgpp_swig:
_pysgpp_swig.OptSoland_swigregister(OptSoland)


def OptFileIOWriteGrid(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `writeGrid(filename, gridStorage)`  

        Write a grid (only grid points) to a file.  

        The format is the same as the version with functions values with all
        function values set to zero.  

        Parameters:  
        * `filename` :  
            filename of the file to be written  
        * `gridStorage` :  
            grid storage containing the grid points  

    * `writeGrid(filename, gridStorage, functionValues)`  

        Write a grid (grid points and function values) to a file.  

        The format is as follows:  


        size_t   N (number of grid points)
        size_t   d (dimension)
        for j = 0, ..., N-1
            for t = 0, ..., d-1
                double           grid_point[j].coord(t)
                unsigned int     grid_point[j].level(t)
                unsigned int     grid_point[j].index(t)
            end
            double   function_value[j]
        end  

        Parameters:  
        * `filename` :  
            filename of the file to be written  
        * `gridStorage` :  
            grid storage containing the grid points  
        * `functionValues` :  
            vector of function values  

    """
    return _pysgpp_swig.OptFileIOWriteGrid(*args)

def OptFileIOReadGrid(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `readGrid(filename, gridStorage)`  

        Read a grid (only grid points) from a file.  

        The format is as in writeGrid (discarding function values).  

        Parameters:  
        * `filename` :  
            filename of the file to be read  
        * `gridStorage` :  
            grid storage containing the grid points  

    * `readGrid(filename, gridStorage, functionValues)`  

        Read a grid (grid points and function values) from a file.  

        The format is as in writeGrid.  

        Parameters:  
        * `filename` :  
            filename of the file to be read  
        * `gridStorage` :  
            grid storage containing the grid points  
        * `functionValues` :  
            vector of function values  

    """
    return _pysgpp_swig.OptFileIOReadGrid(*args)

def OptMathSchurDecomposition(A: "DataMatrix", V: "DataMatrix") -> "void":
    r"""


    Schur decomposition of given matrix $A$ with transformation matrix $V$
    (similiarity transformation such that $S = V^{-1} AV$ upper triangular, $V$
    orthogonal).  

    The diagonal of $S$ contains the eigenvalues of $A$. The Schur decomposition
    exists iff the characteristic polynomial of $A$ factorizes in real linear
    factors. If $A$ is symmetric, then the Schur decomposition exists with diagonal
    $S$, i.e., the columns of $V$ are the eigenvectors of $A$.  

    Parameters
    ----------
    * `A` :  
        square matrix, afterwards $S$  
    * `V` :  
        transformation matrix (must have correct size $n \times n$)  

    """
    return _pysgpp_swig.OptMathSchurDecomposition(A, V)

def OptMathQRDecomposition(A: "DataMatrix", Q: "DataMatrix") -> "void":
    r"""


    QR decomposition of given matrix $A$ with transformation matrix $Q$ with $A =
    QR$ ( $Q$ orthogonal and $R$ upper triangular).  

    Parameters
    ----------
    * `A` :  
        square matrix, afterwards $R$  
    * `Q` :  
        transformation matrix (must have correct size $n \times n$)  

    """
    return _pysgpp_swig.OptMathQRDecomposition(A, Q)

def OptMathHessenbergForm(A: "DataMatrix", V: "DataMatrix") -> "void":
    r"""


    Hessenberg form of given matrix $A$ with transformation matrix $V$ with $H =
    V^{-1} AV$ in Hessenberg form (similiarity transformation such that entries
    $(i,j)$ vanish for $i > j + 1$, $V$ orthogonal).  

    Parameters
    ----------
    * `A` :  
        square matrix, afterwards $H$  
    * `V` :  
        transformation matrix (must have correct size $n \times n$)  

    """
    return _pysgpp_swig.OptMathHessenbergForm(A, V)

def OptMathHouseholderTransformation(A: "DataMatrix", i: "size_t", j: "size_t", Q: "DataMatrix") -> "void":
    r"""


    Calculate transformation matrix $Q$ of a Householder transformation.  

    The normal vector (defining the reflection hyperplane) used is $d := (c_1 +
    \sigma \lVert c \rVert_2, c_2, \dotsc, c_n)$ with $c := A(i:end,j)$ and
    $\sigma := +1$ for $\sigma \ge 0$ and $\sigma := -1$ otherwise. $Q$ is
    symmetric and orthogonal (i.e. $Q = Q^{\mathrm{t}} = Q^{-1}$). After applying
    $QA$, the entries $(i+1:end,j)$ should vanish.  

    Parameters
    ----------
    * `A` :  
        square matrix containing the normal vector  
    * `i` :  
        row index of starting row of normal vector  
    * `j` :  
        column index of starting column of normal vector  
    * `Q` :  
        transformation matrix (must have correct size $(n-i) \times (n-i)$)  

    """
    return _pysgpp_swig.OptMathHouseholderTransformation(A, i, j, Q)

def createOperationMultipleHierarchisation(grid: "Grid") -> "sgpp::optimization::OperationMultipleHierarchisation *":
    r"""


    Creates a OperationMultipleHierarchisation for the given sgpp::optimization
    grid.  

    Don't forget to delete the object after use.  

    Parameters
    ----------
    * `grid` :  
        sparse grid  

    Returns
    -------
    pointer to a OperationMultipleHierarchisation object for the grid  

    """
    return _pysgpp_swig.createOperationMultipleHierarchisation(grid)

def OptFileIOWriteMatrix(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `writeMatrix(filename, A)`  

        Write a base::DataMatrix to a file.  

        Parameters:  
        * `filename` :  
            filename of the file to be written  
        * `A` :  
            matrix  

    * `writeMatrix(filename, A, m, n)`  

        Write a matrix (stored row-wise in a std::vector) to a file.  

        The format is as follows:  


        size_t       m
        size_t       n
        char[16]     type string (one of "uint8", "uint16", "uint32",
                     "uint64", "double", "string", or "other",
                     right-padded with spaces to 16 characters)
        for i = 0, ..., m*n - 1
            T        A[i] (size depending on template parameter,
                     strings are written null-terminatedly)
        end  

        Parameters:  
        * `filename` :  
            filename of the file to be written  
        * `A` :  
            matrix  
        * `m` :  
            number of rows  
        * `n` :  
            number of columns  

    """
    return _pysgpp_swig.OptFileIOWriteMatrix(*args)

def OptFileIOReadMatrix(*args) -> "size_t &, size_t &":
    r"""


    Overloaded function
    -------------------
    * `readMatrix(filename, A)`  

        Read a matrix from a file.  

        The format is as in writeMatrix.  

        Parameters:  
        * `filename` :  
            filename of the file to be read  
        * `A` :  
            matrix  

    * `readMatrix(filename, A, m, n)`  

        Read a matrix (stored row-wise in a std::vector) from a file.  

        The format is as in writeMatrix.  

        Parameters:  
        * `filename` :  
            filename of the file to be written  
        * `A` :  
            matrix  
        * `m` :  
            number of rows  
        * `n` :  
            number of columns  

    """
    return _pysgpp_swig.OptFileIOReadMatrix(*args)

def OptFileIOWriteVector(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `writeVector(filename, x)`  

        Write a base::DataVector to a file.  

        It's writeMatrix with the vector as one row.  

        Parameters:  
        * `filename` :  
            filename of the file to be written  
        * `x` :  
            vector  

    * `writeVector(filename, x)`  

        Write a std::vector to a file.  

        It's writeMatrix with the vector as one row.  

        Parameters:  
        * `filename` :  
            filename of the file to be written  
        * `x` :  
            vector  

    """
    return _pysgpp_swig.OptFileIOWriteVector(*args)

def OptFileIOReadVector(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `readVector(filename, x)`  

        Read a base::DataVector from a file.  

        It's readMatrix with the vector as one row.  

        Parameters:  
        * `filename` :  
            filename of the file to be read  
        * `x` :  
            vector  

    * `readVector(filename, x)`  

        Read a std::vector from a file.  

        It's readMatrix with the vector as one row.  

        Parameters:  
        * `filename` :  
            filename of the file to be read  
        * `x` :  
            vector  

    """
    return _pysgpp_swig.OptFileIOReadVector(*args)
class OptFuzzyIntervalVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.OptFuzzyIntervalVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.OptFuzzyIntervalVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.OptFuzzyIntervalVector___bool__(self)

    def __len__(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::size_type":
        return _pysgpp_swig.OptFuzzyIntervalVector___len__(self)

    def __getslice__(self, i: "std::vector< sgpp::optimization::FuzzyInterval const * >::difference_type", j: "std::vector< sgpp::optimization::FuzzyInterval const * >::difference_type") -> "std::vector< sgpp::optimization::FuzzyInterval const *,std::allocator< sgpp::optimization::FuzzyInterval const * > > *":
        return _pysgpp_swig.OptFuzzyIntervalVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< sgpp::optimization::FuzzyInterval const * >::difference_type", j: "std::vector< sgpp::optimization::FuzzyInterval const * >::difference_type") -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::value_type":
        return _pysgpp_swig.OptFuzzyIntervalVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector___setitem__(self, *args)

    def pop(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::value_type":
        return _pysgpp_swig.OptFuzzyIntervalVector_pop(self)

    def append(self, x: "OptFuzzyInterval") -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.OptFuzzyIntervalVector_empty(self)

    def size(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::size_type":
        return _pysgpp_swig.OptFuzzyIntervalVector_size(self)

    def swap(self, v: "OptFuzzyIntervalVector") -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector_swap(self, v)

    def begin(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::iterator":
        return _pysgpp_swig.OptFuzzyIntervalVector_begin(self)

    def end(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::iterator":
        return _pysgpp_swig.OptFuzzyIntervalVector_end(self)

    def rbegin(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::reverse_iterator":
        return _pysgpp_swig.OptFuzzyIntervalVector_rbegin(self)

    def rend(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::reverse_iterator":
        return _pysgpp_swig.OptFuzzyIntervalVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector_clear(self)

    def get_allocator(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::allocator_type":
        return _pysgpp_swig.OptFuzzyIntervalVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector_pop_back(self)

    def erase(self, *args) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::iterator":
        return _pysgpp_swig.OptFuzzyIntervalVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.OptFuzzyIntervalVector_swiginit(self, _pysgpp_swig.new_OptFuzzyIntervalVector(*args))

    def push_back(self, x: "OptFuzzyInterval") -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector_push_back(self, x)

    def front(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::value_type":
        return _pysgpp_swig.OptFuzzyIntervalVector_front(self)

    def back(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::value_type":
        return _pysgpp_swig.OptFuzzyIntervalVector_back(self)

    def assign(self, n: "std::vector< sgpp::optimization::FuzzyInterval const * >::size_type", x: "OptFuzzyInterval") -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector_insert(self, *args)

    def reserve(self, n: "std::vector< sgpp::optimization::FuzzyInterval const * >::size_type") -> "void":
        return _pysgpp_swig.OptFuzzyIntervalVector_reserve(self, n)

    def capacity(self) -> "std::vector< sgpp::optimization::FuzzyInterval const * >::size_type":
        return _pysgpp_swig.OptFuzzyIntervalVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_OptFuzzyIntervalVector

# Register OptFuzzyIntervalVector in _pysgpp_swig:
_pysgpp_swig.OptFuzzyIntervalVector_swigregister(OptFuzzyIntervalVector)

class DMSystemMatrixBase(OperationMatrix):
    r"""

    `DMSystemMatrixBase(trainData, lambda)`  

    Abstract class that defines the virtual class base::OperationMatrix for
    classification and regression problems.  

    Constructors
    ------------
    * `DMSystemMatrixBase(trainData, lambda)`  

        Std-Constructor.  

        Parameters:  
        * `trainData` :  
            matrix with training data  
        * `lambda` :  
            the lambda, the regression parameter  

    C++ includes: DMSystemMatrixBase.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_DMSystemMatrixBase

    def generateb(self, classes: "DataVector", b: "DataVector") -> "void":
        r"""


        Generates the right hand side of the classification equation.  

        Parameters
        ----------
        * `classes` :  
            the class information of the training data  
        * `b` :  
            reference to the vector that will contain the result of the matrix vector
            multiplication on the rhs  

        """
        return _pysgpp_swig.DMSystemMatrixBase_generateb(self, classes, b)

    def prepareGrid(self) -> "void":
        r"""


        forward declaration  

        rebuilds the base::DataMatrix for Level and Index this routine is needed for
        supporting adaptive grids with vectorized high performance kernels  

        """
        return _pysgpp_swig.DMSystemMatrixBase_prepareGrid(self)

    def resetTimers(self) -> "void":
        r"""


        resets all timers to 0  

        """
        return _pysgpp_swig.DMSystemMatrixBase_resetTimers(self)

    def getTimers(self, timeMult: "double &", computeMult: "double &", timeMultTrans: "double &", computeMultTrans: "double &") -> "void":
        r"""


        gets the timer's values by saving them into call by reference values  

        Parameters
        ----------
        * `timeMult` :  
            variable to store overall time needed for Mult  
        * `computeMult` :  
            variable to store compute time needed for Mult  
        * `timeMultTrans` :  
            variable to store everall time needed for Mult Transposed  
        * `computeMultTrans` :  
            variable to store compute time needed for Mult Transposed  

        """
        return _pysgpp_swig.DMSystemMatrixBase_getTimers(self, timeMult, computeMult, timeMultTrans, computeMultTrans)

# Register DMSystemMatrixBase in _pysgpp_swig:
_pysgpp_swig.DMSystemMatrixBase_swigregister(DMSystemMatrixBase)

class DMSystemMatrix(DMSystemMatrixBase):
    r"""

    `DMSystemMatrix(grid, trainData, C, lambdaRegression)`  

    Class that implements the virtual class base::OperationMatrix for the
    application of classification for the Systemmatrix.  

    Constructors
    ------------
    * `DMSystemMatrix(grid, trainData, C, lambdaRegression)`  

        Std-Constructor.  

        Parameters:  
        * `grid` :  
            reference to the sparse grid  
        * `trainData` :  
            reference to base::DataVector that contains the training data  
        * `C` :  
            the regression functional  
        * `lambdaRegression` :  
            the lambda, the regression parameter  

    C++ includes: DMSystemMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid", trainData: "DataMatrix", C: "std::shared_ptr< sgpp::base::OperationMatrix >", lambdaRegression: "double"):
        r"""


        Std-Constructor.  

        Parameters
        ----------
        * `grid` :  
            reference to the sparse grid  
        * `trainData` :  
            reference to base::DataVector that contains the training data  
        * `C` :  
            the regression functional  
        * `lambdaRegression` :  
            the lambda, the regression parameter  

        """
        _pysgpp_swig.DMSystemMatrix_swiginit(self, _pysgpp_swig.new_DMSystemMatrix(grid, trainData, C, lambdaRegression))
    __swig_destroy__ = _pysgpp_swig.delete_DMSystemMatrix

# Register DMSystemMatrix in _pysgpp_swig:
_pysgpp_swig.DMSystemMatrix_swigregister(DMSystemMatrix)

class DensitySystemMatrix(OperationMatrix):
    r"""

    `DensitySystemMatrix(grid, trainData, C, lambda)`  
    `DensitySystemMatrix(A, B, C, lambda, numSamples)`  

    Class that implements the virtual class OperationMatrix for the application of
    classification for the Systemmatrix by using a density function.  

    Constructors
    ------------
    * `DensitySystemMatrix(grid, trainData, C, lambda)`  

        Std-Constructor.  

        Parameters:  
        * `grid` :  
            reference to the sparse grid  
        * `trainData` :  
            reference to DataVector that contains the training data  
        * `C` :  
            the regression functional  
        * `lambda` :  
            the regression parameter  

    * `DensitySystemMatrix(A, B, C, lambda, numSamples)`  

        Std-Constructor.  

        Parameters:  
        * `A` :  
            L^2 dot product matrix of some grid  
        * `B` :  
            MultipleEval matrix of grid and data points  
        * `C` :  
            the regression functional  
        * `lambda` :  
            the regression parameter  
        * `numSamples` :  
            number of data samples  

    C++ includes: DensitySystemMatrix.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DensitySystemMatrix(grid, trainData, C, lambda)`  

            Std-Constructor.  

            Parameters:  
            * `grid` :  
                reference to the sparse grid  
            * `trainData` :  
                reference to DataVector that contains the training data  
            * `C` :  
                the regression functional  
            * `lambda` :  
                the regression parameter  

        * `DensitySystemMatrix(A, B, C, lambda, numSamples)`  

            Std-Constructor.  

            Parameters:  
            * `A` :  
                L^2 dot product matrix of some grid  
            * `B` :  
                MultipleEval matrix of grid and data points  
            * `C` :  
                the regression functional  
            * `lambda` :  
                the regression parameter  
            * `numSamples` :  
                number of data samples  

        """
        _pysgpp_swig.DensitySystemMatrix_swiginit(self, _pysgpp_swig.new_DensitySystemMatrix(*args))

    def generateb(self, b: "DataVector") -> "void":
        r"""


        Generates the right hand side of the classification equation.  

        Parameters
        ----------
        * `b` :  
            reference to the vector which will contain the result of the matrix vector
            multiplication on the rhs  

        """
        return _pysgpp_swig.DensitySystemMatrix_generateb(self, b)
    __swig_destroy__ = _pysgpp_swig.delete_DensitySystemMatrix

# Register DensitySystemMatrix in _pysgpp_swig:
_pysgpp_swig.DensitySystemMatrix_swigregister(DensitySystemMatrix)

class Dataset(object):
    r"""

    `Dataset()`  
    `Dataset(numberInstances, dimension)`  

    Constructors
    ------------
    * `Dataset()`  

        Constructs an empty dataset (zero size).  

    * `Dataset(numberInstances, dimension)`  

        Constructs an empty dataset with given size.  

        Parameters:  
        * `numberInstances` :  
            number of instances in the dataset  
        * `dimension` :  
            number of dimensions in the dataset  

    C++ includes: Dataset.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `Dataset()`  

            Constructs an empty dataset (zero size).  

        * `Dataset(numberInstances, dimension)`  

            Constructs an empty dataset with given size.  

            Parameters:  
            * `numberInstances` :  
                number of instances in the dataset  
            * `dimension` :  
                number of dimensions in the dataset  

        """
        _pysgpp_swig.Dataset_swiginit(self, _pysgpp_swig.new_Dataset(*args))

    def getNumberInstances(self) -> "size_t":
        r"""


        Returns
        -------
        number of instances in the dataset  

        """
        return _pysgpp_swig.Dataset_getNumberInstances(self)

    def getDimension(self) -> "size_t":
        r"""


        Returns
        -------
        number of dimensions in the dataset  

        """
        return _pysgpp_swig.Dataset_getDimension(self)

    def getTargets(self, *args) -> "sgpp::base::DataVector const &":
        r"""


        Overloaded function
        -------------------
        * `getTargets() -> sgpp::base::DataVector &`  

            Returns:
            classes data of the dataset  

        * `getTargets() -> const sgpp::base::DataVector &`  

            Returns:
            classes data of the dataset  

        """
        return _pysgpp_swig.Dataset_getTargets(self, *args)

    def getData(self, *args) -> "sgpp::base::DataMatrix const &":
        r"""


        Overloaded function
        -------------------
        * `getData() -> sgpp::base::DataMatrix &`  

            Returns:
            training data of the dataset  

        * `getData() -> const sgpp::base::DataMatrix &`  

            Returns:
            training data of the dataset  

        """
        return _pysgpp_swig.Dataset_getData(self, *args)
    __swig_destroy__ = _pysgpp_swig.delete_Dataset

# Register Dataset in _pysgpp_swig:
_pysgpp_swig.Dataset_swigregister(Dataset)

class ParallelConfiguration(object):
    r"""


    Struct that stores all the configuration information for parallelization with
    ScaLAPACK.  

    C++ includes: ParallelConfiguration.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    scalapackEnabled_ = property(_pysgpp_swig.ParallelConfiguration_scalapackEnabled__get, _pysgpp_swig.ParallelConfiguration_scalapackEnabled__set)
    processRows_ = property(_pysgpp_swig.ParallelConfiguration_processRows__get, _pysgpp_swig.ParallelConfiguration_processRows__set)
    processCols_ = property(_pysgpp_swig.ParallelConfiguration_processCols__get, _pysgpp_swig.ParallelConfiguration_processCols__set)
    rowBlockSize_ = property(_pysgpp_swig.ParallelConfiguration_rowBlockSize__get, _pysgpp_swig.ParallelConfiguration_rowBlockSize__set)
    columnBlockSize_ = property(_pysgpp_swig.ParallelConfiguration_columnBlockSize__get, _pysgpp_swig.ParallelConfiguration_columnBlockSize__set)

    def __init__(self):
        _pysgpp_swig.ParallelConfiguration_swiginit(self, _pysgpp_swig.new_ParallelConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_ParallelConfiguration

# Register ParallelConfiguration in _pysgpp_swig:
_pysgpp_swig.ParallelConfiguration_swigregister(ParallelConfiguration)

class CrossvalidationConfiguration(object):
    r"""


    C++ includes: CrossvalidationConfiguration.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    enable_ = property(_pysgpp_swig.CrossvalidationConfiguration_enable__get, _pysgpp_swig.CrossvalidationConfiguration_enable__set)
    kfold_ = property(_pysgpp_swig.CrossvalidationConfiguration_kfold__get, _pysgpp_swig.CrossvalidationConfiguration_kfold__set)
    seed_ = property(_pysgpp_swig.CrossvalidationConfiguration_seed__get, _pysgpp_swig.CrossvalidationConfiguration_seed__set)
    shuffle_ = property(_pysgpp_swig.CrossvalidationConfiguration_shuffle__get, _pysgpp_swig.CrossvalidationConfiguration_shuffle__set)
    silent_ = property(_pysgpp_swig.CrossvalidationConfiguration_silent__get, _pysgpp_swig.CrossvalidationConfiguration_silent__set)
    lambda_ = property(_pysgpp_swig.CrossvalidationConfiguration_lambda__get, _pysgpp_swig.CrossvalidationConfiguration_lambda__set)
    lambdaStart_ = property(_pysgpp_swig.CrossvalidationConfiguration_lambdaStart__get, _pysgpp_swig.CrossvalidationConfiguration_lambdaStart__set)
    lambdaEnd_ = property(_pysgpp_swig.CrossvalidationConfiguration_lambdaEnd__get, _pysgpp_swig.CrossvalidationConfiguration_lambdaEnd__set)
    lambdaSteps_ = property(_pysgpp_swig.CrossvalidationConfiguration_lambdaSteps__get, _pysgpp_swig.CrossvalidationConfiguration_lambdaSteps__set)
    logScale_ = property(_pysgpp_swig.CrossvalidationConfiguration_logScale__get, _pysgpp_swig.CrossvalidationConfiguration_logScale__set)

    def __init__(self):
        _pysgpp_swig.CrossvalidationConfiguration_swiginit(self, _pysgpp_swig.new_CrossvalidationConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_CrossvalidationConfiguration

# Register CrossvalidationConfiguration in _pysgpp_swig:
_pysgpp_swig.CrossvalidationConfiguration_swigregister(CrossvalidationConfiguration)

DensityEstimationType_CG = _pysgpp_swig.DensityEstimationType_CG
DensityEstimationType_Decomposition = _pysgpp_swig.DensityEstimationType_Decomposition
MatrixDecompositionType_LU = _pysgpp_swig.MatrixDecompositionType_LU
MatrixDecompositionType_Eigen = _pysgpp_swig.MatrixDecompositionType_Eigen
MatrixDecompositionType_Chol = _pysgpp_swig.MatrixDecompositionType_Chol
MatrixDecompositionType_DenseIchol = _pysgpp_swig.MatrixDecompositionType_DenseIchol
MatrixDecompositionType_OrthoAdapt = _pysgpp_swig.MatrixDecompositionType_OrthoAdapt
MatrixDecompositionType_SMW_ortho = _pysgpp_swig.MatrixDecompositionType_SMW_ortho
MatrixDecompositionType_SMW_chol = _pysgpp_swig.MatrixDecompositionType_SMW_chol
class DensityEstimationConfiguration(object):
    r"""


    C++ includes: DensityEstimationConfiguration.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type_ = property(_pysgpp_swig.DensityEstimationConfiguration_type__get, _pysgpp_swig.DensityEstimationConfiguration_type__set)
    decomposition_ = property(_pysgpp_swig.DensityEstimationConfiguration_decomposition__get, _pysgpp_swig.DensityEstimationConfiguration_decomposition__set)
    useOfflinePermutation = property(_pysgpp_swig.DensityEstimationConfiguration_useOfflinePermutation_get, _pysgpp_swig.DensityEstimationConfiguration_useOfflinePermutation_set)
    normalize_ = property(_pysgpp_swig.DensityEstimationConfiguration_normalize__get, _pysgpp_swig.DensityEstimationConfiguration_normalize__set)
    iCholSweepsDecompose_ = property(_pysgpp_swig.DensityEstimationConfiguration_iCholSweepsDecompose__get, _pysgpp_swig.DensityEstimationConfiguration_iCholSweepsDecompose__set)
    iCholSweepsRefine_ = property(_pysgpp_swig.DensityEstimationConfiguration_iCholSweepsRefine__get, _pysgpp_swig.DensityEstimationConfiguration_iCholSweepsRefine__set)
    iCholSweepsUpdateLambda_ = property(_pysgpp_swig.DensityEstimationConfiguration_iCholSweepsUpdateLambda__get, _pysgpp_swig.DensityEstimationConfiguration_iCholSweepsUpdateLambda__set)
    iCholSweepsSolver_ = property(_pysgpp_swig.DensityEstimationConfiguration_iCholSweepsSolver__get, _pysgpp_swig.DensityEstimationConfiguration_iCholSweepsSolver__set)

    def __init__(self):
        _pysgpp_swig.DensityEstimationConfiguration_swiginit(self, _pysgpp_swig.new_DensityEstimationConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_DensityEstimationConfiguration

# Register DensityEstimationConfiguration in _pysgpp_swig:
_pysgpp_swig.DensityEstimationConfiguration_swigregister(DensityEstimationConfiguration)

RegularizationMetricType_mse = _pysgpp_swig.RegularizationMetricType_mse
RegularizationMetricType_nll = _pysgpp_swig.RegularizationMetricType_nll
RegularizationMetricType_accuracy = _pysgpp_swig.RegularizationMetricType_accuracy
RegularizationMetricType_residual = _pysgpp_swig.RegularizationMetricType_residual
RegularizationType_Identity = _pysgpp_swig.RegularizationType_Identity
RegularizationType_Laplace = _pysgpp_swig.RegularizationType_Laplace
RegularizationType_Diagonal = _pysgpp_swig.RegularizationType_Diagonal
RegularizationType_Lasso = _pysgpp_swig.RegularizationType_Lasso
RegularizationType_ElasticNet = _pysgpp_swig.RegularizationType_ElasticNet
RegularizationType_GroupLasso = _pysgpp_swig.RegularizationType_GroupLasso
class RegularizationConfiguration(object):
    r"""


    C++ includes: RegularizationConfiguration.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type_ = property(_pysgpp_swig.RegularizationConfiguration_type__get, _pysgpp_swig.RegularizationConfiguration_type__set)
    lambda_ = property(_pysgpp_swig.RegularizationConfiguration_lambda__get, _pysgpp_swig.RegularizationConfiguration_lambda__set)
    l1Ratio_ = property(_pysgpp_swig.RegularizationConfiguration_l1Ratio__get, _pysgpp_swig.RegularizationConfiguration_l1Ratio__set)
    exponentBase_ = property(_pysgpp_swig.RegularizationConfiguration_exponentBase__get, _pysgpp_swig.RegularizationConfiguration_exponentBase__set)
    lamda_start_ = property(_pysgpp_swig.RegularizationConfiguration_lamda_start__get, _pysgpp_swig.RegularizationConfiguration_lamda_start__set)
    lambda_end_ = property(_pysgpp_swig.RegularizationConfiguration_lambda_end__get, _pysgpp_swig.RegularizationConfiguration_lambda_end__set)
    lambda_steps_ = property(_pysgpp_swig.RegularizationConfiguration_lambda_steps__get, _pysgpp_swig.RegularizationConfiguration_lambda_steps__set)
    lambda_log_scale_ = property(_pysgpp_swig.RegularizationConfiguration_lambda_log_scale__get, _pysgpp_swig.RegularizationConfiguration_lambda_log_scale__set)
    optimizeLambda_ = property(_pysgpp_swig.RegularizationConfiguration_optimizeLambda__get, _pysgpp_swig.RegularizationConfiguration_optimizeLambda__set)
    optimizerTolerance_ = property(_pysgpp_swig.RegularizationConfiguration_optimizerTolerance__get, _pysgpp_swig.RegularizationConfiguration_optimizerTolerance__set)
    convergenceThreshold_ = property(_pysgpp_swig.RegularizationConfiguration_convergenceThreshold__get, _pysgpp_swig.RegularizationConfiguration_convergenceThreshold__set)
    intervalA_ = property(_pysgpp_swig.RegularizationConfiguration_intervalA__get, _pysgpp_swig.RegularizationConfiguration_intervalA__set)
    intervalB_ = property(_pysgpp_swig.RegularizationConfiguration_intervalB__get, _pysgpp_swig.RegularizationConfiguration_intervalB__set)
    regularizationMetric_ = property(_pysgpp_swig.RegularizationConfiguration_regularizationMetric__get, _pysgpp_swig.RegularizationConfiguration_regularizationMetric__set)

    def __init__(self):
        _pysgpp_swig.RegularizationConfiguration_swiginit(self, _pysgpp_swig.new_RegularizationConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_RegularizationConfiguration

# Register RegularizationConfiguration in _pysgpp_swig:
_pysgpp_swig.RegularizationConfiguration_swigregister(RegularizationConfiguration)

class DatabaseConfiguration(object):
    r"""


    Configuration structure for the offline datamatrix decomposition database.  

    C++ includes: DatabaseConfiguration.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    filePath = property(_pysgpp_swig.DatabaseConfiguration_filePath_get, _pysgpp_swig.DatabaseConfiguration_filePath_set)

    def __init__(self):
        _pysgpp_swig.DatabaseConfiguration_swiginit(self, _pysgpp_swig.new_DatabaseConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_DatabaseConfiguration

# Register DatabaseConfiguration in _pysgpp_swig:
_pysgpp_swig.DatabaseConfiguration_swigregister(DatabaseConfiguration)

class RefinementMonitor(object):
    r"""


    Superclass for refinement monitors.  

    They track whether a refinement should happen or not.  

    C++ includes: RefinementMonitor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_RefinementMonitor

    def pushToBuffer(self, numberInstances: "size_t", currentValidError: "double", currentTrainError: "double") -> "void":
        r"""


        Stores the current error values in the buffer.  

        If the buffer has reached the maximum size, the oldest values are removed.  

        Parameters
        ----------
        * `numberInstances` :  
            the number of instances added  
        * `currentValidError` :  
            The current validation error  
        * `currentTrainError` :  
            The current training error  

        """
        return _pysgpp_swig.RefinementMonitor_pushToBuffer(self, numberInstances, currentValidError, currentTrainError)

    def refinementsNecessary(self) -> "size_t":
        r"""


        Checks if the model needs to be refined.  

        Returns
        -------
        the number of refinements that are triggered by the monitor  

        """
        return _pysgpp_swig.RefinementMonitor_refinementsNecessary(self)

# Register RefinementMonitor in _pysgpp_swig:
_pysgpp_swig.RefinementMonitor_swigregister(RefinementMonitor)

class RefinementMonitorConvergence(RefinementMonitor):
    r"""

    `RefinementMonitorConvergence(pDeclineThreshold, pBufferSize, pMinRefInterval)`  

    A monitor to decide if a learning algorithm has converged.  

    The convergence criterion is based on the comparison of error measurements
    throughout the training process.  

    Constructors
    ------------
    * `RefinementMonitorConvergence(pDeclineThreshold, pBufferSize,
        pMinRefInterval)`  

        Constructor.  

        Parameters:  
        * `pDeclineThreshold` :  
            The convergence threshold  
        * `pBufferSize` :  
            Number of error measurements which are considered for convergence check  
        * `pMinRefInterval` :  
            Minimum number of iterations before next refinement is allowed to be
            performed  

    C++ includes: RefinementMonitorConvergence.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pDeclineThreshold: "double", pBufferSize: "size_t", pMinRefInterval: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `pDeclineThreshold` :  
            The convergence threshold  
        * `pBufferSize` :  
            Number of error measurements which are considered for convergence check  
        * `pMinRefInterval` :  
            Minimum number of iterations before next refinement is allowed to be
            performed  

        """
        _pysgpp_swig.RefinementMonitorConvergence_swiginit(self, _pysgpp_swig.new_RefinementMonitorConvergence(pDeclineThreshold, pBufferSize, pMinRefInterval))
    __swig_destroy__ = _pysgpp_swig.delete_RefinementMonitorConvergence

# Register RefinementMonitorConvergence in _pysgpp_swig:
_pysgpp_swig.RefinementMonitorConvergence_swigregister(RefinementMonitorConvergence)

class RefinementMonitorPeriodic(RefinementMonitor):
    r"""

    `RefinementMonitorPeriodic(period)`  

    A monitor that decides whether refinements should be performed using a simple
    periodic approach: After at least a certain amount of instances has arrived, the
    monitor will allow a new refinement.  

    Constructors
    ------------
    * `RefinementMonitorPeriodic(period)`  

        Constructor for the periodic refinement monitor.  

        Parameters:  
        * `period` :  
            the number of instances that is needed to trigger a new refinement. If
            set to zero, this monitor will always trigger exactly one refinement  

    C++ includes: RefinementMonitorPeriodic.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, period: "size_t"):
        r"""


        Constructor for the periodic refinement monitor.  

        Parameters
        ----------
        * `period` :  
            the number of instances that is needed to trigger a new refinement. If set
            to zero, this monitor will always trigger exactly one refinement  

        """
        _pysgpp_swig.RefinementMonitorPeriodic_swiginit(self, _pysgpp_swig.new_RefinementMonitorPeriodic(period))
    __swig_destroy__ = _pysgpp_swig.delete_RefinementMonitorPeriodic

# Register RefinementMonitorPeriodic in _pysgpp_swig:
_pysgpp_swig.RefinementMonitorPeriodic_swigregister(RefinementMonitorPeriodic)

class RefinementMonitorFactory(object):
    r"""

    `RefinementMonitorFactory()`  

    Factory to create refinement monitors.  

    Constructors
    ------------
    * `RefinementMonitorFactory()`  

    C++ includes: RefinementMonitorFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        """
        _pysgpp_swig.RefinementMonitorFactory_swiginit(self, _pysgpp_swig.new_RefinementMonitorFactory())

    def createRefinementMonitor(self, adaptivityConfig: "AdaptivityConfiguration") -> "sgpp::datadriven::RefinementMonitor *":
        r"""


        Creates a refinement monitor.  

        Parameters
        ----------
        * `adaptivityConfig` :  
            configuration for the adaptivity of the sparse grid  

        Returns
        -------
        a new refinement monitor instance  

        """
        return _pysgpp_swig.RefinementMonitorFactory_createRefinementMonitor(self, adaptivityConfig)
    __swig_destroy__ = _pysgpp_swig.delete_RefinementMonitorFactory

# Register RefinementMonitorFactory in _pysgpp_swig:
_pysgpp_swig.RefinementMonitorFactory_swigregister(RefinementMonitorFactory)

class BlacsProcessGrid(object):
    r"""

    `BlacsProcessGrid(arg1)`  
    `BlacsProcessGrid(rows=-1, columns=-1)`  

    This class represents a BLACS process grid for use with ScaLAPACK.  

    Constructors
    ------------
    * `BlacsProcessGrid(arg1)`  

        Cannot be copied, otherwise errors with multiple calls to blacs_gridexit are
        possible.  

    * `BlacsProcessGrid(rows=-1, columns=-1)`  

        Creates a BLACS process grid with a certain number of rows and columns.  

        There must be at least rows * columns processes available. If rows or
        columns is set to < 1, a square grid of maximum size is created from the
        available processes. Always call this method from *all* processes, as the
        init method of a BLACS grid has to be called from all processes, otherwise a
        deadlock will occur.  

        Parameters:  
        * `rows` :  
            number of rows of the process grid, default -1 (square grid)  
        * `columns` :  
            number of columns of the process grid, default -1 (square grid)  

    C++ includes: BlacsProcessGrid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, rows: "int"=-1, columns: "int"=-1):
        r"""


        Overloaded function
        -------------------
        * `BlacsProcessGrid(arg1)`  

            Cannot be copied, otherwise errors with multiple calls to blacs_gridexit are
            possible.  

        * `BlacsProcessGrid(rows=-1, columns=-1)`  

            Creates a BLACS process grid with a certain number of rows and columns.  

            There must be at least rows * columns processes available. If rows or
            columns is set to < 1, a square grid of maximum size is created from the
            available processes. Always call this method from *all* processes, as the
            init method of a BLACS grid has to be called from all processes, otherwise a
            deadlock will occur.  

            Parameters:  
            * `rows` :  
                number of rows of the process grid, default -1 (square grid)  
            * `columns` :  
                number of columns of the process grid, default -1 (square grid)  

        """
        _pysgpp_swig.BlacsProcessGrid_swiginit(self, _pysgpp_swig.new_BlacsProcessGrid(rows, columns))
    __swig_destroy__ = _pysgpp_swig.delete_BlacsProcessGrid

    def getContextHandle(self) -> "int":
        r"""


        Returns
        -------
        the context handle of the BLACS context  

        """
        return _pysgpp_swig.BlacsProcessGrid_getContextHandle(self)

    def getTotalRows(self) -> "int":
        r"""


        Returns
        -------
        Total number of rows of the grid  

        """
        return _pysgpp_swig.BlacsProcessGrid_getTotalRows(self)

    def getTotalColumns(self) -> "int":
        r"""


        Returns
        -------
        Total number of columns of the grid  

        """
        return _pysgpp_swig.BlacsProcessGrid_getTotalColumns(self)

    def getCurrentRow(self) -> "int":
        r"""


        Returns
        -------
        Row of the current process  

        """
        return _pysgpp_swig.BlacsProcessGrid_getCurrentRow(self)

    def getCurrentColumn(self) -> "int":
        r"""


        Returns
        -------
        Column of the current process  

        """
        return _pysgpp_swig.BlacsProcessGrid_getCurrentColumn(self)

    def getRowColumnIndex(self) -> "int":
        r"""


        Returns
        -------
        index of the process in the current grid.  

        """
        return _pysgpp_swig.BlacsProcessGrid_getRowColumnIndex(self)

    def getProcessesInGrid(self) -> "int":
        r"""


        Returns
        -------
        the number of processes in the current grid.  

        """
        return _pysgpp_swig.BlacsProcessGrid_getProcessesInGrid(self)

    def isProcessInGrid(self) -> "bool":
        r"""


        Returns
        -------
        True if the current process is part of this grid, else false  

        """
        return _pysgpp_swig.BlacsProcessGrid_isProcessInGrid(self)

    @staticmethod
    def getCurrentProcess() -> "int":
        r"""


        Returns
        -------
        Number of the current process  

        """
        return _pysgpp_swig.BlacsProcessGrid_getCurrentProcess()

    @staticmethod
    def availableProcesses() -> "int":
        r"""


        Can only be called after BLACS initialization.  

        Returns
        -------
        the number of available mpi processes  

        """
        return _pysgpp_swig.BlacsProcessGrid_availableProcesses()

    @staticmethod
    def initializeBlacs() -> "void":
        r"""


        Initialize BLACS, should only be called once.  

        """
        return _pysgpp_swig.BlacsProcessGrid_initializeBlacs()

    @staticmethod
    def exitBlacs() -> "void":
        r"""


        Exit BLACS, should only be called once.  

        """
        return _pysgpp_swig.BlacsProcessGrid_exitBlacs()

# Register BlacsProcessGrid in _pysgpp_swig:
_pysgpp_swig.BlacsProcessGrid_swigregister(BlacsProcessGrid)

def BlacsProcessGrid_getCurrentProcess() -> "int":
    r"""


    Returns
    -------
    Number of the current process  

    """
    return _pysgpp_swig.BlacsProcessGrid_getCurrentProcess()

def BlacsProcessGrid_availableProcesses() -> "int":
    r"""


    Can only be called after BLACS initialization.  

    Returns
    -------
    the number of available mpi processes  

    """
    return _pysgpp_swig.BlacsProcessGrid_availableProcesses()

def BlacsProcessGrid_initializeBlacs() -> "void":
    r"""


    Initialize BLACS, should only be called once.  

    """
    return _pysgpp_swig.BlacsProcessGrid_initializeBlacs()

def BlacsProcessGrid_exitBlacs() -> "void":
    r"""


    Exit BLACS, should only be called once.  

    """
    return _pysgpp_swig.BlacsProcessGrid_exitBlacs()

class DataMatrixDistributed(object):
    r"""

    `DataMatrixDistributed()`  
    `DataMatrixDistributed(input, grid, globalRows, globalColumns, rowBlockSize,
        columnBlockSize, dtype=DTYPE::DENSE)`  
    `DataMatrixDistributed(grid, globalRows, globalColumns, rowBlockSize,
        columnBlockSize, value=0.0, dtype=DTYPE::DENSE)`  

    Class to represent a DataMatrix which is distributed on a process grid.  

    The class provides a wrapper for ScaLAPACK methods on the matrix. See
    http://netlib.org/scalapack/slug/node76.html for information regarding the
    distribution scheme.  

    Constructors
    ------------
    * `DataMatrixDistributed()`  

        Creates an empty DataMatrixDistributed object.  

        Warning: This object cannot be used.  

    * `DataMatrixDistributed(input, grid, globalRows, globalColumns, rowBlockSize,
        columnBlockSize, dtype=DTYPE::DENSE)`  

        Creates an two-dimensional DataMatrixDistributed with the specified input.  

        Call this matrix on all processes in the grid to ensure proper
        initialization.  

        Parameters:  
        * `input` :  
            pointer to data that will be distributed  
        * `grid` :  
            BLACS process grid this matrix will be distributed on  
        * `globalRows` :  
            number of global rows of the matrix  
        * `globalColumns` :  
            number of global columns of the matrix  
        * `rowBlockSize` :  
            block size in the row dimension  
        * `columnBlockSize` :  
            block size in the column dimension  
        * `dtype` :  
            datatype of the matrix, default DENSE  

    * `DataMatrixDistributed(grid, globalRows, globalColumns, rowBlockSize,
        columnBlockSize, value=0.0, dtype=DTYPE::DENSE)`  

        Creates an two-dimensional DataMatrixDistributed filled with a value.  

        Parameters:  
        * `grid` :  
            BLACS process grid this matrix will be distributed on  
        * `globalRows` :  
            number of global rows of the matrix  
        * `globalColumns` :  
            number of global columns of the matrix  
        * `rowBlockSize` :  
            block size in the row dimension  
        * `columnBlockSize` :  
            block size in the column dimension  
        * `value` :  
            initial value for all elements of the matrix, default 0  
        * `dtype` :  
            datatype of the matrix, default DENSE  

    C++ includes: DataMatrixDistributed.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DTYPE_DENSE = _pysgpp_swig.DataMatrixDistributed_DTYPE_DENSE
    DTYPE_TRIDIAG_COEFFICIENT = _pysgpp_swig.DataMatrixDistributed_DTYPE_TRIDIAG_COEFFICIENT
    DTYPE_TRIDIAG_RHS = _pysgpp_swig.DataMatrixDistributed_DTYPE_TRIDIAG_RHS
    DTYPE_OUT_OF_CORE = _pysgpp_swig.DataMatrixDistributed_DTYPE_OUT_OF_CORE
    TRIANGULAR_LOWER = _pysgpp_swig.DataMatrixDistributed_TRIANGULAR_LOWER
    TRIANGULAR_UPPER = _pysgpp_swig.DataMatrixDistributed_TRIANGULAR_UPPER

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DataMatrixDistributed()`  

            Creates an empty DataMatrixDistributed object.  

            Warning: This object cannot be used.  

        * `DataMatrixDistributed(input, grid, globalRows, globalColumns, rowBlockSize,
            columnBlockSize, dtype=DTYPE::DENSE)`  

            Creates an two-dimensional DataMatrixDistributed with the specified input.  

            Call this matrix on all processes in the grid to ensure proper
            initialization.  

            Parameters:  
            * `input` :  
                pointer to data that will be distributed  
            * `grid` :  
                BLACS process grid this matrix will be distributed on  
            * `globalRows` :  
                number of global rows of the matrix  
            * `globalColumns` :  
                number of global columns of the matrix  
            * `rowBlockSize` :  
                block size in the row dimension  
            * `columnBlockSize` :  
                block size in the column dimension  
            * `dtype` :  
                datatype of the matrix, default DENSE  

        * `DataMatrixDistributed(grid, globalRows, globalColumns, rowBlockSize,
            columnBlockSize, value=0.0, dtype=DTYPE::DENSE)`  

            Creates an two-dimensional DataMatrixDistributed filled with a value.  

            Parameters:  
            * `grid` :  
                BLACS process grid this matrix will be distributed on  
            * `globalRows` :  
                number of global rows of the matrix  
            * `globalColumns` :  
                number of global columns of the matrix  
            * `rowBlockSize` :  
                block size in the row dimension  
            * `columnBlockSize` :  
                block size in the column dimension  
            * `value` :  
                initial value for all elements of the matrix, default 0  
            * `dtype` :  
                datatype of the matrix, default DENSE  

        """
        _pysgpp_swig.DataMatrixDistributed_swiginit(self, _pysgpp_swig.new_DataMatrixDistributed(*args))

    @staticmethod
    def fromSharedData(*args) -> "sgpp::datadriven::DataMatrixDistributed":
        r"""


        Creates a distributed data matrix from data which is already shared (mirrored)
        on each process.  

        Avoids network transfers.  

        Parameters
        ----------
        * `input` :  
            pointer to data that will be distributed  
        * `grid` :  
            BLACS process grid this matrix will be distributed on  
        * `globalRows` :  
            number of global rows of the matrix  
        * `globalColumns` :  
            number of global columns of the matrix  
        * `rowBlockSize` :  
            block size in the row dimension  
        * `columnBlockSize` :  
            block size in the column dimension  
        * `dtype` :  
            datatype of the matrix, default DENSE  

        """
        return _pysgpp_swig.DataMatrixDistributed_fromSharedData(*args)

    def get(self, row: "size_t", col: "size_t") -> "double":
        r"""


        Returns the value of the element at position [row,col].  

        Parameters
        ----------
        * `row` :  
            Row  
        * `col` :  
            Column  

        Returns
        -------
        Value of the element  

        """
        return _pysgpp_swig.DataMatrixDistributed_get(self, row, col)

    def set(self, row: "size_t", col: "size_t", value: "double") -> "void":
        r"""


        Sets the element at global position [row,col] to value.  

        Parameters
        ----------
        * `row` :  
            Global row  
        * `col` :  
            Global column  
        * `value` :  
            New value for element  

        """
        return _pysgpp_swig.DataMatrixDistributed_set(self, row, col, value)

    def setAll(self, value: "double") -> "void":
        r"""


        Set all entries of the matrix to one value.  

        Parameters
        ----------
        * `value` :  

        """
        return _pysgpp_swig.DataMatrixDistributed_setAll(self, value)

    def copyFrom(self, other: "DataMatrixDistributed") -> "void":
        r"""


        Copies all values of another distributed data matrix to this object, resizes
        this object to the size of the other matrix.  

        """
        return _pysgpp_swig.DataMatrixDistributed_copyFrom(self, other)

    @staticmethod
    def transpose(*args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `transpose() -> DataMatrixDistributed`  

            Transposes this matrix.  

            Returns:
            the transposed version of this matrix  

        * `transpose(a, c, alpha=1.0, beta=0.0)`  

            Transposes matrix A and stores the result in C: sub(C):=beta*sub(C) +
            alpha*sub(A)'.  

            Parameters:  
            * `a` :  
                matrix A to transpose  
            * `c` :  
                result matrix C  
            * `alpha` :  
                factor for matrix A, default 1.0  
            * `beta` :  
                factor for matrix C, default 0.0  

        """
        return _pysgpp_swig.DataMatrixDistributed_transpose(*args)

    @staticmethod
    def add(*args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `add(a)`  

            Adds the values from another DataMatrix to the current values.  

            Modifies the current values.  

            Parameters:  
            * `a` :  
                The DataMatrix which is added to the current values  

        * `add(c, a, transposeA=false, beta=1.0, alpha=1.0)`  

            Calculates sub(C):=beta*sub(C) + alpha*op(sub(A))  

            Parameters:  
            * `c` :  
                matrix C  
            * `a` :  
                matrix A  
            * `transposeA` :  
                transpose matrix A if true, default false  
            * `beta` :  
                scalar factor for matrix C, default 1.0  
            * `alpha` :  
                scalar factor for matrix A, default 1.0  

        """
        return _pysgpp_swig.DataMatrixDistributed_add(*args)

    @staticmethod
    def sub(*args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `sub(a)`  

            Subtracts the values from another DataMatrix of the current values.  

            Modifies the current values.  

            Parameters:  
            * `a` :  
                The DataMatrix which is subtracted from the current values  

        * `sub(c, a, transposeA=false, beta=1.0, alpha=1.0)`  

            Calculates sub(C):=beta*sub(C) - alpha*op(sub(A))  

            Parameters:  
            * `c` :  
                matrix C  
            * `a` :  
                matrix A  
            * `transposeA` :  
                transpose matrix A if true, default false  
            * `beta` :  
                scalar factor for matrix C, default 1.0  
            * `alpha` :  
                scalar factor for matrix A, default 1.0  

        """
        return _pysgpp_swig.DataMatrixDistributed_sub(*args)

    @staticmethod
    def mult(*args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `mult(b, c, transposeA=false, transposeB=false, alpha=1.0, beta=0.0)`  

            Uses PBLAS to multiply this matrix with matrix B:  

            sub(C) := alpha*op(sub(this))*op(sub(B)) + beta*sub(C)  

            Parameters:  
            * `b` :  
                matrix B  
            * `c` :  
                used as output matrix C, can also be added to the product using factor
                beta  
            * `transposeA` :  
                Whether or not to transpose this matrix  
            * `transposeB` :  
                Whether or not to transpose matrix B  
            * `alpha` :  
                factor alpha, default 1.0  
            * `beta` :  
                factor beta, default 0.0  

        * `mult(x, y, transpose=false, alpha=1.0, beta=0.0)`  

            Multiplies the matrix with a vector x and stores the result in another
            vector y.  

            sub(y) := alpha*sub(this)'*sub(x) + beta*sub(y)  

            Parameters:  
            * `x` :  
                vector to be multiplied  
            * `y` :  
                vector in which the result should be stored  
            * `transpose` :  
                transpose if true, default false  
            * `alpha` :  
                factor alpha, default 1.0  
            * `beta` :  
                factor beta, default 0.0  

        * `mult(a, b, c, transposeA=false, transposeB=false, alpha=1.0, beta=0.0)`  

            Uses BLAS to multiply matrix A with matrix B:  

            sub(C) := alpha*op(sub(A))*op(sub(B)) + beta*sub(C)  

            Parameters:  
            * `a` :  
                matrix A  
            * `b` :  
                matrix B  
            * `c` :  
                used as output matrix C, can also be added to the product using factor
                beta  
            * `transposeA` :  
                Whether or not to transpose this matrix  
            * `transposeB` :  
                Whether or not to transpose matrix B  
            * `alpha` :  
                factor alpha, default 1.0  
            * `beta` :  
                factor beta, default 0.0  

        * `mult(a, x, y, transpose=false, alpha=1.0, beta=0.0)`  

            Multiplies matrix A with a vector x and stores the result in another vector
            y.  

            sub(y) := alpha*sub(A)'*sub(x) + beta*sub(y)  

            Parameters:  
            * `a` :  
                matrix to be multiplied  
            * `x` :  
                vector to be multiplied  
            * `y` :  
                vector in which the result should be stored  
            * `transpose` :  
                transpose if true, default false  
            * `alpha` :  
                factor alpha, default 1.0  
            * `beta` :  
                factor beta, default 0.0  

        """
        return _pysgpp_swig.DataMatrixDistributed_mult(*args)

    @staticmethod
    def solveCholesky(*args) -> "void":
        r"""


        Solves a linear system of equations Ax=b using a previously computed Cholesky
        decomposition A=LL^T.  

        Parameters
        ----------
        * `l` :  
            lower triangular matrix L of the Cholesky decomposition  
        * `b` :  
            vector b of the linear system, is overwritten with solution x  
        * `uplo` :  
            storage format of the triangular matrix, either upper or lower triangular  

        """
        return _pysgpp_swig.DataMatrixDistributed_solveCholesky(*args)

    def resize(self, rows: "size_t", cols: "size_t") -> "void":
        r"""


        Resizes the matrix to rows and cols, data is discarded.  

        Parameters
        ----------
        * `rows` :  
        * `cols` :  

        """
        return _pysgpp_swig.DataMatrixDistributed_resize(self, rows, cols)

    def toVector(self) -> "sgpp::datadriven::DataVectorDistributed":
        r"""


        Convert this matrix to a vector.  

        This operation is only possible if either globalRows or globalColumns equals
        one.  

        Returns
        -------
        A DataVectorDistributed object with the same size and data  

        """
        return _pysgpp_swig.DataMatrixDistributed_toVector(self)

    def getLocalPointer(self, *args) -> "double const *":
        r"""


        Overloaded function
        -------------------
        * `getLocalPointer() -> double *`  

            Returns:
            Pointer to the local data of this process  

        * `getLocalPointer() -> const double *`  

            Returns:
            const pointer to the local data of this process  

        """
        return _pysgpp_swig.DataMatrixDistributed_getLocalPointer(self, *args)

    def toLocalDataMatrix(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `toLocalDataMatrix() -> DataMatrix`  

            Returns:
            the gathered DataMatrix as a normal, not distributed, DataMatrix.  

        * `toLocalDataMatrix(localMatrix)`  

            Parameters:  
            * `localMatrix` :  
                the gathered DataMatrix as a normal, not distributed, DataMatrix. Result
                can only be used on the master process.  

        """
        return _pysgpp_swig.DataMatrixDistributed_toLocalDataMatrix(self, *args)

    def toLocalDataMatrixBroadcast(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `toLocalDataMatrixBroadcast() -> DataMatrix`  

            Returns:
            the whole DataMatrix on broadcasted to all processes in the grid  

        * `toLocalDataMatrixBroadcast(localMatrix)`  

            Parameters:  
            * `localMatrix` :  
                the whole DataMatrix is broadcasted to all processes in the grid  

        """
        return _pysgpp_swig.DataMatrixDistributed_toLocalDataMatrixBroadcast(self, *args)

    def getDescriptor(self, *args) -> "int const *":
        r"""


        Overloaded function
        -------------------
        * `getDescriptor() -> int *`  

            Returns:
            The ScaLAPACK matrix descriptor  

        * `getDescriptor() -> const int *`  

            Returns:
            Const pointer to ScaLAPACK matrix descriptor  

        """
        return _pysgpp_swig.DataMatrixDistributed_getDescriptor(self, *args)

    def getGlobalRows(self) -> "size_t":
        r"""


        Returns the number of rows of the DataMatrix.  

        Returns
        -------
        Number of rows  

        """
        return _pysgpp_swig.DataMatrixDistributed_getGlobalRows(self)

    def getGlobalCols(self) -> "size_t":
        r"""


        Returns the number of columns of the DataMatrix.  

        Returns
        -------
        Number of columns  

        """
        return _pysgpp_swig.DataMatrixDistributed_getGlobalCols(self)

    def getLocalRows(self) -> "size_t":
        r"""


        Returns
        -------
        number of rows assigned to the current process  

        """
        return _pysgpp_swig.DataMatrixDistributed_getLocalRows(self)

    def getLocalColumns(self) -> "size_t":
        r"""


        Returns
        -------
        number of columns assigned to the current process  

        """
        return _pysgpp_swig.DataMatrixDistributed_getLocalColumns(self)

    def getRowBlockSize(self) -> "size_t":
        r"""


        Returns
        -------
        the row block size.  

        """
        return _pysgpp_swig.DataMatrixDistributed_getRowBlockSize(self)

    def getColumnBlockSize(self) -> "size_t":
        r"""


        Returns
        -------
        the column block size.  

        """
        return _pysgpp_swig.DataMatrixDistributed_getColumnBlockSize(self)

    def getProcessGrid(self) -> "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >":
        r"""


        Returns
        -------
        the process grid of this matrix.  

        """
        return _pysgpp_swig.DataMatrixDistributed_getProcessGrid(self)

    def printMatrix(self) -> "void":
        r"""


        Prints the matrix on stdout on process 0.  

        """
        return _pysgpp_swig.DataMatrixDistributed_printMatrix(self)

    def isProcessMapped(self) -> "bool":
        r"""


        Returns
        -------
        true if part of the matrix is mapped to the current process, false otherwise  

        """
        return _pysgpp_swig.DataMatrixDistributed_isProcessMapped(self)

    def globalToLocalRowIndex(self, globalRowIndex: "size_t") -> "size_t":
        r"""


        Calculates the local row index from the globalRowIndex.  

        Parameters
        ----------
        * `globalRowIndex` :  

        """
        return _pysgpp_swig.DataMatrixDistributed_globalToLocalRowIndex(self, globalRowIndex)

    def globalToLocalColumnIndex(self, globalColumnIndex: "size_t") -> "size_t":
        r"""


        Calculates the local column index from the globalColumnIndex.  

        Parameters
        ----------
        * `globalColumnIndex` :  

        """
        return _pysgpp_swig.DataMatrixDistributed_globalToLocalColumnIndex(self, globalColumnIndex)

    def localToGlobalRowIndex(self, localRowIndex: "size_t") -> "size_t":
        r"""


        Calculates the global row index from the local row index.  

        Parameters
        ----------
        * `localRowIndex` :  

        """
        return _pysgpp_swig.DataMatrixDistributed_localToGlobalRowIndex(self, localRowIndex)

    def localToGlobalColumnIndex(self, localColumnIndex: "size_t") -> "size_t":
        r"""


        Calculates the global column index from the local column index.  

        Parameters
        ----------
        * `localColumnIndex` :  

        """
        return _pysgpp_swig.DataMatrixDistributed_localToGlobalColumnIndex(self, localColumnIndex)

    def globalToRowProcessIndex(self, globalRowIndex: "size_t") -> "size_t":
        r"""


        Calculates the row process index from the global row index.  

        Parameters
        ----------
        * `globalRowIndex` :  

        """
        return _pysgpp_swig.DataMatrixDistributed_globalToRowProcessIndex(self, globalRowIndex)

    def globalToColumnProcessIndex(self, globalColumnIndex: "size_t") -> "size_t":
        r"""


        Calculates the column process index from the global column index.  

        Parameters
        ----------
        * `globalColumnIndex` :  

        """
        return _pysgpp_swig.DataMatrixDistributed_globalToColumnProcessIndex(self, globalColumnIndex)

    def distribute(self, matrix: "double const *", masterRow: "int"=0, masterCol: "int"=0) -> "void":
        r"""


        Distribute the matrix from the master on the process grid according to the 2d
        block cyclic scheme used in scalapack.  

        More information: http://www.netlib.org/scalapack/slug/node76.html  

        Parameters
        ----------
        * `matrix` :  
            Pointer to the local matrix, only relevant for the master process  
        * `masterRow` :  
            row coordinate of the master process, default 0  
        * `masterCol` :  
            col coordinate of the master process, default 0  

        """
        return _pysgpp_swig.DataMatrixDistributed_distribute(self, matrix, masterRow, masterCol)
    __swig_destroy__ = _pysgpp_swig.delete_DataMatrixDistributed

# Register DataMatrixDistributed in _pysgpp_swig:
_pysgpp_swig.DataMatrixDistributed_swigregister(DataMatrixDistributed)

def DataMatrixDistributed_fromSharedData(*args) -> "sgpp::datadriven::DataMatrixDistributed":
    r"""


    Creates a distributed data matrix from data which is already shared (mirrored)
    on each process.  

    Avoids network transfers.  

    Parameters
    ----------
    * `input` :  
        pointer to data that will be distributed  
    * `grid` :  
        BLACS process grid this matrix will be distributed on  
    * `globalRows` :  
        number of global rows of the matrix  
    * `globalColumns` :  
        number of global columns of the matrix  
    * `rowBlockSize` :  
        block size in the row dimension  
    * `columnBlockSize` :  
        block size in the column dimension  
    * `dtype` :  
        datatype of the matrix, default DENSE  

    """
    return _pysgpp_swig.DataMatrixDistributed_fromSharedData(*args)

def DataMatrixDistributed_transpose(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `transpose() -> DataMatrixDistributed`  

        Transposes this matrix.  

        Returns:
        the transposed version of this matrix  

    * `transpose(a, c, alpha=1.0, beta=0.0)`  

        Transposes matrix A and stores the result in C: sub(C):=beta*sub(C) +
        alpha*sub(A)'.  

        Parameters:  
        * `a` :  
            matrix A to transpose  
        * `c` :  
            result matrix C  
        * `alpha` :  
            factor for matrix A, default 1.0  
        * `beta` :  
            factor for matrix C, default 0.0  

    """
    return _pysgpp_swig.DataMatrixDistributed_transpose(*args)

def DataMatrixDistributed_add(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `add(a)`  

        Adds the values from another DataMatrix to the current values.  

        Modifies the current values.  

        Parameters:  
        * `a` :  
            The DataMatrix which is added to the current values  

    * `add(c, a, transposeA=false, beta=1.0, alpha=1.0)`  

        Calculates sub(C):=beta*sub(C) + alpha*op(sub(A))  

        Parameters:  
        * `c` :  
            matrix C  
        * `a` :  
            matrix A  
        * `transposeA` :  
            transpose matrix A if true, default false  
        * `beta` :  
            scalar factor for matrix C, default 1.0  
        * `alpha` :  
            scalar factor for matrix A, default 1.0  

    """
    return _pysgpp_swig.DataMatrixDistributed_add(*args)

def DataMatrixDistributed_sub(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `sub(a)`  

        Subtracts the values from another DataMatrix of the current values.  

        Modifies the current values.  

        Parameters:  
        * `a` :  
            The DataMatrix which is subtracted from the current values  

    * `sub(c, a, transposeA=false, beta=1.0, alpha=1.0)`  

        Calculates sub(C):=beta*sub(C) - alpha*op(sub(A))  

        Parameters:  
        * `c` :  
            matrix C  
        * `a` :  
            matrix A  
        * `transposeA` :  
            transpose matrix A if true, default false  
        * `beta` :  
            scalar factor for matrix C, default 1.0  
        * `alpha` :  
            scalar factor for matrix A, default 1.0  

    """
    return _pysgpp_swig.DataMatrixDistributed_sub(*args)

def DataMatrixDistributed_mult(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `mult(b, c, transposeA=false, transposeB=false, alpha=1.0, beta=0.0)`  

        Uses PBLAS to multiply this matrix with matrix B:  

        sub(C) := alpha*op(sub(this))*op(sub(B)) + beta*sub(C)  

        Parameters:  
        * `b` :  
            matrix B  
        * `c` :  
            used as output matrix C, can also be added to the product using factor
            beta  
        * `transposeA` :  
            Whether or not to transpose this matrix  
        * `transposeB` :  
            Whether or not to transpose matrix B  
        * `alpha` :  
            factor alpha, default 1.0  
        * `beta` :  
            factor beta, default 0.0  

    * `mult(x, y, transpose=false, alpha=1.0, beta=0.0)`  

        Multiplies the matrix with a vector x and stores the result in another
        vector y.  

        sub(y) := alpha*sub(this)'*sub(x) + beta*sub(y)  

        Parameters:  
        * `x` :  
            vector to be multiplied  
        * `y` :  
            vector in which the result should be stored  
        * `transpose` :  
            transpose if true, default false  
        * `alpha` :  
            factor alpha, default 1.0  
        * `beta` :  
            factor beta, default 0.0  

    * `mult(a, b, c, transposeA=false, transposeB=false, alpha=1.0, beta=0.0)`  

        Uses BLAS to multiply matrix A with matrix B:  

        sub(C) := alpha*op(sub(A))*op(sub(B)) + beta*sub(C)  

        Parameters:  
        * `a` :  
            matrix A  
        * `b` :  
            matrix B  
        * `c` :  
            used as output matrix C, can also be added to the product using factor
            beta  
        * `transposeA` :  
            Whether or not to transpose this matrix  
        * `transposeB` :  
            Whether or not to transpose matrix B  
        * `alpha` :  
            factor alpha, default 1.0  
        * `beta` :  
            factor beta, default 0.0  

    * `mult(a, x, y, transpose=false, alpha=1.0, beta=0.0)`  

        Multiplies matrix A with a vector x and stores the result in another vector
        y.  

        sub(y) := alpha*sub(A)'*sub(x) + beta*sub(y)  

        Parameters:  
        * `a` :  
            matrix to be multiplied  
        * `x` :  
            vector to be multiplied  
        * `y` :  
            vector in which the result should be stored  
        * `transpose` :  
            transpose if true, default false  
        * `alpha` :  
            factor alpha, default 1.0  
        * `beta` :  
            factor beta, default 0.0  

    """
    return _pysgpp_swig.DataMatrixDistributed_mult(*args)

def DataMatrixDistributed_solveCholesky(*args) -> "void":
    r"""


    Solves a linear system of equations Ax=b using a previously computed Cholesky
    decomposition A=LL^T.  

    Parameters
    ----------
    * `l` :  
        lower triangular matrix L of the Cholesky decomposition  
    * `b` :  
        vector b of the linear system, is overwritten with solution x  
    * `uplo` :  
        storage format of the triangular matrix, either upper or lower triangular  

    """
    return _pysgpp_swig.DataMatrixDistributed_solveCholesky(*args)

class DataVectorDistributed(object):
    r"""

    `DataVectorDistributed(input, grid, globalSize, blockSize)`  
    `DataVectorDistributed(grid, globalSize, blockSize, value=0.0)`  

    Constructors
    ------------
    * `DataVectorDistributed(input, grid, globalSize, blockSize)`  

        Creates a distributed data vector with specified input data.  

        Parameters:  
        * `input` :  
            pointer to input values for this vector  
        * `grid` :  
            blacs grid for distribution  
        * `globalSize` :  
            global size (rows) of this vector  
        * `blockSize` :  
            size for each block (one process might receive multiple blocks)  

    * `DataVectorDistributed(grid, globalSize, blockSize, value=0.0)`  

        Creates a distributed data vector of specified size and initializes the
        elements to value.  

        Parameters:  
        * `grid` :  
            blacs grid for distribution  
        * `globalSize` :  
            global size (rows) of this vector  
        * `blockSize` :  
            size for each block (one process might receive multiple blocks)  
        * `value` :  
            Initial value of all elements, default 0.0  

    C++ includes: DataVectorDistributed.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DataVectorDistributed(input, grid, globalSize, blockSize)`  

            Creates a distributed data vector with specified input data.  

            Parameters:  
            * `input` :  
                pointer to input values for this vector  
            * `grid` :  
                blacs grid for distribution  
            * `globalSize` :  
                global size (rows) of this vector  
            * `blockSize` :  
                size for each block (one process might receive multiple blocks)  

        * `DataVectorDistributed(grid, globalSize, blockSize, value=0.0)`  

            Creates a distributed data vector of specified size and initializes the
            elements to value.  

            Parameters:  
            * `grid` :  
                blacs grid for distribution  
            * `globalSize` :  
                global size (rows) of this vector  
            * `blockSize` :  
                size for each block (one process might receive multiple blocks)  
            * `value` :  
                Initial value of all elements, default 0.0  

        """
        _pysgpp_swig.DataVectorDistributed_swiginit(self, _pysgpp_swig.new_DataVectorDistributed(*args))

    def get(self, row: "size_t") -> "double":
        r"""


        Returns the value of the element at position [row].  

        Parameters
        ----------
        * `row` :  
            Row  

        Returns
        -------
        Value of the element  

        """
        return _pysgpp_swig.DataVectorDistributed_get(self, row)

    def set(self, row: "size_t", value: "double") -> "void":
        r"""


        Sets the element at global position [row] to value.  

        Parameters
        ----------
        * `row` :  
            Global row  
        * `value` :  
            New value for element  

        """
        return _pysgpp_swig.DataVectorDistributed_set(self, row, value)

    def setAll(self, value: "double") -> "void":
        r"""


        Set all entries of the vector to one value.  

        Parameters
        ----------
        * `value` :  

        """
        return _pysgpp_swig.DataVectorDistributed_setAll(self, value)

    def copyFrom(self, other: "DataVectorDistributed") -> "void":
        r"""


        Copies all values of another distributed data matrix to this object, resizes
        this object to the size of the other matrix.  

        """
        return _pysgpp_swig.DataVectorDistributed_copyFrom(self, other)

    @staticmethod
    def add(*args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `add(x)`  

            Adds another vector to this vector, modifies this vector.  

            Parameters:  
            * `x` :  
                vector that is added to this vector  

        * `add(y, x, a=1.0)`  

            Performs the following operation sub(y) := sub(y) + a*sub(x)  

            Parameters:  
            * `y` :  
            * `x` :  
            * `a` :  
                factor for x, default 1.0  

        """
        return _pysgpp_swig.DataVectorDistributed_add(*args)

    @staticmethod
    def dot(*args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `dot(y) -> double`  

            Parameters:  
            * `y` :  

            Returns:
            the dot product of this vector transposed and y  

        * `dot(x, y) -> double`  

            Parameters:  
            * `x` :  
            * `y` :  

            Returns:
            dot = sub(x)'*sub(y); vector x is transposed  

        """
        return _pysgpp_swig.DataVectorDistributed_dot(*args)

    def scale(self, a: "double") -> "void":
        r"""


        Scales this vector by factor a.  

        Parameters
        ----------
        * `a` :  

        """
        return _pysgpp_swig.DataVectorDistributed_scale(self, a)

    def resize(self, rows: "size_t") -> "void":
        r"""


        Resizes the vector to rows, discards the data.  

        Parameters
        ----------
        * `rows` :  

        """
        return _pysgpp_swig.DataVectorDistributed_resize(self, rows)

    def getLocalPointer(self, *args) -> "double const *":
        r"""


        Overloaded function
        -------------------
        * `getLocalPointer() -> double *`  

            Returns:
            pointer to the local data of this process  

        * `getLocalPointer() -> const double *`  

            Returns:
            const pointer to the local data of this process  

        """
        return _pysgpp_swig.DataVectorDistributed_getLocalPointer(self, *args)

    def getProcessGrid(self) -> "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >":
        r"""


        Returns
        -------
        process grid used by the vector.  

        """
        return _pysgpp_swig.DataVectorDistributed_getProcessGrid(self)

    def toLocalDataVector(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `toLocalDataVector() -> DataVector`  

            Returns:
            the gathered DataVector on process 0  

        * `toLocalDataVector(localVector)`  

            Parameters:  
            * `localVector` :  
                the gathered DataVector on process (0, 0)  

        """
        return _pysgpp_swig.DataVectorDistributed_toLocalDataVector(self, *args)

    def toLocalDataVectorBroadcast(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `toLocalDataVectorBroadcast() -> DataVector`  

            Returns:
            the broadcasted DataVector on all processes  

        * `toLocalDataVectorBroadcast(localVector)`  

            Parameters:  
            * `localVector` :  
                the broadcaster DataVector on all processes  

        """
        return _pysgpp_swig.DataVectorDistributed_toLocalDataVectorBroadcast(self, *args)

    def getDescriptor(self, *args) -> "int const *":
        r"""


        Overloaded function
        -------------------
        * `getDescriptor() -> int *`  

            Returns:
            pointer to the descriptor array for the underlying data matrix  

        * `getDescriptor() -> const int *`  

            Returns:
            const pointer to the descriptor array for the underlying data matrix  

        """
        return _pysgpp_swig.DataVectorDistributed_getDescriptor(self, *args)

    def getGlobalRows(self) -> "size_t":
        r"""


        Returns the number of rows of the DataMatrix.  

        Returns
        -------
        Number of rows  

        """
        return _pysgpp_swig.DataVectorDistributed_getGlobalRows(self)

    def getLocalRows(self) -> "size_t":
        r"""


        Returns
        -------
        number of rows assigned to the current process  

        """
        return _pysgpp_swig.DataVectorDistributed_getLocalRows(self)

    def getBlockSize(self) -> "size_t":
        r"""


        Returns
        -------
        the block size  

        """
        return _pysgpp_swig.DataVectorDistributed_getBlockSize(self)

    def printVector(self) -> "void":
        r"""


        Prints the vector on stdout on process 0.  

        """
        return _pysgpp_swig.DataVectorDistributed_printVector(self)

    def isProcessMapped(self) -> "bool":
        r"""


        Returns
        -------
        true if part of the vector is mapped to the current process, false otherwise  

        """
        return _pysgpp_swig.DataVectorDistributed_isProcessMapped(self)

    def getMatrix(self, *args) -> "sgpp::datadriven::DataMatrixDistributed const &":
        r"""


        Overloaded function
        -------------------
        * `getMatrix() -> DataMatrixDistributed &`  

            Returns:
            reference to the underlying DataMatrixDistributed object.  

        * `getMatrix() -> const DataMatrixDistributed &`  

            Returns:
            const ref to the underlying DataMatrixDistributed object.  

        """
        return _pysgpp_swig.DataVectorDistributed_getMatrix(self, *args)

    def distribute(self, input: "double *", masterRow: "int"=0, masterCol: "int"=0) -> "void":
        r"""


        Distribute the input data to the process grid.  

        Overwrites the current data. For more information, see
        DataMatrixDistributed::distribute  

        Parameters
        ----------
        * `input` :  
            input data  
        * `masterRow` :  
            row of the process that distributes the data  
        * `masterCol` :  
            col of the process that distributes the data  

        """
        return _pysgpp_swig.DataVectorDistributed_distribute(self, input, masterRow, masterCol)

    def globalToLocalRowIndex(self, globalRowIndex: "size_t") -> "size_t":
        r"""


        Calculates the local row index from the globalRowIndex.  

        Parameters
        ----------
        * `globalRowIndex` :  

        """
        return _pysgpp_swig.DataVectorDistributed_globalToLocalRowIndex(self, globalRowIndex)

    def localToGlobalRowIndex(self, localRowIndex: "size_t") -> "size_t":
        r"""


        Calculates the global row index from the local row index.  

        Parameters
        ----------
        * `localRowIndex` :  

        """
        return _pysgpp_swig.DataVectorDistributed_localToGlobalRowIndex(self, localRowIndex)

    def globalToRowProcessIndex(self, globalRowIndex: "size_t") -> "size_t":
        r"""


        Calculates the row process index from the global row index.  

        Parameters
        ----------
        * `globalRowIndex` :  

        """
        return _pysgpp_swig.DataVectorDistributed_globalToRowProcessIndex(self, globalRowIndex)
    __swig_destroy__ = _pysgpp_swig.delete_DataVectorDistributed

# Register DataVectorDistributed in _pysgpp_swig:
_pysgpp_swig.DataVectorDistributed_swigregister(DataVectorDistributed)

def DataVectorDistributed_add(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `add(x)`  

        Adds another vector to this vector, modifies this vector.  

        Parameters:  
        * `x` :  
            vector that is added to this vector  

    * `add(y, x, a=1.0)`  

        Performs the following operation sub(y) := sub(y) + a*sub(x)  

        Parameters:  
        * `y` :  
        * `x` :  
        * `a` :  
            factor for x, default 1.0  

    """
    return _pysgpp_swig.DataVectorDistributed_add(*args)

def DataVectorDistributed_dot(*args) -> "double":
    r"""


    Overloaded function
    -------------------
    * `dot(y) -> double`  

        Parameters:  
        * `y` :  

        Returns:
        the dot product of this vector transposed and y  

    * `dot(x, y) -> double`  

        Parameters:  
        * `x` :  
        * `y` :  

        Returns:
        dot = sub(x)'*sub(y); vector x is transposed  

    """
    return _pysgpp_swig.DataVectorDistributed_dot(*args)

class VectorHash(object):
    r"""


    Hash to make an unordered_set over an vector of size_t's possible.  

    C++ includes: CombiScheme.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pysgpp_swig.VectorHash_swiginit(self, _pysgpp_swig.new_VectorHash())
    __swig_destroy__ = _pysgpp_swig.delete_VectorHash

# Register VectorHash in _pysgpp_swig:
_pysgpp_swig.VectorHash_swigregister(VectorHash)

class CombiScheme(object):
    r"""

    `CombiScheme()`  

    Constructors
    ------------
    * `CombiScheme()`  

        Empty Constructor.  

    C++ includes: CombiScheme.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Empty Constructor.  

        """
        _pysgpp_swig.CombiScheme_swiginit(self, _pysgpp_swig.new_CombiScheme())

    def initialize(self, dim: "size_t", level: "size_t") -> "void":
        r"""


        Initialize the combigrid scheme.  

        Parameters
        ----------
        * `dim` :  
            dimension  
        * `level` :  
            level  

        """
        return _pysgpp_swig.CombiScheme_initialize(self, dim, level)

    def isRefinable(self, levelvec: "SizeVector") -> "bool":
        r"""


        check if the component of levelvec is refinable  

        Parameters
        ----------
        * `levelvec` :  
            vector for the component in question  

        Returns
        -------
        whether we can refine the scheme  

        """
        return _pysgpp_swig.CombiScheme_isRefinable(self, levelvec)

    def refineComponent(self, levelvec: "SizeVector") -> "bool":
        r"""


        update the scheme by component of levelvec  

        Parameters
        ----------
        * `levelvec` :  
            vector for the component in question  

        Returns
        -------
        whether the scheme was refined  

        """
        return _pysgpp_swig.CombiScheme_refineComponent(self, levelvec)

    def getCombiScheme(self) -> "std::vector< std::pair< std::vector< size_t,std::allocator< size_t > >,int >,std::allocator< std::pair< std::vector< size_t,std::allocator< size_t > >,int > > >":
        r"""


        return the combigrid scheme (levelvectors of the components and their
        coefficients)  

        Returns
        -------
        levelvectors of the components and their corresponding coefficients  

        """
        return _pysgpp_swig.CombiScheme_getCombiScheme(self)
    __swig_destroy__ = _pysgpp_swig.delete_CombiScheme

# Register CombiScheme in _pysgpp_swig:
_pysgpp_swig.CombiScheme_swigregister(CombiScheme)

class DBMatDecompMatrixSolver(SGSolver):
    r"""

    `DBMatDecompMatrixSolver()`  

    Constructors
    ------------
    * `DBMatDecompMatrixSolver()`  

    C++ includes: DBMatDecompMatrixSolver.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        """
        _pysgpp_swig.DBMatDecompMatrixSolver_swiginit(self, _pysgpp_swig.new_DBMatDecompMatrixSolver())
    __swig_destroy__ = _pysgpp_swig.delete_DBMatDecompMatrixSolver

# Register DBMatDecompMatrixSolver in _pysgpp_swig:
_pysgpp_swig.DBMatDecompMatrixSolver_swigregister(DBMatDecompMatrixSolver)

class DBMatDMSChol(DBMatDecompMatrixSolver):
    r"""

    `DBMatDMSChol()`  

    Class to solve the system of equations with a LL'-decomposed matrix.  

    Constructors
    ------------
    * `DBMatDMSChol()`  

        Default constructor.  

    C++ includes: DBMatDMSChol.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.DBMatDMSChol_swiginit(self, _pysgpp_swig.new_DBMatDMSChol())

    def solve(self, decompMatrix: "DataMatrix", alpha: "DataVector", b: "DataVector", lambda_old: "double", lambda_new: "double") -> "void":
        r"""


        Solves a system of equations.  

        Parameters
        ----------
        * `decompMatrix` :  
            the LL' lower triangular cholesky factor  
        * `alpha` :  
            the vector of unknowns (the result is stored there)  
        * `b` :  
            the right hand vector of the equation system  
        * `lambda_old` :  
            the current regularization paramter  
        * `lambda_new` :  
            the new regularization paramter (e.g. if cross-validation is applied)  

        """
        return _pysgpp_swig.DBMatDMSChol_solve(self, decompMatrix, alpha, b, lambda_old, lambda_new)

    def solveParallel(self, decompMatrix: "DataMatrixDistributed", x: "DataVectorDistributed", lambda_old: "double", lambda_new: "double") -> "void":
        r"""


        Parallel (distributed) version of solve.  

        Parameters
        ----------
        * `decompMatrix` :  
            the LL' lower triangular cholesky factor  
        * `x` :  
            input: the right hand vector of the equation system, output: the vector of
            unknowns (the result is stored there)  
        * `lambda_old` :  
            the current regularization paramter  
        * `lambda_new` :  
            the new regularization paramter (e.g. if cross-validation is applied)  

        """
        return _pysgpp_swig.DBMatDMSChol_solveParallel(self, decompMatrix, x, lambda_old, lambda_new)

    def choleskyUpdate(self, decompMatrix: "DataMatrix", update: "DataVector", do_cv: "bool"=False) -> "void":
        r"""


        Performe a rank one cholesky update.  

        Parameters
        ----------
        * `decompMatrix` :  
            the LL' lower triangular cholesky factor  
        * `update` :  
            the vector representing the rank one matrix (xx')  
        * `do_cv` :  
            indicating if updates are used for cross valdiation (using special structure
            of update vectors to save runtime)  

        """
        return _pysgpp_swig.DBMatDMSChol_choleskyUpdate(self, decompMatrix, update, do_cv)

    def choleskyDowndate(self, decompMatrix: "DataMatrix", downdate: "DataVector", do_cv: "bool"=False) -> "void":
        r"""


        Performe a rank one cholesky downdate.  

        Parameters
        ----------
        * `decompMatrix` :  
            the LL' lower triangular cholesky factor  
        * `downdate` :  
            the vector representing the rank one matrix (xx')  
        * `do_cv` :  
            indicating if updates are used for cross valdiation (using special structure
            of update vectors to save runtime)  

        """
        return _pysgpp_swig.DBMatDMSChol_choleskyDowndate(self, decompMatrix, downdate, do_cv)
    __swig_destroy__ = _pysgpp_swig.delete_DBMatDMSChol

# Register DBMatDMSChol in _pysgpp_swig:
_pysgpp_swig.DBMatDMSChol_swigregister(DBMatDMSChol)

class DBMatDMSDenseIChol(DBMatDMSChol):
    r"""

    `DBMatDMSDenseIChol(densityEstimationConfig, grid, lambda, doCV)`  

    Solve the system of equations with a LL'-decomposed matrix where LL' is created
    by an iterative, incomplete cholesky factorization on a dense matrix.  

    Constructors
    ------------
    * `DBMatDMSDenseIChol(densityEstimationConfig, grid, lambda, doCV)`  

    C++ includes: DBMatDMSDenseIChol.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, densityEstimationConfig: "DensityEstimationConfiguration", grid: "Grid", _lambda: "double", doCV: "bool"):
        r"""


        """
        _pysgpp_swig.DBMatDMSDenseIChol_swiginit(self, _pysgpp_swig.new_DBMatDMSDenseIChol(densityEstimationConfig, grid, _lambda, doCV))
    __swig_destroy__ = _pysgpp_swig.delete_DBMatDMSDenseIChol

# Register DBMatDMSDenseIChol in _pysgpp_swig:
_pysgpp_swig.DBMatDMSDenseIChol_swigregister(DBMatDMSDenseIChol)

class DBMatOffline(object):
    r"""

    `DBMatOffline(rhs)`  
    `DBMatOffline(fileName)`  
    `DBMatOffline(rhs)`  

    Class that is used to decompose and store the left-hand-side matrix for the
    density based classification approach (The classification is divided into two
    parts: the offline step that does not depend on the actual data and the online
    step that depends on the data).  

    Uses Gnu Scientific Library (GSL).  

    Constructors
    ------------
    * `DBMatOffline(rhs)`  

        Copy Constructor.  

        Parameters:  
        * `rhs` :  
            Object to copy  

    * `DBMatOffline(fileName)`  

        Constructor Create offline object from serialized offline object.  

        Parameters:  
        * `fileName` :  
            path to the file that stores serialized offline object  

    * `DBMatOffline(rhs)`  

        Default move constructor.  

    C++ includes: DBMatOffline.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_DBMatOffline

    def clone(self) -> "sgpp::datadriven::DBMatOffline *":
        r"""


        Interface for the clone idiom.  

        Returns
        -------
        a copy of this very object as a pointer to a new DBMatOffline object which is
        owned by the caller.  

        """
        return _pysgpp_swig.DBMatOffline_clone(self)

    def isRefineable(self) -> "bool":
        r"""


        Only Offline objects based on Cholesky decomposition, or orthogonal adaptivity
        can be refined.  

        Returns
        -------
        true if object can be refined, else false;  

        """
        return _pysgpp_swig.DBMatOffline_isRefineable(self)

    def getDecomposedMatrix(self) -> "sgpp::datadriven::DataMatrix &":
        r"""


        Get a reference to the decomposed matrix.  

        Throws if matrix has not yet been decomposed.  

        Returns
        -------
        decomposed matrix  

        """
        return _pysgpp_swig.DBMatOffline_getDecomposedMatrix(self)

    def getUnmodifiedR(self) -> "sgpp::datadriven::DataMatrix const &":
        r"""


        Get the unmodified (without added lambda) system matrix R.  

        Returns
        -------
        Matrix R  

        """
        return _pysgpp_swig.DBMatOffline_getUnmodifiedR(self)

    def getUnmodifiedRDistributed(self, processGrid: "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >", parallelConfig: "ParallelConfiguration") -> "sgpp::datadriven::DataMatrixDistributed const &":
        r"""


        Get the distributed version of the unmodified (without added lambda) system
        matrix R.  

        Only possible in the ScaLAPACK version.  

        Parameters
        ----------
        * `processGrid` :  
            BLACS process grid  
        * `parallelConfig` :  
            config options for ScaLAPACK  

        Returns
        -------
        Matrix R  

        """
        return _pysgpp_swig.DBMatOffline_getUnmodifiedRDistributed(self, processGrid, parallelConfig)

    def updateRegularization(self, _lambda: "double") -> "void":
        r"""


        Modifies the decomposition to update the regularization parameter lambda.  

        Parameters
        ----------
        * `lambda` :  
            New lambda value  

        """
        return _pysgpp_swig.DBMatOffline_updateRegularization(self, _lambda)

    def updateRegularizationParallel(self, _lambda: "double", processGrid: "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >", parallelConfig: "ParallelConfiguration") -> "void":
        r"""


        Modifies the parallel decomposition to update the regularization parameter
        lambda.  

        Parameters
        ----------
        * `lambda` :  
            New lambda value  
        * `processGrid` :  
            ScaLAPACK process grid  
        * `parallelConfig` :  
            Configuration for ScaLAPACK  

        """
        return _pysgpp_swig.DBMatOffline_updateRegularizationParallel(self, _lambda, processGrid, parallelConfig)

    def getInverseMatrix(self) -> "sgpp::datadriven::DataMatrix &":
        r"""


        Get a reference to the inverse matrix.  

        Returns
        -------
        inverse matrix  

        """
        return _pysgpp_swig.DBMatOffline_getInverseMatrix(self)

    def getDecomposedMatrixDistributed(self) -> "sgpp::datadriven::DataMatrixDistributed &":
        r"""


        Get a reference to the distributed decomposed matrix.  

        Throws if matrix has not yet been decomposed. In order to return valid data,
        syncDistributedDecomposition() has to be called if the decomposition was changed
        (after refinements).  

        """
        return _pysgpp_swig.DBMatOffline_getDecomposedMatrixDistributed(self)

    def getDecomposedInverseDistributed(self) -> "sgpp::datadriven::DataMatrixDistributed &":
        r"""


        Get a reference to the distributed decomposed matrix, analogously to
        getDecomposedMatrixDistributed()  

        """
        return _pysgpp_swig.DBMatOffline_getDecomposedInverseDistributed(self)

    def syncDistributedDecomposition(self, processGrid: "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >", parallelConfig: "ParallelConfiguration") -> "void":
        r"""


        Synchronizes the decomposed matrix.  

        Override if more matrices have to be synched.  

        Parameters
        ----------
        * `processGrid` :  
            process grid to distribute the matrix on  
        * `parallelConfig` :  

        """
        return _pysgpp_swig.DBMatOffline_syncDistributedDecomposition(self, processGrid, parallelConfig)

    def syncDistributedInverse(self, processGrid: "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >", parallelConfig: "ParallelConfiguration") -> "void":
        r"""


        Synchronizes the inverse matrix.  

        Parameters
        ----------
        * `processGrid` :  
            process grid to distribute the matrix on  
        * `parallelConfig` :  

        """
        return _pysgpp_swig.DBMatOffline_syncDistributedInverse(self, processGrid, parallelConfig)

    def getLhsMatrix_ONLY_FOR_TESTING(self) -> "sgpp::datadriven::DataMatrix &":
        r"""


        Allows access to lhs matrix, which is meant ONLY FOR TESTING.  

        """
        return _pysgpp_swig.DBMatOffline_getLhsMatrix_ONLY_FOR_TESTING(self)

    def buildMatrix(self, grid: "Grid", regularizationConfig: "RegularizationConfiguration") -> "void":
        r"""


        Builds the right hand side matrix with or without the regularization term
        depending on the type of decomposition.  

        Parameters
        ----------
        * `grid` :  
            The grid object the matrix is based on  
        * `regularizationConfig` :  
            Configures the regularization which is incorporated into the lhs  

        """
        return _pysgpp_swig.DBMatOffline_buildMatrix(self, grid, regularizationConfig)

    def decomposeMatrix(self, regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration") -> "void":
        r"""


        Decomposes the matrix according to the chosen decomposition type.  

        The number of rows of the stored result depends on the decomposition type.  

        Parameters
        ----------
        * `regularizationConfig` :  
            the regularization configuration  
        * `densityEstimationConfig` :  
            the density estimation configuration  

        """
        return _pysgpp_swig.DBMatOffline_decomposeMatrix(self, regularizationConfig, densityEstimationConfig)

    def decomposeMatrixParallel(self, regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration", processGrid: "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >", parallelConfig: "ParallelConfiguration") -> "void":
        r"""


        The parallel/distributed version of decomposeMatrix(...)  

        Parameters
        ----------
        * `regularizationConfig` :  
            the regularization configuration  
        * `densityEstimationConfig` :  
            the density estimation configuration  
        * `processGrid` :  
            process grid to distribute the matrix on  
        * `parallelConfig` :  

        """
        return _pysgpp_swig.DBMatOffline_decomposeMatrixParallel(self, regularizationConfig, densityEstimationConfig, processGrid, parallelConfig)

    def printMatrix(self) -> "void":
        r"""


        Prints the matrix onto standard output.  

        """
        return _pysgpp_swig.DBMatOffline_printMatrix(self)

    def compute_L2_refine_vectors(self, mat_refine: "DataMatrix", grid: "Grid", newPoints: "size_t") -> "void":
        r"""


        computes vectors of L2 products of grid points for refinement  

        Parameters
        ----------
        * `mat_refine` :  
            matrix to store L2 vectors  
        * `grid` :  
            underlying grid  
        * `newPoints` :  
            amount of points to refine  

        """
        return _pysgpp_swig.DBMatOffline_compute_L2_refine_vectors(self, mat_refine, grid, newPoints)

    def compute_inverse(self) -> "void":
        r"""


        """
        return _pysgpp_swig.DBMatOffline_compute_inverse(self)

    def compute_inverse_parallel(self, processGrid: "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >", parallelConfig: "ParallelConfiguration") -> "void":
        r"""


        parallel/distributed version of compute_inverse()  

        Parameters
        ----------
        * `processGrid` :  
            process grid to distribute the matrix on  
        * `parallelConfig` :  

        """
        return _pysgpp_swig.DBMatOffline_compute_inverse_parallel(self, processGrid, parallelConfig)

    def store(self, fileName: "std::string const &") -> "void":
        r"""


        Serialize the DBMatOffline Object.  

        Parameters
        ----------
        * `fileName` :  
            path where to store the file.  

        """
        return _pysgpp_swig.DBMatOffline_store(self, fileName)

    def getGridSize(self) -> "size_t":
        r"""


        Returns the dimensionality of the quadratic lhs matrix (i.e.  

        the number of rows)  

        Returns
        -------
        the grid size  

        """
        return _pysgpp_swig.DBMatOffline_getGridSize(self)

    def getDecompositionType(self) -> "sgpp::datadriven::MatrixDecompositionType":
        r"""


        Returns the decomposition type of the DBMatOffline object.  

        Returns
        -------
        the type of matrix decomposition  

        """
        return _pysgpp_swig.DBMatOffline_getDecompositionType(self)
    interactions = property(_pysgpp_swig.DBMatOffline_interactions_get, _pysgpp_swig.DBMatOffline_interactions_set)

# Register DBMatOffline in _pysgpp_swig:
_pysgpp_swig.DBMatOffline_swigregister(DBMatOffline)

class DBMatOfflineGE(DBMatOffline):
    r"""

    `DBMatOfflineGE(fileName)`  

    DBMatOffline specialization as a base class for all algorithms based on gaussian
    elimination on a dense matrix.  

    Constructors
    ------------
    * `DBMatOfflineGE(fileName)`  

    C++ includes: DBMatOfflineGE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_DBMatOfflineGE

# Register DBMatOfflineGE in _pysgpp_swig:
_pysgpp_swig.DBMatOfflineGE_swigregister(DBMatOfflineGE)

class DBMatOfflineChol(DBMatOfflineGE):
    r"""

    `DBMatOfflineChol()`  
    `DBMatOfflineChol(fileName)`  

    DBMatOffline specialization that uses a cholesky factorization on a dense
    matrix.  

    The resulting factorization can be updated when the grid changes.  

    Constructors
    ------------
    * `DBMatOfflineChol()`  

    * `DBMatOfflineChol(fileName)`  

    C++ includes: DBMatOfflineChol.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DBMatOfflineChol()`  

        * `DBMatOfflineChol(fileName)`  

        """
        _pysgpp_swig.DBMatOfflineChol_swiginit(self, _pysgpp_swig.new_DBMatOfflineChol(*args))

    def choleskyModification(self, grid: "Grid", densityEstimationConfig: "DensityEstimationConfiguration", newPoints: "size_t", deletedPoints: "SizeVector", _lambda: "double") -> "void":
        r"""


        Updates offline cholesky factorization based on coarsed (deletedPoints) and
        refined (newPoints) gridPoints.  

        Parameters
        ----------
        * `grid` :  
            the underlying grid  
        * `densityEstimationConfig` :  
            configuration for the density estimation  
        * `newPoints` :  
            amount of refined points  
        * `deletedPoints` :  
            list of indices of last coarsed points  
        * `lambda` :  
            the regularization parameter  

        """
        return _pysgpp_swig.DBMatOfflineChol_choleskyModification(self, grid, densityEstimationConfig, newPoints, deletedPoints, _lambda)
    __swig_destroy__ = _pysgpp_swig.delete_DBMatOfflineChol

# Register DBMatOfflineChol in _pysgpp_swig:
_pysgpp_swig.DBMatOfflineChol_swigregister(DBMatOfflineChol)

class DBMatOfflineDenseIChol(DBMatOfflineChol):
    r"""

    `DBMatOfflineDenseIChol()`  
    `DBMatOfflineDenseIChol(fileName)`  

    DBMatOfflineChol specialization that uses a parallel, iterative incomplete
    cholesky factorization on a dense matrix.  

    The current implementation is a proof of concept.  

    Constructors
    ------------
    * `DBMatOfflineDenseIChol()`  

    * `DBMatOfflineDenseIChol(fileName)`  

    C++ includes: DBMatOfflineDenseIChol.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DBMatOfflineDenseIChol()`  

        * `DBMatOfflineDenseIChol(fileName)`  

        """
        _pysgpp_swig.DBMatOfflineDenseIChol_swiginit(self, _pysgpp_swig.new_DBMatOfflineDenseIChol(*args))

    @staticmethod
    def ichol(matrix: "DataMatrix", result: "DataMatrix", sweeps: "size_t"=4, startRow: "size_t"=0) -> "void":
        r"""


        perform parlallel incomplete cholesky factorization of a matrix.  

        This is an out of place operation.  

        Parameters
        ----------
        * `matrix` :  
            the matrix to be decomposed  
        * `result` :  
            data matrix that will hold the decomposed matrix  
        * `sweeps` :  
            how many iterations of the algorithm are required until the result is good
            enough?  
        * `startRow` :  
            on which row to start the decomposition (needed for refinement)  

        """
        return _pysgpp_swig.DBMatOfflineDenseIChol_ichol(matrix, result, sweeps, startRow)
    __swig_destroy__ = _pysgpp_swig.delete_DBMatOfflineDenseIChol

# Register DBMatOfflineDenseIChol in _pysgpp_swig:
_pysgpp_swig.DBMatOfflineDenseIChol_swigregister(DBMatOfflineDenseIChol)

def DBMatOfflineDenseIChol_ichol(matrix: "DataMatrix", result: "DataMatrix", sweeps: "size_t"=4, startRow: "size_t"=0) -> "void":
    r"""


    perform parlallel incomplete cholesky factorization of a matrix.  

    This is an out of place operation.  

    Parameters
    ----------
    * `matrix` :  
        the matrix to be decomposed  
    * `result` :  
        data matrix that will hold the decomposed matrix  
    * `sweeps` :  
        how many iterations of the algorithm are required until the result is good
        enough?  
    * `startRow` :  
        on which row to start the decomposition (needed for refinement)  

    """
    return _pysgpp_swig.DBMatOfflineDenseIChol_ichol(matrix, result, sweeps, startRow)


def deleteOnesFromLevelVec(vectorWithOnes: "SizeVector") -> "std::vector< size_t,std::allocator< size_t > >":
    r"""


    Removes all elements equal to 1 from a vector and returns the obtained vector.  

    Parameters
    ----------
    * `vectorWithOnes` :  
        The input vector.  

    Returns
    -------
    std::vector<size_t>  

    """
    return _pysgpp_swig.deleteOnesFromLevelVec(vectorWithOnes)

def getNormalizedConfig(gridConfig: "sgpp::base::GeneralGridConfiguration") -> "sgpp::base::GeneralGridConfiguration":
    r"""


    Returns a grid configuration with level vector without elements equal to 1 and
    adjusted dimension.  

    Parameters
    ----------
    * `gridConfig` :  
        Grid condiguration to normalize.  

    Returns
    -------
    sgpp::base::GeneralGridConfiguration  

    """
    return _pysgpp_swig.getNormalizedConfig(gridConfig)

def isPermutation(vec1: "SizeVector", vec2: "SizeVector") -> "bool":
    r"""


    Cecks whether vec1 is permutation of vec2.  

    Parameters
    ----------
    * `vec1` :  
        First input vector.  
    * `vec2` :  
        Second input vector.  

    Returns
    -------
    true  

    Returns
    -------
    false  

    """
    return _pysgpp_swig.isPermutation(vec1, vec2)
class DBMatOfflinePermutable(DBMatOffline):
    r"""

    `DBMatOfflinePermutable(fileName)`  

    Constructors
    ------------
    * `DBMatOfflinePermutable(fileName)`  

    C++ includes: DBMatOfflinePermutable.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def permuteLhsMatrix(self, baseGridConfig: "sgpp::base::GeneralGridConfiguration const &", desiredGridConfig: "sgpp::base::GeneralGridConfiguration const &") -> "void":
        r"""


        Applies permutation and blow-up approach to undecomposed left-hand side matrix.  

        Meant to be used for testing primarily.  

        Parameters
        ----------
        * `baseGridConfig` :  
        * `desiredGridConfig` :  

        """
        return _pysgpp_swig.DBMatOfflinePermutable_permuteLhsMatrix(self, baseGridConfig, desiredGridConfig)

    def permuteDecomposition(self, baseGridConfig: "sgpp::base::GeneralGridConfiguration const &", desiredGridConfig: "sgpp::base::GeneralGridConfiguration const &") -> "void":
        r"""


        Applies the permutation and blow-up approach to the decomposition to match the
        desired grid configuration.  

        Parameters
        ----------
        * `baseGridConfig` :  
            Grid configuration of the current state of the offline object.  
        * `desiredGridConfig` :  
            Grid configuration of the desired offline object.  

        """
        return _pysgpp_swig.DBMatOfflinePermutable_permuteDecomposition(self, baseGridConfig, desiredGridConfig)
    __swig_destroy__ = _pysgpp_swig.delete_DBMatOfflinePermutable

# Register DBMatOfflinePermutable in _pysgpp_swig:
_pysgpp_swig.DBMatOfflinePermutable_swigregister(DBMatOfflinePermutable)
DBMatOfflinePermutable.PermutableDecompositions = _pysgpp_swig.cvar.DBMatOfflinePermutable_PermutableDecompositions

class DBMatOnline(object):
    r"""

    `DBMatOnline(rhs)`  
    `DBMatOnline(o)`  
    `DBMatOnline(rhs)`  

    Class for objects that can be used in the online step of the classification (The
    classification is divided into two parts: the offline step that does not depend
    on the actual data and the online step that depends on the data)  

    Constructors
    ------------
    * `DBMatOnline(rhs)`  

    * `DBMatOnline(o)`  

        Constructor.  

        Parameters:  
        * `o` :  
            a offline object  

    * `DBMatOnline(rhs)`  

    C++ includes: DBMatOnline.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DBMatOnline(rhs)`  

        * `DBMatOnline(o)`  

            Constructor.  

            Parameters:  
            * `o` :  
                a offline object  

        * `DBMatOnline(rhs)`  

        """
        _pysgpp_swig.DBMatOnline_swiginit(self, _pysgpp_swig.new_DBMatOnline(*args))
    __swig_destroy__ = _pysgpp_swig.delete_DBMatOnline

    def setLambda(self, _lambda: "double") -> "void":
        r"""


        switch (offlineObject.getDensityEstimationConfig().decomposition_) { case
        MatrixDecompositionType::Eigen: case MatrixDecompositionType::Chol: case
        MatrixDecompositionType::DenseIchol: case MatrixDecompositionType::OrthoAdapt:
        offlineObject.getRegularizationConfig().lambda_ = lambda; break; case
        MatrixDecompositionType::LU: default: throw application_exception( "Lambda can
        not be changed in the online step for this decomposition " "type!"); }  

        """
        return _pysgpp_swig.DBMatOnline_setLambda(self, _lambda)

    def getOfflineObject(self, *args) -> "sgpp::datadriven::DBMatOffline const &":
        r"""


        Overloaded function
        -------------------
        * `getOfflineObject() -> DBMatOffline &`  

            Returns a reference to the offline object.  

            Returns:
            reference to the stored offline object  

        * `getOfflineObject() -> const DBMatOffline &`  

        """
        return _pysgpp_swig.DBMatOnline_getOfflineObject(self, *args)

    def updateSystemMatrixDecomposition(self, densityEstimationConfig: "DensityEstimationConfiguration", grid: "Grid", numAddedGridPoints: "size_t", deletedGridPointIndices: "SizeVector", _lambda: "double") -> "std::vector< size_t,std::allocator< size_t > >":
        r"""


        Update the system matrix decomposition after the grid has been modified.  

        Parameters
        ----------
        * `densityEstimationConfig` :  
            configuration of the density estimation  
        * `grid` :  
            the underlying grid  
        * `numAddedGridPoints` :  
            Number of grid points inserted at the end of the grid storage  
        * `deletedGridPointIndices` :  
            Indices of grid points that were deleted  
        * `lambda` :  
            The last best lambda value  

        Returns
        -------
        list of grid points, that cannot be coarsened  

        """
        return _pysgpp_swig.DBMatOnline_updateSystemMatrixDecomposition(self, densityEstimationConfig, grid, numAddedGridPoints, deletedGridPointIndices, _lambda)

# Register DBMatOnline in _pysgpp_swig:
_pysgpp_swig.DBMatOnline_swigregister(DBMatOnline)

class DBMatOnlineDE(DBMatOnline):
    r"""

    `DBMatOnlineDE(offline, grid, lambda, beta=0.)`  

    Class that stores, generates and manipulates a density function during online
    phase in on/off learning.  

    Constructors
    ------------
    * `DBMatOnlineDE(offline, grid, lambda, beta=0.)`  

        Constructor.  

        Parameters:  
        * `offline` :  
            The offline object we base our evaluations on.  
        * `grid` :  
            The underlying grid (TODO(fuchsgruber) do we need this?)  
        * `lambda` :  
            The regularization strength (TODO(fuchsgruber) remove this)  
        * `beta` :  
            The initial weighting factor  

    C++ includes: DBMatOnlineDE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def updateRhs(self, gridSize: "size_t", deletedPoints: "SizeVector") -> "void":
        r"""


        Restructures the rhs (b vector) of the system matrix.  

        This is only availible for streaming, i.e. when computeDensityFunction was
        called with save_b = true. First b is coarsened, then extended according to the
        new grid size (refinement).  

        Parameters
        ----------
        * `gridSize` :  
            grid size after coarsening and refinement (inherently gives the number of
            points added during refinement after coarsening)  
        * `deletedPoints` :  
            pointer to list of indexes that will be removed from b  

        """
        return _pysgpp_swig.DBMatOnlineDE_updateRhs(self, gridSize, deletedPoints)

    def computeDensityFunction(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `computeDensityFunction(alpha, m, grid, densityEstimationConfig, save_b=false,
            do_cv=false)`  

            Computes the density function for a certain data matrix.  

            Parameters:  
            * `alpha` :  
                the vector where surplusses for the density function will be stored  
            * `m` :  
                the matrix that contains the data points  
            * `grid` :  
                The underlying grid  
            * `densityEstimationConfig` :  
                Configuration for the density estimation  
            * `save_b` :  
                Indicates whether the old right hand side should be saved and combined
                with the new right hand side (aka streaming)  
            * `do_cv` :  
                Indicates whether crossvalidation should take place  

        * `computeDensityFunction(alpha, grid, densityEstimationConfig, do_cv=false)`  

            Computes the density function again based on the saved b's (only applicable
            for streaming)  

            Parameters:  
            * `alpha` :  
                the vector where surplusses for the density function will be stored  
            * `grid` :  
                The underlying grid  
            * `densityEstimationConfig` :  
                Configuration for the density estimation combined with the new right
                hand side (aka streaming)  
            * `do_cv` :  
                Indicates whether crossvalidation should take place  

        """
        return _pysgpp_swig.DBMatOnlineDE_computeDensityFunction(self, *args)

    def computeDensityFunctionParallel(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `computeDensityFunctionParallel(alpha, m, grid, densityEstimationConfig,
            parallelConfig, processGrid, save_b=false, do_cv=false,
            deletedPoints=nullptr, newPoints=0)`  

            Computes the density function for a certain data matrix in parallel using
            ScaLAPACK.  

            Parameters:  
            * `alpha` :  
                the distributed vector where surplusses for the density function will be
                stored  
            * `m` :  
                the matrix that contains the data points, currently every process has to
                have the data points  
            * `grid` :  
                The underlying grid  
            * `densityEstimationConfig` :  
                Configuration for the density estimation  
            * `parallelConfig` :  
                configuration for ScaLAPACK  
            * `processGrid` :  
                pointer to BlacsProcessGrid  
            * `save_b` :  
                Indicates whether the old right hand side should be saved and combined
                with the new right hand side (aka streaming)  
            * `do_cv` :  
                Indicates whether crossvalidation should take place  
            * `deletedPoints` :  
                indicates the indices of removed grid points due to coarsening  
            * `newPoints` :  
                indicates the amount of added points due to refinement  

        * `computeDensityFunctionParallel(alpha, grid, densityEstimationConfig,
            parallelConfig, processGrid, do_cv=false)`  

            Computes the density function again based on the saved b's (only applicable
            for streaming) in parallel on a cluster using ScaLAPACK.  

            Parameters:  
            * `alpha` :  
                the vector where surplusses for the density function will be stored  
            * `grid` :  
                The underlying grid  
            * `densityEstimationConfig` :  
                Configuration for the density estimation combined with the new right
                hand side (aka streaming)  
            * `parallelConfig` :  
                configuration for ScaLAPACK  
            * `processGrid` :  
                pointer to BlacsProcessGrid  
            * `do_cv` :  
                Indicates whether crossvalidation should take place  

        """
        return _pysgpp_swig.DBMatOnlineDE_computeDensityFunctionParallel(self, *args)

    def computeBFromBatch(self, m: "DataMatrix", grid: "Grid", densityEstimationConfig: "DensityEstimationConfiguration") -> "sgpp::datadriven::DataVector":
        r"""


        Computes/updates the b vector for the given batch of data.  

        Parameters
        ----------
        * `m` :  
            the matrix that contains the data points  
        * `grid` :  
            The underlying grid  
        * `densityEstimationConfig` :  
            Configuration for the density estimation  

        """
        return _pysgpp_swig.DBMatOnlineDE_computeBFromBatch(self, m, grid, densityEstimationConfig)

    def computeBFromBatchParallel(self, m: "DataMatrix", grid: "Grid", densityEstimationConfig: "DensityEstimationConfiguration", parallelConfig: "ParallelConfiguration", processGrid: "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >") -> "sgpp::datadriven::DataVectorDistributed":
        r"""


        Computes/updates the b vector for the given batch of data in parallel using
        ScaLAPACK.  

        Parameters
        ----------
        * `m` :  
            the matrix that contains the data points, currently every process has to
            have the data points  
        * `grid` :  
            The underlying grid  
        * `densityEstimationConfig` :  
            Configuration for the density estimation  
        * `parallelConfig` :  
            ScaLAPACK configuration  
        * `processGrid` :  
            process grid for ScaLAPACK  

        """
        return _pysgpp_swig.DBMatOnlineDE_computeBFromBatchParallel(self, m, grid, densityEstimationConfig, parallelConfig, processGrid)

    def eval(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `eval(alpha, p, grid, force=false) -> double`  

            Evaluates the density function at a certain point.  

            Parameters:  
            * `alpha` :  
                the vector of surplusses  
            * `p` :  
                the point at which the function is evaluated  
            * `grid` :  
                the underlying grid  
            * `force` :  
                if set, it will even try to evaluate if the internal state recommends
                otherwise  

            Returns:
            the result of the evaluation  

        * `eval(alpha, values, results, grid, force=false)`  

            Evaluates the density function on multiple points.  

            Parameters:  
            * `alpha` :  
                the vector of surplusses  
            * `values` :  
                the points at which the function is evaluated  
            * `results` :  
                the result of the evaluation  
            * `grid` :  
                the underlying grid  
            * `force` :  
                if set, it will even try to evaluate if the internal state recommends
                otherwise  

        """
        return _pysgpp_swig.DBMatOnlineDE_eval(self, *args)

    def evalParallel(self, alpha: "DataVector", values: "DataMatrix", results: "DataVectorDistributed", grid: "Grid", force: "bool"=False) -> "void":
        r"""


        Evaluates the density function on multiple points using parallization.  

        Parameters
        ----------
        * `alpha` :  
            the vector of surplusses  
        * `values` :  
            the points at which the function is evaluated  
        * `results` :  
            the result of the evaluation  
        * `grid` :  
            the underlying grid  
        * `force` :  
            if set, it will even try to evaluate if the internal state recommends
            otherwise  

        """
        return _pysgpp_swig.DBMatOnlineDE_evalParallel(self, alpha, values, results, grid, force)

    def isComputed(self) -> "bool":
        r"""


        Returns if the surplus has already been computed.  

        """
        return _pysgpp_swig.DBMatOnlineDE_isComputed(self)

    def setBeta(self, beta: "double") -> "void":
        r"""


        Sets the weighting factor.  

        Parameters
        ----------
        * `beta` :  
            the new weighting factor. If set to 0, no plasticity takes place.  

        """
        return _pysgpp_swig.DBMatOnlineDE_setBeta(self, beta)

    def getBeta(self) -> "double":
        r"""


        Returns the current weighting factor.  

        """
        return _pysgpp_swig.DBMatOnlineDE_getBeta(self)

    def normalize(self, alpha: "DataVector", grid: "Grid", samples: "size_t"=1000) -> "double":
        r"""


        Normalize the Density.  

        Parameters
        ----------
        * `alpha` :  
            the vector of surplusses  
        * `grid` :  
            the underlying grid  
        * `samples` :  
            number of samples to be used for MC quadrature  

        """
        return _pysgpp_swig.DBMatOnlineDE_normalize(self, alpha, grid, samples)

    def normalizeQuadrature(self, alpha: "DataVector", grid: "Grid") -> "double":
        r"""


        Normalize the Density using Quadrature.  

        Parameters
        ----------
        * `alpha` :  
            the vector of surplusses  
        * `grid` :  
            the underlying grid  

        """
        return _pysgpp_swig.DBMatOnlineDE_normalizeQuadrature(self, alpha, grid)

    def syncDistributedDecomposition(self, processGrid: "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >", parallelConfig: "ParallelConfiguration") -> "void":
        r"""


        Synchronizes the distributed decomposition, only has an effect if scalapack is
        used.  

        """
        return _pysgpp_swig.DBMatOnlineDE_syncDistributedDecomposition(self, processGrid, parallelConfig)

    def resetTraining(self) -> "void":
        r"""


        Resets the training state of the model.  

        """
        return _pysgpp_swig.DBMatOnlineDE_resetTraining(self)
    __swig_destroy__ = _pysgpp_swig.delete_DBMatOnlineDE

# Register DBMatOnlineDE in _pysgpp_swig:
_pysgpp_swig.DBMatOnlineDE_swigregister(DBMatOnlineDE)

class DBMatOnlineDEChol(DBMatOnlineDE):
    r"""

    `DBMatOnlineDEChol(offline, grid, lambda, beta=0.)`  

    Constructors
    ------------
    * `DBMatOnlineDEChol(offline, grid, lambda, beta=0.)`  

        Constructor.  

        Parameters:  
        * `offline` :  
            The offline object we base our evaluations on.  
        * `lambda` :  
            The regularization strength (TODO(fuchsgruber) remove this)  
        * `grid` :  
            The underlying grid (TODO(fuchsgruber) do we need this?)  
        * `beta` :  
            The initial weighting factor  

    C++ includes: DBMatOnlineDEChol.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_DBMatOnlineDEChol

# Register DBMatOnlineDEChol in _pysgpp_swig:
_pysgpp_swig.DBMatOnlineDEChol_swigregister(DBMatOnlineDEChol)


def buildDBMatOnlineDE(*args) -> "sgpp::datadriven::DBMatOnlineDE *":
    r"""


    Factory to build a DBMatOnlineDE object to manipulate the decomposition in
    offline object.  

    Parameters
    ----------
    * `offline` :  
        offline object that holds the decomposed system matrix  
    * `grid` :  
        the underlying grid  
    * `lambda` :  
        regularization strength (todo(fuchsgruber): maybe remove this)  
    * `beta` :  
        plasticity weighting factor. If set to 0, no plasticity takes place.  
    * `matDecompType` :  
        the matrix decomposition type of the online matrix  

    """
    return _pysgpp_swig.buildDBMatOnlineDE(*args)

def buildOfflineObject(gridConfig: "sgpp::base::GeneralGridConfiguration const &", adaptivityConfig: "AdaptivityConfiguration", regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration") -> "sgpp::datadriven::DBMatOffline *":
    r"""


    Based on the configuration file, build the appropriate DBMatOffline object and
    return it.  

    Parameters
    ----------
    * `gridConfig` :  
        The configuration of the grid  
    * `adaptivityConfig` :  
        The configuration of the grid adaptivity  
    * `regularizationConfig` :  
        The configuration of the grid regularization  
    * `densityEstimationConfig` :  
        The configuration of the matrix decomposition  

    Returns
    -------
    new instance of DBMatOffline implementor owned by caller.  

    """
    return _pysgpp_swig.buildOfflineObject(gridConfig, adaptivityConfig, regularizationConfig, densityEstimationConfig)

def buildFromFile(fname: "std::string const &") -> "sgpp::datadriven::DBMatOffline *":
    r"""


    Read a serialized DBMatOffline object and construct a new object with the
    information.  

    Parameters
    ----------
    * `fname` :  
        Path to the serialized DBMatOffline object.  

    Returns
    -------
    new instance of DBMatOffline implementor owned by caller.  

    """
    return _pysgpp_swig.buildFromFile(fname)
class DBMatObjectStore(object):
    r"""

    `DBMatObjectStore()`  
    `DBMatObjectStore(fileName)`  

    Constructors
    ------------
    * `DBMatObjectStore()`  

        Default constructor.  

    * `DBMatObjectStore(fileName)`  

        Constructor with path to database file.  

        Parameters:  
        * `fileName` :  

    C++ includes: DBMatObjectStore.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DBMatObjectStore()`  

            Default constructor.  

        * `DBMatObjectStore(fileName)`  

            Constructor with path to database file.  

            Parameters:  
            * `fileName` :  

        """
        _pysgpp_swig.DBMatObjectStore_swiginit(self, _pysgpp_swig.new_DBMatObjectStore(*args))

    def putObject(self, gridConfig: "sgpp::base::GeneralGridConfiguration const &", geometryConfig: "sgpp::datadriven::GeometryConfiguration const &", adaptivityConfig: "AdaptivityConfiguration", regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration", object: "DBMatOffline") -> "void":
        r"""


        Stores a given offline object together with its configuration in the object
        store.  

        Parameters
        ----------
        * `gridConfig` :  
            Grid configuration  
        * `geometryConfig` :  
            Geometry configuration for geometry aware sparse grids  
        * `adaptivityConfig` :  
            Adaptivity configuration  
        * `regularizationConfig` :  
            Regularization configuration  
        * `densityEstimationConfig` :  
            Density estimation configuration  
        * `object` :  
            The object to be stored  

        """
        return _pysgpp_swig.DBMatObjectStore_putObject(self, gridConfig, geometryConfig, adaptivityConfig, regularizationConfig, densityEstimationConfig, object)

    def getBaseObject(self, gridConfig: "sgpp::base::GeneralGridConfiguration const &", geometryConfig: "sgpp::datadriven::GeometryConfiguration const &", adaptivityConfig: "AdaptivityConfiguration", regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration", baseGridConfig: "sgpp::base::GeneralGridConfiguration &") -> "sgpp::datadriven::DBMatOfflinePermutable const *":
        r"""


        Returns a suitable base object for the permutation and blow-up approach.  

        The grid configuration of the stored base object is returned in baseGridConfig.
        If no suitable base object exists, a nullptr is returned.  

        Parameters
        ----------
        * `gridConfig` :  
            Grid configuration of the desired offline object  
        * `geometryConfig` :  
            Geometry configuration for geometry aware sparse grids  
        * `adaptivityConfig` :  
            Adaptivity configuration  
        * `regularizationConfig` :  
            Regularization configuration  
        * `densityEstimationConfig` :  
            Density estimation configuration  
        * `baseGridConfig` :  
            Reference to a grid configuration. Gets overridden by the grid configuration
            of the returned base object  

        Returns
        -------
        const DBMatOfflinePermutable*  

        """
        return _pysgpp_swig.DBMatObjectStore_getBaseObject(self, gridConfig, geometryConfig, adaptivityConfig, regularizationConfig, densityEstimationConfig, baseGridConfig)

    def getObject(self, gridConfig: "sgpp::base::GeneralGridConfiguration const &", geometryConfig: "sgpp::datadriven::GeometryConfiguration const &", adaptivityConfig: "AdaptivityConfiguration", regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration") -> "sgpp::datadriven::DBMatOffline const *":
        r"""


        Returns an identical offline object to the specified configuration.  

        If no such object exits, a nullptr is returned  

        Parameters
        ----------
        * `gridConfig` :  
            Grid configuration  
        * `geometryConfig` :  
            Geometry configuration for geometry aware sparse grids  
        * `adaptivityConfig` :  
            Adaptivity configuration  
        * `regularizationConfig` :  
            Regularization configuration  
        * `densityEstimationConfig` :  
            Density estimation configuration  

        Returns
        -------
        const DBMatOffline*  

        """
        return _pysgpp_swig.DBMatObjectStore_getObject(self, gridConfig, geometryConfig, adaptivityConfig, regularizationConfig, densityEstimationConfig)
    __swig_destroy__ = _pysgpp_swig.delete_DBMatObjectStore

# Register DBMatObjectStore in _pysgpp_swig:
_pysgpp_swig.DBMatObjectStore_swigregister(DBMatObjectStore)

class DBMatDatabase(object):
    r"""

    `DBMatDatabase(filepath)`  

    A database class to store and retrieve online matrix decompositions for the
    sparse grid density estimation.  

    The class works on a json file.  

    Constructors
    ------------
    * `DBMatDatabase(filepath)`  

        Initializes the database from a json filepath.  

        Parameters:  
        * `filepath` :  
            the path to the json database  

    C++ includes: DBMatDatabase.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, filepath: "std::string const &"):
        r"""


        Initializes the database from a json filepath.  

        Parameters
        ----------
        * `filepath` :  
            the path to the json database  

        """
        _pysgpp_swig.DBMatDatabase_swiginit(self, _pysgpp_swig.new_DBMatDatabase(filepath))
    __swig_destroy__ = _pysgpp_swig.delete_DBMatDatabase

    def hasDataMatrix(self, gridConfig: "sgpp::base::GeneralGridConfiguration const &", adaptivityConfig: "AdaptivityConfiguration", regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration") -> "bool":
        r"""


        Scans the entire database and checks weather any entry matches the
        configuration.  

        Parameters
        ----------
        * `gridConfig` :  
            the grid configuration the matrix must match  
        * `adaptivityConfig` :  
            the adaptivity configuration the matrix must match  
        * `regularizationConfig` :  
            the regularization configuration the matrix must match  
        * `densityEstimationConfig` :  
            the density estimation configuration the matrix must match  

        Returns
        -------
        weather the configuration is held in the database  

        """
        return _pysgpp_swig.DBMatDatabase_hasDataMatrix(self, gridConfig, adaptivityConfig, regularizationConfig, densityEstimationConfig)

    def hasBaseDataMatrix(self, gridConfig: "sgpp::base::GeneralGridConfiguration const &", adaptivityConfig: "AdaptivityConfiguration", regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration") -> "bool":
        r"""


        Scans the entire database and checks whether there exists an entry that can be
        permutated to match the configurations.  

        A entry matches if all config properties except the gridConfig's level vector
        are equal and level vector elements unequal 1 are set equal.  

        Parameters
        ----------
        * `gridConfig` :  
            the grid configuration the matrix must match  
        * `adaptivityConfig` :  
            the adaptivity configuration the matrix must match  
        * `regularizationConfig` :  
            the regularization configuration the matrix must match  
        * `densityEstimationConfig` :  
            the density estimation configuration the matrix must match  

        Returns
        -------
        weather the configuration is held in the database  

        """
        return _pysgpp_swig.DBMatDatabase_hasBaseDataMatrix(self, gridConfig, adaptivityConfig, regularizationConfig, densityEstimationConfig)

    def getDataMatrix(self, gridConfig: "sgpp::base::GeneralGridConfiguration const &", adaptivityConfig: "AdaptivityConfiguration", regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration") -> "std::string &":
        r"""


        Scans the entire database and finds the first entry that matches the
        configurations.  

        Parameters
        ----------
        * `gridConfig` :  
            the grid configuration the matrix must match  
        * `adaptivityConfig` :  
            the adaptivity configuration the matrix must match  
        * `regularizationConfig` :  
            the regularization configuration the matrix must match  
        * `densityEstimationConfig` :  
            the density estimation configuration the matrix must match  

        Returns
        -------
        Returns the string of the datamatrix if any match was obtained and throws an
        exception otherwise  

        """
        return _pysgpp_swig.DBMatDatabase_getDataMatrix(self, gridConfig, adaptivityConfig, regularizationConfig, densityEstimationConfig)

    def getBaseDataMatrix(self, gridConfig: "sgpp::base::GeneralGridConfiguration const &", adaptivityConfig: "AdaptivityConfiguration", regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration", baseGridConfig: "sgpp::base::GeneralGridConfiguration &") -> "std::string &":
        r"""


        Scans the entire database and returns the first entry that can be permutated to
        match the configurations.  

        A entry matches if all config properties except the gridConfig's level vector
        are equal and level vector elements unequal 1 are set equal.  

        Parameters
        ----------
        * `gridConfig` :  
            the grid configuration the matrix must match  
        * `adaptivityConfig` :  
            the adaptivity configuration the matrix must match  
        * `regularizationConfig` :  
            the regularization configuration the matrix must match  
        * `densityEstimationConfig` :  
            the density estimation configuration the matrix must match  
        * `baseGridConfig` :  
            is overriten with the entry's grid config  

        Returns
        -------
        Returns the string of the datamatrix if any match was obtained and throws an
        exception otherwise  

        """
        return _pysgpp_swig.DBMatDatabase_getBaseDataMatrix(self, gridConfig, adaptivityConfig, regularizationConfig, densityEstimationConfig, baseGridConfig)

    def putDataMatrix(self, gridConfig: "sgpp::base::GeneralGridConfiguration const &", adaptivityConfig: "AdaptivityConfiguration", regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration", filepath: "std::string const", overwriteEntry: "bool"=False) -> "void":
        r"""


        Puts a filepath for a given configuration in the database.  

        The filepath refers to the matrix file. If for this configuration a filepath is
        already present in the database the filepath is updated if and only if the
        overwriteEntry parameter is set (default = false).  

        Parameters
        ----------
        * `gridConfig` :  
            the grid configuration the matrix matches  
        * `adaptivityConfig` :  
            the adaptivity configuration the matrix matches  
        * `regularizationConfig` :  
            the regularization configuration the matrix matches  
        * `densityEstimationConfig` :  
            the density estimation configuration the matrix matches  
        * `filepath` :  
            the path where the matrix decomposition is located at  
        * `overwriteEntry` :  
            replaces existing entries with the same configuration if and only if this
            parameter is set  

        """
        return _pysgpp_swig.DBMatDatabase_putDataMatrix(self, gridConfig, adaptivityConfig, regularizationConfig, densityEstimationConfig, filepath, overwriteEntry)

# Register DBMatDatabase in _pysgpp_swig:
_pysgpp_swig.DBMatDatabase_swigregister(DBMatDatabase)

class GridFactory(object):
    r"""

    `GridFactory()`  

    Factory class to create grids based on a configuration file.  

    Constructors
    ------------
    * `GridFactory()`  

    C++ includes: GridFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        """
        _pysgpp_swig.GridFactory_swiginit(self, _pysgpp_swig.new_GridFactory())

    def createGrid(self, gridConfig: "sgpp::base::GeneralGridConfiguration const &", interactions: "std::set< std::set< size_t > > const") -> "sgpp::base::Grid *":
        r"""


        Creates and initializes a grid based on a configuration file.  

        Parameters
        ----------
        * `gridConfig` :  
            the grid configuration  
        * `interactions` :  
            the interactions for each dimension  

        Returns
        -------
        pointer to the grid object created  

        """
        return _pysgpp_swig.GridFactory_createGrid(self, gridConfig, interactions)

    def getInteractions(self, config: "sgpp::datadriven::GeometryConfiguration") -> "std::set< std::set< size_t > >":
        r"""


        """
        return _pysgpp_swig.GridFactory_getInteractions(self, config)

    def getBlockInteractions(self, interactions: "std::set< std::set< size_t > > &", geoConf: "sgpp::datadriven::GeometryConfiguration &", stencilConf: "sgpp::datadriven::StencilConfiguration &") -> "void":
        r"""


        """
        return _pysgpp_swig.GridFactory_getBlockInteractions(self, interactions, geoConf, stencilConf)

    def getHierarchicalParents(self, interactions: "std::set< std::set< size_t > > &", geometryConf: "sgpp::datadriven::GeometryConfiguration &", stencilConf: "sgpp::datadriven::StencilConfiguration &") -> "void":
        r"""


        """
        return _pysgpp_swig.GridFactory_getHierarchicalParents(self, interactions, geometryConf, stencilConf)

    def getDirectNeighbours(self, interactions: "std::set< std::set< size_t > > &", geometryConf: "sgpp::datadriven::GeometryConfiguration &", stencilConf: "sgpp::datadriven::StencilConfiguration &") -> "void":
        r"""


        """
        return _pysgpp_swig.GridFactory_getDirectNeighbours(self, interactions, geometryConf, stencilConf)
    __swig_destroy__ = _pysgpp_swig.delete_GridFactory

# Register GridFactory in _pysgpp_swig:
_pysgpp_swig.GridFactory_swigregister(GridFactory)

class DBMatPermutationFactory(object):
    r"""

    `DBMatPermutationFactory()`  
    `DBMatPermutationFactory(store)`  
    `DBMatPermutationFactory(store, dbFilePath)`  

    Constructors
    ------------
    * `DBMatPermutationFactory()`  

    * `DBMatPermutationFactory(store)`  

    * `DBMatPermutationFactory(store, dbFilePath)`  

    C++ includes: DBMatPermutationFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `DBMatPermutationFactory()`  

        * `DBMatPermutationFactory(store)`  

        * `DBMatPermutationFactory(store, dbFilePath)`  

        """
        _pysgpp_swig.DBMatPermutationFactory_swiginit(self, _pysgpp_swig.new_DBMatPermutationFactory(*args))

    def getPermutedObject(self, gridConfig: "sgpp::base::GeneralGridConfiguration const &", geometryConfig: "sgpp::datadriven::GeometryConfiguration const", adaptivityConfig: "AdaptivityConfiguration", regularizationConfig: "RegularizationConfiguration", densityEstimationConfig: "DensityEstimationConfiguration") -> "sgpp::datadriven::DBMatOfflinePermutable *":
        r"""


        Returns a offline object matching the specified configuration.  

        If the store contains a suitable base object, the permutation and blow-up
        approach is applied on a copy of the base object, which is then returned. If no
        suitable base object exists in the store, the factory builds a suitable object
        from scratch and stores it. If a database file is given, the database is
        searched for a base object, which is then again stored.  

        Parameters
        ----------
        * `gridConfig` :  
            The desired grid configuration.  
        * `geometryConfig` :  
            The desired geometry configuration.  
        * `adaptivityConfig` :  
            The desired adaptivity configuration.  
        * `regularizationConfig` :  
            The desired regularization configuration.  
        * `densityEstimationConfig` :  
            The desired desnity estimation configuration.  

        Returns
        -------
        A offline object that matches the configuration.  

        """
        return _pysgpp_swig.DBMatPermutationFactory_getPermutedObject(self, gridConfig, geometryConfig, adaptivityConfig, regularizationConfig, densityEstimationConfig)
    __swig_destroy__ = _pysgpp_swig.delete_DBMatPermutationFactory

# Register DBMatPermutationFactory in _pysgpp_swig:
_pysgpp_swig.DBMatPermutationFactory_swigregister(DBMatPermutationFactory)


def createOperationTest(grid: "Grid") -> "sgpp::datadriven::OperationTest *":
    r"""


    Factory method, returning an OperationTest for the grid at hand.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for OperationTest  

    Returns
    -------
    Pointer to the new OperationTest object for the Grid grid  

    """
    return _pysgpp_swig.createOperationTest(grid)

def createOperationRegularizationDiagonal(grid: "Grid", mode: "int", k: "double") -> "sgpp::base::OperationMatrix *":
    r"""


    Factory method, returning an OperationRegularizationDiagonal for the grid at
    hand.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for OperationRegularizationDiagonal  
    * `mode` :  
        Mode, specifying which regularization to use. Example:
        OperationRegularizationDiagonal::HKMIX.  
    * `k` :  
        Parameter for $H^k$  

    Returns
    -------
    Pointer to the new OperationRegularizationDiagonal object for the Grid grid  

    """
    return _pysgpp_swig.createOperationRegularizationDiagonal(grid, mode, k)

def createOperationDensityMarginalize(grid: "Grid") -> "sgpp::datadriven::OperationDensityMarginalize *":
    r"""


    Factory method, returning an OperationDensityMarginalize for the grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationDensityMarginalize for the Grid grid  

    """
    return _pysgpp_swig.createOperationDensityMarginalize(grid)

def createOperationDensityMargTo1D(grid: "Grid") -> "sgpp::datadriven::OperationDensityMargTo1D *":
    r"""


    Factory method, returning an OperationDensityMargTo1D for the grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationDensityMarginalize for the Grid grid  

    """
    return _pysgpp_swig.createOperationDensityMargTo1D(grid)

def createOperationDensitySampling1D(grid: "Grid") -> "sgpp::datadriven::OperationDensitySampling1D *":
    r"""


    Factory method, returning an OperationDensitySampling1D for the grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationDensitySampling1D for the Grid grid  

    """
    return _pysgpp_swig.createOperationDensitySampling1D(grid)

def createOperationDensitySampling(grid: "Grid") -> "sgpp::datadriven::OperationDensitySampling *":
    r"""


    Factory method, returning an OperationDensitySampling for the grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationDensitySampling1D for the Grid grid  

    """
    return _pysgpp_swig.createOperationDensitySampling(grid)

def createOperationDensityRejectionSampling(grid: "Grid") -> "sgpp::datadriven::OperationDensityRejectionSampling *":
    r"""


    Factory method, returning an OperationDensityRejectionSampling for the grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationDensitySampling1D for the Grid grid  

    """
    return _pysgpp_swig.createOperationDensityRejectionSampling(grid)

def createOperationDensityConditional(grid: "Grid") -> "sgpp::datadriven::OperationDensityConditional *":
    r"""


    Factory method, returning an OperationDensityConditional for the grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationDensityConditional for the Grid grid  

    """
    return _pysgpp_swig.createOperationDensityConditional(grid)

def createOperationRosenblattTransformation(grid: "Grid") -> "sgpp::datadriven::OperationRosenblattTransformation *":
    r"""


    Factory method, returning an OperationRosenblattTransformation for the grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationRosenblattTransformation for the Grid grid  

    """
    return _pysgpp_swig.createOperationRosenblattTransformation(grid)

def createOperationRosenblattTransformation1D(grid: "Grid") -> "sgpp::datadriven::OperationTransformation1D *":
    r"""


    Factory method, returning an OperationRosenblattTransformation for the grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationRosenblattTransformation1D for the Grid grid  

    """
    return _pysgpp_swig.createOperationRosenblattTransformation1D(grid)

def createOperationInverseRosenblattTransformation(grid: "Grid") -> "sgpp::datadriven::OperationInverseRosenblattTransformation *":
    r"""


    Factory method, returning an OperationInverseRosenblattTransformation for the
    grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationInverseRosenblattTransformation for the Grid grid  

    """
    return _pysgpp_swig.createOperationInverseRosenblattTransformation(grid)

def createOperationInverseRosenblattTransformation1D(grid: "Grid") -> "sgpp::datadriven::OperationTransformation1D *":
    r"""


    Factory method, returning an OperationInverseRosenblattTransformation1D for the
    grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationInverseRosenblattTransformation1D for the Grid grid  

    """
    return _pysgpp_swig.createOperationInverseRosenblattTransformation1D(grid)

def createOperationRosenblattTransformationKDE(kde: "KernelDensityEstimator") -> "sgpp::datadriven::OperationRosenblattTransformationKDE *":
    r"""


    Factory method, returning an OperationRosenblattTransformationKDE for the kde.  

    Parameters
    ----------
    * `kde` :  
        KernelDensityEstimator for which the Rosenblatt transformation should be
        computed  

    Returns
    -------
    Pointer to new OperationRosenblattTransformationKDE for the kde  

    """
    return _pysgpp_swig.createOperationRosenblattTransformationKDE(kde)

def createOperationInverseRosenblattTransformationKDE(kde: "KernelDensityEstimator") -> "sgpp::datadriven::OperationInverseRosenblattTransformationKDE *":
    r"""


    Factory method, returning an OperationInverseRosenblattTransformationKDE for the
    kde.  

    Parameters
    ----------
    * `kde` :  
        KernelDensityEstimator for which the inverse Rosenblatt transformation
        should be computed  

    Returns
    -------
    Pointer to new OperationInverseRosenblattTransformationKDE for the kde  

    """
    return _pysgpp_swig.createOperationInverseRosenblattTransformationKDE(kde)

def createOperationDensityMarginalizeKDE(kde: "KernelDensityEstimator") -> "sgpp::datadriven::OperationDensityMarginalizeKDE *":
    r"""


    Factory method, returning an OperationDensityMarginalizeKDE for the kernel
    density.  

    Parameters
    ----------
    * `kde` :  
        kernel density which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationDensityMarginalizeKDE  

    """
    return _pysgpp_swig.createOperationDensityMarginalizeKDE(kde)

def createOperationDensityConditionalKDE(kde: "KernelDensityEstimator") -> "sgpp::datadriven::OperationDensityConditionalKDE *":
    r"""


    Factory method, returning an OperationDensityConditionalKDE for the kernel
    density.  

    Parameters
    ----------
    * `kde` :  
        kernel density which is to be used for the operation  

    Returns
    -------
    Pointer to new OperationDensityConditionalKDE  

    """
    return _pysgpp_swig.createOperationDensityConditionalKDE(kde)

def createOperationMultipleEval(*args) -> "sgpp::base::OperationMultipleEval *":
    r"""


    Factory method, returning an OperationMultipleEval for the grid.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used for the operation  
    * `dataset` :  
        dataset to be evaluated  
    * `configuration` :  
        configuration to be used (evalType and evalSubType)  

    Returns
    -------
    Pointer to new OperationMultipleEval for the Grid grid  

    """
    return _pysgpp_swig.createOperationMultipleEval(*args)

def createOperationMakePositive(*args) -> "sgpp::datadriven::OperationMakePositive *":
    r"""


    Factory method, returning an OperationMakePositive for an arbitrary function f
    or some sparse grid, which is yet to be defined.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `candidateSearchAlgorithm` :  
        defines algorithm for candidate set enumeration  
    * `interpolationAlgorithm` :  
        defines algorithm for coefficient estimation of extension set  
    * `generateConsistentGrid` :  
        if set to true, all hierarchical ancestors are available in the resulting
        grid  
    * `f` :  
        function to be approximated (as an alternative to a sparse grid function)  

    Returns
    -------
    Pointer to the new OperationMakePositive object for the Grid grid  

    """
    return _pysgpp_swig.createOperationMakePositive(*args)

def createOperationLimitFunctionValueRange(*args) -> "sgpp::datadriven::OperationLimitFunctionValueRange *":
    r"""


    Factory method, returning an OperationLimitFunctionValueRange for an arbitrary
    function f or some sparse grid, which is yet to be defined.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `candidateSearchAlgorithm` :  
        defines algorithm for candidate set enumeration  
    * `interpolationAlgorithm` :  
        defines algorithm for coefficient estimation of extension set  
    * `f` :  
        function to be approximated (as an alternative to a sparse grid function)  

    Returns
    -------
    Pointer to the new OperationLimitFunctionValueRange object for the Grid grid  

    """
    return _pysgpp_swig.createOperationLimitFunctionValueRange(*args)

def createOperationCovariance(grid: "Grid") -> "sgpp::datadriven::OperationCovariance *":
    r"""


    Factory method, returning an OperationCovariance for the grid at hand.  

    Note: object has to be freed after use.  

    Parameters
    ----------
    * `grid` :  
        Grid which is to be used  

    Returns
    -------
    Pointer to the new OperationCovariance object for the Grid grid  

    """
    return _pysgpp_swig.createOperationCovariance(grid)
class ClassificatorQuality(object):
    r"""


    struct to encapsulate the classsifiers quality by its characteristic numbers  

    C++ includes: TypesDatadriven.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    truePositive_ = property(_pysgpp_swig.ClassificatorQuality_truePositive__get, _pysgpp_swig.ClassificatorQuality_truePositive__set)
    trueNegative_ = property(_pysgpp_swig.ClassificatorQuality_trueNegative__get, _pysgpp_swig.ClassificatorQuality_trueNegative__set)
    falsePositive_ = property(_pysgpp_swig.ClassificatorQuality_falsePositive__get, _pysgpp_swig.ClassificatorQuality_falsePositive__set)
    falseNegative_ = property(_pysgpp_swig.ClassificatorQuality_falseNegative__get, _pysgpp_swig.ClassificatorQuality_falseNegative__set)

    def __init__(self):
        _pysgpp_swig.ClassificatorQuality_swiginit(self, _pysgpp_swig.new_ClassificatorQuality())
    __swig_destroy__ = _pysgpp_swig.delete_ClassificatorQuality

# Register ClassificatorQuality in _pysgpp_swig:
_pysgpp_swig.ClassificatorQuality_swigregister(ClassificatorQuality)

class LearnerTiming(object):
    r"""


    strcut to encapsulate the learner's timings during training  

    C++ includes: TypesDatadriven.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    timeComplete_ = property(_pysgpp_swig.LearnerTiming_timeComplete__get, _pysgpp_swig.LearnerTiming_timeComplete__set)
    timeMultComplete_ = property(_pysgpp_swig.LearnerTiming_timeMultComplete__get, _pysgpp_swig.LearnerTiming_timeMultComplete__set)
    timeMultCompute_ = property(_pysgpp_swig.LearnerTiming_timeMultCompute__get, _pysgpp_swig.LearnerTiming_timeMultCompute__set)
    timeMultTransComplete_ = property(_pysgpp_swig.LearnerTiming_timeMultTransComplete__get, _pysgpp_swig.LearnerTiming_timeMultTransComplete__set)
    timeMultTransCompute_ = property(_pysgpp_swig.LearnerTiming_timeMultTransCompute__get, _pysgpp_swig.LearnerTiming_timeMultTransCompute__set)
    timeRegularization_ = property(_pysgpp_swig.LearnerTiming_timeRegularization__get, _pysgpp_swig.LearnerTiming_timeRegularization__set)
    GFlop_ = property(_pysgpp_swig.LearnerTiming_GFlop__get, _pysgpp_swig.LearnerTiming_GFlop__set)
    GByte_ = property(_pysgpp_swig.LearnerTiming_GByte__get, _pysgpp_swig.LearnerTiming_GByte__set)

    def __init__(self):
        _pysgpp_swig.LearnerTiming_swiginit(self, _pysgpp_swig.new_LearnerTiming())
    __swig_destroy__ = _pysgpp_swig.delete_LearnerTiming

# Register LearnerTiming in _pysgpp_swig:
_pysgpp_swig.LearnerTiming_swigregister(LearnerTiming)

class LearnerBase(object):
    r"""

    `LearnerBase(isRegression, isVerbose=true)`  
    `LearnerBase(copyMe)`  

    Abstract class that implements a regression/classification learner based on
    spatial adaptive Sparse Grids.  

    Furthermore this class is intended to provide a framework for adavanded
    regression and classification methods by allowing to override basic routines
    like train and test.  

    Constructors
    ------------
    * `LearnerBase(isRegression, isVerbose=true)`  

        Constructor.  

        Parameters:  
        * `isRegression` :  
            flag for regression  
        * `isVerbose` :  
            flag for verbose output  

    * `LearnerBase(copyMe)`  

        Copy-Constructor.  

        Parameters:  
        * `copyMe` :  
            LearnerBase that should be duplicated  

    C++ includes: LearnerBase.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_LearnerBase

    def train(self, *args) -> "sgpp::datadriven::LearnerTiming":
        r"""


        Overloaded function
        -------------------
        * `train(trainDataset, classes, GridConfig, SolverConfig, lambdaRegularization)
            -> LearnerTiming`  

            Learning a dataset with regular sparse grids.  

            Parameters:  
            * `trainDataset` :  
                the training dataset  
            * `classes` :  
                classes corresponding to the training dataset  
            * `GridConfig` :  
                configuration of the regular grid  
            * `SolverConfig` :  
                configuration of the SLE solver  
            * `lambdaRegularization` :  
                regularization parameter lambda  

        * `train(trainDataset, classes, GridConfig, SolverConfigRefine,
            SolverConfigFinal, AdaptConfig, testAccDuringAdapt, lambdaRegularization,
            testDataset=nullptr, testClasses=nullptr) -> LearnerTiming`  

            Learning a dataset with spatially adaptive sparse grids.  

            Parameters:  
            * `trainDataset` :  
                the training dataset  
            * `classes` :  
                classes corresponding to the training dataset  
            * `GridConfig` :  
                configuration of the regular start grid  
            * `SolverConfigRefine` :  
                configuration of the SLE solver during the adaptive refinements of the
                grid  
            * `SolverConfigFinal` :  
                configuration of the final SLE solving step on the refined grid  
            * `AdaptConfig` :  
                configuration of the adaptivity strategy  
            * `testAccDuringAdapt` :  
                set to true if the training accuracy should be determined in evert
                refinement step  
            * `lambdaRegularization` :  
                regularization parameter lambda  
            * `testDataset` :  
                the test dataset (for accuracy output, nullptr if no output is wished)  
            * `testClasses` :  
                classes corresponding to the testing dataset (for accuracy output,
                nullptr if no output is wished)  

        """
        return _pysgpp_swig.LearnerBase_train(self, *args)

    def predict(self, testDataset: "DataMatrix", classesComputed: "DataVector") -> "void":
        r"""


        executes a Regression test for a given dataset and returns the result  

        Parameters
        ----------
        * `testDataset` :  
            dataset that is evaluated with the current learner  
        * `classesComputed` :  
            result of the evaluation of the data set  

        Returns
        -------
        regression values of testDataset  

        """
        return _pysgpp_swig.LearnerBase_predict(self, testDataset, classesComputed)

    def multTranspose(self, dataset: "DataMatrix", multiplier: "DataVector", result: "DataVector") -> "void":
        r"""


        """
        return _pysgpp_swig.LearnerBase_multTranspose(self, dataset, multiplier, result)

    def getAccuracy(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `getAccuracy(classesComputed, classesReference, threshold=0.0) -> double`  

            compute the accuracy for given testDataset.  

            In case if classification (isRegression == false) this routine returns the
            learner's accuracy In case of regressions (isRegression == true) this
            routine returns the learner's MSE  

            Parameters:  
            * `classesComputed` :  
                regression results of the test dataset  
            * `classesReference` :  
                reference labels of the test dataset  
            * `threshold` :  
                threshold used for classification, ignored when performing regressions  

            Returns:
            accuracy, percent or MSE, depending on the execution mode  

        * `getAccuracy(testDataset, classesReference, threshold=0.0) -> double`  

            compute the accuracy for given testDataset.  

            test is automatically called in order to determine the regression values of
            the current learner  

            In case if classification (isRegression == false) this routine returns the
            learner's accuracy In case of regressions (isRegression == true) this
            routine returns the learner's MSE  

            Parameters:  
            * `testDataset` :  
                dataset to be tested  
            * `classesReference` :  
                reference labels of the test dataset  
            * `threshold` :  
                threshold used for classification, ignored when performing regressions  

            Returns:
            accuracy, percent or MSE, depending on the execution mode  

        """
        return _pysgpp_swig.LearnerBase_getAccuracy(self, *args)

    def getCassificatorQuality(self, *args) -> "sgpp::datadriven::ClassificatorQuality":
        r"""


        Overloaded function
        -------------------
        * `getCassificatorQuality(classesComputed, classesReference, threshold=0.0) ->
            ClassificatorQuality`  

            compute the quality for given testDataset, classification ONLY!  

            Parameters:  
            * `classesComputed` :  
                regression results of the test dataset  
            * `classesReference` :  
                reference labels of the test dataset  
            * `threshold` :  
                threshold used for classification, ignored when performing regressions  

            Returns:
            quality structure containing tp, tn, fp, fn counts  

        * `getCassificatorQuality(testDataset, classesReference, threshold=0.0) ->
            ClassificatorQuality`  

            compute the quality for given testDataset, classification ONLY! test is
            automatically called in order to determine the regression values of the
            current learner  

            Parameters:  
            * `testDataset` :  
                dataset to be tested  
            * `classesReference` :  
                reference labels of the test dataset  
            * `threshold` :  
                threshold used for classification, ignored when performing regressions  

            Returns:
            quality structure containing tp, tn, fp, fn counts  

        """
        return _pysgpp_swig.LearnerBase_getCassificatorQuality(self, *args)

    def store(self, tGridFilename: "std::string", tAlphaFilename: "std::string") -> "void":
        r"""


        store the grid and its current coefficients into files for further usage.  

        Parameters
        ----------
        * `tGridFilename` :  
            filename of grid file  
        * `tAlphaFilename` :  
            filename of coefficient file  

        """
        return _pysgpp_swig.LearnerBase_store(self, tGridFilename, tAlphaFilename)

    def dumpGrid(self, tFilename: "std::string") -> "void":
        r"""


        simple dump of grid points into file, e.g.  

        used to plot with gnuplot  

        only executed if grid is trained  

        Parameters
        ----------
        * `tFilename` :  
            filename to store the dump to  

        """
        return _pysgpp_swig.LearnerBase_dumpGrid(self, tFilename)

    def dumpFunction(self, tFilename: "std::string", resolution: "size_t") -> "void":
        r"""


        simple dump of sparse grid function into file, e.g.  

        used to plot with gnuplot.  

        only executed if grid is trained and number of dimensions <= 2.  

        Parameters
        ----------
        * `tFilename` :  
            filename to store the dump to  
        * `resolution` :  
            resolution of function plot  

        """
        return _pysgpp_swig.LearnerBase_dumpFunction(self, tFilename, resolution)

    def getIsRegression(self) -> "bool":
        r"""


        determines the current mode  

        Returns
        -------
        returns whether the current mode is regression or not  

        """
        return _pysgpp_swig.LearnerBase_getIsRegression(self)

    def getIsVerbose(self) -> "bool":
        r"""


        determines the current verbose mode of learner  

        Returns
        -------
        returns whether the current learner has verbose output  

        """
        return _pysgpp_swig.LearnerBase_getIsVerbose(self)

    def setIsVerbose(self, isVerbose: "bool const") -> "void":
        r"""


        sets the current verbose mode of learner  

        Parameters
        ----------
        * `isVerbose` :  
            the current learner's verbose output  

        """
        return _pysgpp_swig.LearnerBase_setIsVerbose(self, isVerbose)

    def getRefinementExecTimes(self) -> "std::vector< std::pair< size_t,double >,std::allocator< std::pair< size_t,double > > >":
        r"""


        """
        return _pysgpp_swig.LearnerBase_getRefinementExecTimes(self)

    def getGrid(self) -> "sgpp::base::Grid &":
        r"""


        """
        return _pysgpp_swig.LearnerBase_getGrid(self)

    def getAlpha(self) -> "sgpp::base::DataVector &":
        r"""


        """
        return _pysgpp_swig.LearnerBase_getAlpha(self)

    def setReuseCoefficients(self, reuseCoefficients: "bool") -> "void":
        r"""


        """
        return _pysgpp_swig.LearnerBase_setReuseCoefficients(self, reuseCoefficients)

    def setSolverVerbose(self, solverVerbose: "bool") -> "void":
        r"""


        """
        return _pysgpp_swig.LearnerBase_setSolverVerbose(self, solverVerbose)

# Register LearnerBase in _pysgpp_swig:
_pysgpp_swig.LearnerBase_swigregister(LearnerBase)

class DensityEstimator(object):
    r"""

    `DensityEstimator()`  

    Constructors
    ------------
    * `DensityEstimator()`  

    C++ includes: DensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_DensityEstimator

    def initialize(self, samples: "DataMatrix") -> "void":
        r"""


        """
        return _pysgpp_swig.DensityEstimator_initialize(self, samples)

    def pdf(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `pdf(points, res)`  

        * `pdf(x) -> double`  

        """
        return _pysgpp_swig.DensityEstimator_pdf(self, *args)

    def mean(self) -> "double":
        r"""


        """
        return _pysgpp_swig.DensityEstimator_mean(self)

    def variance(self) -> "double":
        r"""


        """
        return _pysgpp_swig.DensityEstimator_variance(self)

    def std_deviation(self) -> "double":
        r"""


        """
        return _pysgpp_swig.DensityEstimator_std_deviation(self)

    def cov(self, cov: "DataMatrix", bounds: "DataMatrix"=None) -> "void":
        r"""


        """
        return _pysgpp_swig.DensityEstimator_cov(self, cov, bounds)

    def corrcoef(self, corr: "DataMatrix", bounds: "DataMatrix"=None) -> "void":
        r"""


        """
        return _pysgpp_swig.DensityEstimator_corrcoef(self, corr, bounds)

    def getSamples(self, *args) -> "std::shared_ptr< sgpp::base::DataMatrix >":
        r"""


        Overloaded function
        -------------------
        * `getSamples() -> std::shared_ptr< base::DataMatrix >`  

        * `getSamples(dim) -> std::shared_ptr< base::DataVector >`  

        """
        return _pysgpp_swig.DensityEstimator_getSamples(self, *args)

    def getDim(self) -> "size_t":
        r"""


        """
        return _pysgpp_swig.DensityEstimator_getDim(self)

    def getNsamples(self) -> "size_t":
        r"""


        """
        return _pysgpp_swig.DensityEstimator_getNsamples(self)

    def crossEntropy(self, samples: "DataMatrix") -> "double":
        r"""


        """
        return _pysgpp_swig.DensityEstimator_crossEntropy(self, samples)

# Register DensityEstimator in _pysgpp_swig:
_pysgpp_swig.DensityEstimator_swigregister(DensityEstimator)

KernelType_GAUSSIAN = _pysgpp_swig.KernelType_GAUSSIAN
KernelType_EPANECHNIKOV = _pysgpp_swig.KernelType_EPANECHNIKOV
BandwidthOptimizationType_NONE = _pysgpp_swig.BandwidthOptimizationType_NONE
BandwidthOptimizationType_SILVERMANSRULE = _pysgpp_swig.BandwidthOptimizationType_SILVERMANSRULE
BandwidthOptimizationType_SCOTTSRULE = _pysgpp_swig.BandwidthOptimizationType_SCOTTSRULE
BandwidthOptimizationType_MAXIMUMLIKELIHOOD = _pysgpp_swig.BandwidthOptimizationType_MAXIMUMLIKELIHOOD
M_SQRT2PI = _pysgpp_swig.M_SQRT2PI
class Kernel(object):
    r"""


    C++ includes: KernelDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_Kernel

    def eval(self, x: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.Kernel_eval(self, x)

    def cdf(self, x: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.Kernel_cdf(self, x)

    def derivative(self, x: "double") -> "double":
        r"""


        """
        return _pysgpp_swig.Kernel_derivative(self, x)

    def norm(self) -> "double":
        r"""


        """
        return _pysgpp_swig.Kernel_norm(self)

    def variance(self) -> "double":
        r"""


        """
        return _pysgpp_swig.Kernel_variance(self)

    def getType(self) -> "sgpp::datadriven::KernelType":
        r"""


        """
        return _pysgpp_swig.Kernel_getType(self)

# Register Kernel in _pysgpp_swig:
_pysgpp_swig.Kernel_swigregister(Kernel)

class GaussianKernel(Kernel):
    r"""


    C++ includes: KernelDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_GaussianKernel

    def __init__(self):
        _pysgpp_swig.GaussianKernel_swiginit(self, _pysgpp_swig.new_GaussianKernel())

# Register GaussianKernel in _pysgpp_swig:
_pysgpp_swig.GaussianKernel_swigregister(GaussianKernel)

class EpanechnikovKernel(Kernel):
    r"""


    C++ includes: KernelDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_EpanechnikovKernel

    def __init__(self):
        _pysgpp_swig.EpanechnikovKernel_swiginit(self, _pysgpp_swig.new_EpanechnikovKernel())

# Register EpanechnikovKernel in _pysgpp_swig:
_pysgpp_swig.EpanechnikovKernel_swigregister(EpanechnikovKernel)

class KernelDensityEstimator(DensityEstimator):
    r"""

    `KernelDensityEstimator(samples, kernelType=KernelType::GAUSSIAN,
        bandwidthOptimizationType=BandwidthOptimizationType::SILVERMANSRULE)`  
    `KernelDensityEstimator(kde)`  
    `KernelDensityEstimator(kernelType=KernelType::GAUSSIAN,
        bandwidthOptimizationType=BandwidthOptimizationType::SILVERMANSRULE)`  
    `KernelDensityEstimator(samplesVec, kernelType=KernelType::GAUSSIAN,
        bandwidthOptimizationType=BandwidthOptimizationType::SILVERMANSRULE)`  

    Constructors
    ------------
    * `KernelDensityEstimator(samples, kernelType=KernelType::GAUSSIAN,
        bandwidthOptimizationType=BandwidthOptimizationType::SILVERMANSRULE)`  

    * `KernelDensityEstimator(kde)`  

    * `KernelDensityEstimator(kernelType=KernelType::GAUSSIAN,
        bandwidthOptimizationType=BandwidthOptimizationType::SILVERMANSRULE)`  

    * `KernelDensityEstimator(samplesVec, kernelType=KernelType::GAUSSIAN,
        bandwidthOptimizationType=BandwidthOptimizationType::SILVERMANSRULE)`  

    C++ includes: KernelDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `KernelDensityEstimator(samples, kernelType=KernelType::GAUSSIAN,
            bandwidthOptimizationType=BandwidthOptimizationType::SILVERMANSRULE)`  

        * `KernelDensityEstimator(kde)`  

        * `KernelDensityEstimator(kernelType=KernelType::GAUSSIAN,
            bandwidthOptimizationType=BandwidthOptimizationType::SILVERMANSRULE)`  

        * `KernelDensityEstimator(samplesVec, kernelType=KernelType::GAUSSIAN,
            bandwidthOptimizationType=BandwidthOptimizationType::SILVERMANSRULE)`  

        """
        _pysgpp_swig.KernelDensityEstimator_swiginit(self, _pysgpp_swig.new_KernelDensityEstimator(*args))
    __swig_destroy__ = _pysgpp_swig.delete_KernelDensityEstimator

    def initialize(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `initialize(samples)`  

        * `initialize(samplesVec)`  

        """
        return _pysgpp_swig.KernelDensityEstimator_initialize(self, *args)

    def initializeKernel(self, kernelType: "sgpp::datadriven::KernelType") -> "void":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_initializeKernel(self, kernelType)

    def getKernel(self) -> "sgpp::datadriven::Kernel &":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_getKernel(self)

    def cov(self, cov: "DataMatrix", bounds: "DataMatrix"=None) -> "void":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_cov(self, cov, bounds)

    def pdf(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `pdf(points, res)`  

        * `pdf(x) -> double`  

        """
        return _pysgpp_swig.KernelDensityEstimator_pdf(self, *args)

    def evalSubset(self, x: "DataVector", skipElements: "SizeVector") -> "double":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_evalSubset(self, x, skipElements)

    def getConditionalizationFactor(self, pcond: "DataVector") -> "void":
        r"""


        getter and setter functions  

        """
        return _pysgpp_swig.KernelDensityEstimator_getConditionalizationFactor(self, pcond)

    def setConditionalizationFactor(self, pcond: "DataVector") -> "void":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_setConditionalizationFactor(self, pcond)

    def updateConditionalizationFactors(self, x: "DataVector", dims: "SizeVector", pcond: "DataVector") -> "void":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_updateConditionalizationFactors(self, x, dims, pcond)

    def getBandwidths(self, sigma: "DataVector") -> "void":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_getBandwidths(self, sigma)

    def setBandwidths(self, sigma: "DataVector") -> "void":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_setBandwidths(self, sigma)

    def getSamples(self, *args) -> "std::shared_ptr< sgpp::base::DataVector >":
        r"""


        Overloaded function
        -------------------
        * `getSamples() -> std::shared_ptr< base::DataMatrix >`  

        * `getSamples(dim) -> std::shared_ptr< base::DataVector >`  

        """
        return _pysgpp_swig.KernelDensityEstimator_getSamples(self, *args)

    def getSample(self, isample: "size_t", sample: "DataVector") -> "void":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_getSample(self, isample, sample)

    def margToDimX(self, idim: "size_t") -> "sgpp::datadriven::KernelDensityEstimator *":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_margToDimX(self, idim)

    def marginalize(self, idim: "size_t") -> "sgpp::datadriven::KernelDensityEstimator *":
        r"""


        """
        return _pysgpp_swig.KernelDensityEstimator_marginalize(self, idim)

# Register KernelDensityEstimator in _pysgpp_swig:
_pysgpp_swig.KernelDensityEstimator_swigregister(KernelDensityEstimator)

class KDEMaximumLikelihoodCrossValidation(ScalarFunction):
    r"""

    `KDEMaximumLikelihoodCrossValidation(kde, kfold=10,
        seedValue=std::mt19937_64::default_seed)`  

    Constructors
    ------------
    * `KDEMaximumLikelihoodCrossValidation(kde, kfold=10,
        seedValue=std::mt19937_64::default_seed)`  

        Constructor.  

    C++ includes: KernelDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Constructor.  

        """
        _pysgpp_swig.KDEMaximumLikelihoodCrossValidation_swiginit(self, _pysgpp_swig.new_KDEMaximumLikelihoodCrossValidation(*args))
    __swig_destroy__ = _pysgpp_swig.delete_KDEMaximumLikelihoodCrossValidation

# Register KDEMaximumLikelihoodCrossValidation in _pysgpp_swig:
_pysgpp_swig.KDEMaximumLikelihoodCrossValidation_swigregister(KDEMaximumLikelihoodCrossValidation)

class RuleOfThumb(object):
    r"""


    C++ includes: KernelDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def getSampleMean(data: "DataVector") -> "double":
        r"""


        """
        return _pysgpp_swig.RuleOfThumb_getSampleMean(data)

    @staticmethod
    def getSampleVariance(data: "DataVector") -> "double":
        r"""


        """
        return _pysgpp_swig.RuleOfThumb_getSampleVariance(data)

    @staticmethod
    def getSampleStd(data: "DataVector") -> "double":
        r"""


        """
        return _pysgpp_swig.RuleOfThumb_getSampleStd(data)

    def __init__(self):
        _pysgpp_swig.RuleOfThumb_swiginit(self, _pysgpp_swig.new_RuleOfThumb())
    __swig_destroy__ = _pysgpp_swig.delete_RuleOfThumb

# Register RuleOfThumb in _pysgpp_swig:
_pysgpp_swig.RuleOfThumb_swigregister(RuleOfThumb)

def RuleOfThumb_getSampleMean(data: "DataVector") -> "double":
    r"""


    """
    return _pysgpp_swig.RuleOfThumb_getSampleMean(data)

def RuleOfThumb_getSampleVariance(data: "DataVector") -> "double":
    r"""


    """
    return _pysgpp_swig.RuleOfThumb_getSampleVariance(data)

def RuleOfThumb_getSampleStd(data: "DataVector") -> "double":
    r"""


    """
    return _pysgpp_swig.RuleOfThumb_getSampleStd(data)

class SilvermansRule(object):
    r"""


    C++ includes: KernelDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def optimizeBandwidths(kde: "KernelDensityEstimator", bandwidths: "DataVector") -> "void":
        r"""


        """
        return _pysgpp_swig.SilvermansRule_optimizeBandwidths(kde, bandwidths)

    def __init__(self):
        _pysgpp_swig.SilvermansRule_swiginit(self, _pysgpp_swig.new_SilvermansRule())
    __swig_destroy__ = _pysgpp_swig.delete_SilvermansRule

# Register SilvermansRule in _pysgpp_swig:
_pysgpp_swig.SilvermansRule_swigregister(SilvermansRule)

def SilvermansRule_optimizeBandwidths(kde: "KernelDensityEstimator", bandwidths: "DataVector") -> "void":
    r"""


    """
    return _pysgpp_swig.SilvermansRule_optimizeBandwidths(kde, bandwidths)

class ScottsRule(object):
    r"""


    C++ includes: KernelDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def optimizeBandwidths(kde: "KernelDensityEstimator", bandwidths: "DataVector") -> "void":
        r"""


        """
        return _pysgpp_swig.ScottsRule_optimizeBandwidths(kde, bandwidths)

    def __init__(self):
        _pysgpp_swig.ScottsRule_swiginit(self, _pysgpp_swig.new_ScottsRule())
    __swig_destroy__ = _pysgpp_swig.delete_ScottsRule

# Register ScottsRule in _pysgpp_swig:
_pysgpp_swig.ScottsRule_swigregister(ScottsRule)

def ScottsRule_optimizeBandwidths(kde: "KernelDensityEstimator", bandwidths: "DataVector") -> "void":
    r"""


    """
    return _pysgpp_swig.ScottsRule_optimizeBandwidths(kde, bandwidths)

class MaximumLikelihoodCrossValidation(object):
    r"""


    C++ includes: KernelDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def optimizeBandwidths(kde: "KernelDensityEstimator", bandwidths: "DataVector") -> "void":
        r"""


        """
        return _pysgpp_swig.MaximumLikelihoodCrossValidation_optimizeBandwidths(kde, bandwidths)

    def __init__(self):
        _pysgpp_swig.MaximumLikelihoodCrossValidation_swiginit(self, _pysgpp_swig.new_MaximumLikelihoodCrossValidation())
    __swig_destroy__ = _pysgpp_swig.delete_MaximumLikelihoodCrossValidation

# Register MaximumLikelihoodCrossValidation in _pysgpp_swig:
_pysgpp_swig.MaximumLikelihoodCrossValidation_swigregister(MaximumLikelihoodCrossValidation)

def MaximumLikelihoodCrossValidation_optimizeBandwidths(kde: "KernelDensityEstimator", bandwidths: "DataVector") -> "void":
    r"""


    """
    return _pysgpp_swig.MaximumLikelihoodCrossValidation_optimizeBandwidths(kde, bandwidths)

class CrossvalidationForRegularizationConfiguration(object):
    r"""


    C++ includes: SparseGridDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    enable_ = property(_pysgpp_swig.CrossvalidationForRegularizationConfiguration_enable__get, _pysgpp_swig.CrossvalidationForRegularizationConfiguration_enable__set)
    kfold_ = property(_pysgpp_swig.CrossvalidationForRegularizationConfiguration_kfold__get, _pysgpp_swig.CrossvalidationForRegularizationConfiguration_kfold__set)
    seed_ = property(_pysgpp_swig.CrossvalidationForRegularizationConfiguration_seed__get, _pysgpp_swig.CrossvalidationForRegularizationConfiguration_seed__set)
    shuffle_ = property(_pysgpp_swig.CrossvalidationForRegularizationConfiguration_shuffle__get, _pysgpp_swig.CrossvalidationForRegularizationConfiguration_shuffle__set)
    silent_ = property(_pysgpp_swig.CrossvalidationForRegularizationConfiguration_silent__get, _pysgpp_swig.CrossvalidationForRegularizationConfiguration_silent__set)
    lambda_ = property(_pysgpp_swig.CrossvalidationForRegularizationConfiguration_lambda__get, _pysgpp_swig.CrossvalidationForRegularizationConfiguration_lambda__set)
    lambdaStart_ = property(_pysgpp_swig.CrossvalidationForRegularizationConfiguration_lambdaStart__get, _pysgpp_swig.CrossvalidationForRegularizationConfiguration_lambdaStart__set)
    lambdaEnd_ = property(_pysgpp_swig.CrossvalidationForRegularizationConfiguration_lambdaEnd__get, _pysgpp_swig.CrossvalidationForRegularizationConfiguration_lambdaEnd__set)
    lambdaSteps_ = property(_pysgpp_swig.CrossvalidationForRegularizationConfiguration_lambdaSteps__get, _pysgpp_swig.CrossvalidationForRegularizationConfiguration_lambdaSteps__set)
    logScale_ = property(_pysgpp_swig.CrossvalidationForRegularizationConfiguration_logScale__get, _pysgpp_swig.CrossvalidationForRegularizationConfiguration_logScale__set)

    def __init__(self):
        _pysgpp_swig.CrossvalidationForRegularizationConfiguration_swiginit(self, _pysgpp_swig.new_CrossvalidationForRegularizationConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_CrossvalidationForRegularizationConfiguration

# Register CrossvalidationForRegularizationConfiguration in _pysgpp_swig:
_pysgpp_swig.CrossvalidationForRegularizationConfiguration_swigregister(CrossvalidationForRegularizationConfiguration)

class MakePositiveConfiguration(object):
    r"""


    C++ includes: SparseGridDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pysgpp_swig.MakePositiveConfiguration_swiginit(self, _pysgpp_swig.new_MakePositiveConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_MakePositiveConfiguration

# Register MakePositiveConfiguration in _pysgpp_swig:
_pysgpp_swig.MakePositiveConfiguration_swigregister(MakePositiveConfiguration)

class SGDEConfiguration(object):
    r"""


    C++ includes: SparseGridDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    makePositive_ = property(_pysgpp_swig.SGDEConfiguration_makePositive__get, _pysgpp_swig.SGDEConfiguration_makePositive__set)
    makePositive_candidateSearchAlgorithm_ = property(_pysgpp_swig.SGDEConfiguration_makePositive_candidateSearchAlgorithm__get, _pysgpp_swig.SGDEConfiguration_makePositive_candidateSearchAlgorithm__set)
    makePositive_interpolationAlgorithm_ = property(_pysgpp_swig.SGDEConfiguration_makePositive_interpolationAlgorithm__get, _pysgpp_swig.SGDEConfiguration_makePositive_interpolationAlgorithm__set)
    makePositive_generateConsistentGrid_ = property(_pysgpp_swig.SGDEConfiguration_makePositive_generateConsistentGrid__get, _pysgpp_swig.SGDEConfiguration_makePositive_generateConsistentGrid__set)
    unitIntegrand_ = property(_pysgpp_swig.SGDEConfiguration_unitIntegrand__get, _pysgpp_swig.SGDEConfiguration_unitIntegrand__set)

    def __init__(self):
        _pysgpp_swig.SGDEConfiguration_swiginit(self, _pysgpp_swig.new_SGDEConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_SGDEConfiguration

# Register SGDEConfiguration in _pysgpp_swig:
_pysgpp_swig.SGDEConfiguration_swigregister(SGDEConfiguration)

class SparseGridDensityEstimatorConfiguration(object):
    r"""

    `SparseGridDensityEstimatorConfiguration()`  
    `SparseGridDensityEstimatorConfiguration(fileName)`  

    Constructors
    ------------
    * `SparseGridDensityEstimatorConfiguration()`  

    * `SparseGridDensityEstimatorConfiguration(fileName)`  

    C++ includes: SparseGridDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `SparseGridDensityEstimatorConfiguration()`  

        * `SparseGridDensityEstimatorConfiguration(fileName)`  

        """
        _pysgpp_swig.SparseGridDensityEstimatorConfiguration_swiginit(self, _pysgpp_swig.new_SparseGridDensityEstimatorConfiguration(*args))

    def clone(self) -> "sgpp::datadriven::SparseGridDensityEstimatorConfiguration *":
        r"""


        """
        return _pysgpp_swig.SparseGridDensityEstimatorConfiguration_clone(self)

    def initConfig(self) -> "void":
        r"""


        """
        return _pysgpp_swig.SparseGridDensityEstimatorConfiguration_initConfig(self)

    def stringToRegularizationType(self, regularizationType: "std::string &") -> "sgpp::datadriven::RegularizationType":
        r"""


        """
        return _pysgpp_swig.SparseGridDensityEstimatorConfiguration_stringToRegularizationType(self, regularizationType)

    def stringToSolverType(self, solverType: "std::string &") -> "sgpp::solver::SLESolverType":
        r"""


        """
        return _pysgpp_swig.SparseGridDensityEstimatorConfiguration_stringToSolverType(self, solverType)
    __swig_destroy__ = _pysgpp_swig.delete_SparseGridDensityEstimatorConfiguration

# Register SparseGridDensityEstimatorConfiguration in _pysgpp_swig:
_pysgpp_swig.SparseGridDensityEstimatorConfiguration_swigregister(SparseGridDensityEstimatorConfiguration)

class SparseGridDensityEstimator(DensityEstimator):
    r"""

    `SparseGridDensityEstimator(grid, alpha, samples)`  
    `SparseGridDensityEstimator(learnerSGDE)`  
    `SparseGridDensityEstimator(gridConfig, adaptivityConfig, solverConfig,
        regularizationConfig, crossvalidationConfig, sgdeConfig)`  
    `SparseGridDensityEstimator(learnerSGDEConfig)`  

    Constructors
    ------------
    * `SparseGridDensityEstimator(grid, alpha, samples)`  

        construct learner from given grid and coefficients  

        Parameters:  
        * `grid` :  
        * `alpha` :  
        * `samples` :  

    * `SparseGridDensityEstimator(learnerSGDE)`  

    * `SparseGridDensityEstimator(gridConfig, adaptivityConfig, solverConfig,
        regularizationConfig, crossvalidationConfig, sgdeConfig)`  

        Constructor.  

        Parameters:  
        * `gridConfig` :  
            grid configuration  
        * `adaptivityConfig` :  
            adaptive refinement configuration  
        * `solverConfig` :  
            solver configuration (CG)  
        * `regularizationConfig` :  
            config for regularization operator  
        * `crossvalidationConfig` :  
            configuration for the cross validation  
        * `sgdeConfig` :  
            configuration for the sparse grid density estimation  

    * `SparseGridDensityEstimator(learnerSGDEConfig)`  

    C++ includes: SparseGridDensityEstimator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `SparseGridDensityEstimator(grid, alpha, samples)`  

            construct learner from given grid and coefficients  

            Parameters:  
            * `grid` :  
            * `alpha` :  
            * `samples` :  

        * `SparseGridDensityEstimator(learnerSGDE)`  

        * `SparseGridDensityEstimator(gridConfig, adaptivityConfig, solverConfig,
            regularizationConfig, crossvalidationConfig, sgdeConfig)`  

            Constructor.  

            Parameters:  
            * `gridConfig` :  
                grid configuration  
            * `adaptivityConfig` :  
                adaptive refinement configuration  
            * `solverConfig` :  
                solver configuration (CG)  
            * `regularizationConfig` :  
                config for regularization operator  
            * `crossvalidationConfig` :  
                configuration for the cross validation  
            * `sgdeConfig` :  
                configuration for the sparse grid density estimation  

        * `SparseGridDensityEstimator(learnerSGDEConfig)`  

        """
        _pysgpp_swig.SparseGridDensityEstimator_swiginit(self, _pysgpp_swig.new_SparseGridDensityEstimator(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SparseGridDensityEstimator

    def pdf(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `pdf(points, res)`  

            Evaluation of the sparse grid density at a set of points.  

            Parameters:  
            * `points` :  
                DataMatrix (nrows = number of samples, ncols = dimensionality)  
            * `res` :  
                DataVector (size = number of samples) where the results are stored  

        * `pdf(x) -> double`  

            This methods evaluates the sparse grid density at a single point.  

            Parameters:  
            * `x` :  
                DataVector length equal to dimensionality  

        """
        return _pysgpp_swig.SparseGridDensityEstimator_pdf(self, *args)

    def cov(self, cov: "DataMatrix", bounds: "DataMatrix"=None) -> "void":
        r"""


        Computes the covariance of the density function.  

        """
        return _pysgpp_swig.SparseGridDensityEstimator_cov(self, cov, bounds)

    def getSamples(self, *args) -> "std::shared_ptr< sgpp::base::DataMatrix >":
        r"""


        Overloaded function
        -------------------
        * `getSamples() -> std::shared_ptr< base::DataMatrix >`  

            returns the complete sample set  

        * `getSamples(dim) -> std::shared_ptr< base::DataVector >`  

            returns the samples in the given dimension  

            Parameters:  
            * `dim` :  

        """
        return _pysgpp_swig.SparseGridDensityEstimator_getSamples(self, *args)

    def getSurpluses(self) -> "sgpp::base::DataVector &":
        r"""


        returns the surpluses  

        """
        return _pysgpp_swig.SparseGridDensityEstimator_getSurpluses(self)

    def getGrid(self) -> "sgpp::base::Grid &":
        r"""


        returns the grid  

        """
        return _pysgpp_swig.SparseGridDensityEstimator_getGrid(self)

    def train(self, grid: "Grid", alpha: "DataVector", train: "DataMatrix", lambdaReg: "double") -> "void":
        r"""


        Does the learning step on a given grid, training set and regularization
        parameter lambda.  

        Parameters
        ----------
        * `grid` :  
            grid  
        * `alpha` :  
            coefficient vector  
        * `train` :  
            sample set  
        * `lambdaReg` :  
            regularization parameter  

        """
        return _pysgpp_swig.SparseGridDensityEstimator_train(self, grid, alpha, train, lambdaReg)

    def margToDimX(self, idim: "size_t") -> "sgpp::datadriven::SparseGridDensityEstimator *":
        r"""


        Compute marginal density.  

        Parameters
        ----------
        * `idim` :  
            dimension which should be left after marginalization  

        """
        return _pysgpp_swig.SparseGridDensityEstimator_margToDimX(self, idim)

    def marginalize(self, idim: "size_t") -> "sgpp::datadriven::SparseGridDensityEstimator *":
        r"""


        Marginalize the density in one dimension and return result.  

        Parameters
        ----------
        * `idim` :  
            dimension which should be marginalized  

        """
        return _pysgpp_swig.SparseGridDensityEstimator_marginalize(self, idim)

# Register SparseGridDensityEstimator in _pysgpp_swig:
_pysgpp_swig.SparseGridDensityEstimator_swigregister(SparseGridDensityEstimator)

class LearnerSGDEConfiguration(object):
    r"""

    `LearnerSGDEConfiguration()`  
    `LearnerSGDEConfiguration(fileName)`  

    Constructors
    ------------
    * `LearnerSGDEConfiguration()`  

    * `LearnerSGDEConfiguration(fileName)`  

    C++ includes: LearnerSGDE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `LearnerSGDEConfiguration()`  

        * `LearnerSGDEConfiguration(fileName)`  

        """
        _pysgpp_swig.LearnerSGDEConfiguration_swiginit(self, _pysgpp_swig.new_LearnerSGDEConfiguration(*args))

    def clone(self) -> "sgpp::datadriven::LearnerSGDEConfiguration *":
        r"""


        """
        return _pysgpp_swig.LearnerSGDEConfiguration_clone(self)

    def initConfig(self) -> "void":
        r"""


        """
        return _pysgpp_swig.LearnerSGDEConfiguration_initConfig(self)

    def stringToGridType(self, gridType: "std::string &") -> "sgpp::base::GridType":
        r"""


        """
        return _pysgpp_swig.LearnerSGDEConfiguration_stringToGridType(self, gridType)

    def stringToRegularizationType(self, regularizationType: "std::string &") -> "sgpp::datadriven::RegularizationType":
        r"""


        """
        return _pysgpp_swig.LearnerSGDEConfiguration_stringToRegularizationType(self, regularizationType)

    def stringToSolverType(self, solverType: "std::string &") -> "sgpp::solver::SLESolverType":
        r"""


        """
        return _pysgpp_swig.LearnerSGDEConfiguration_stringToSolverType(self, solverType)
    __swig_destroy__ = _pysgpp_swig.delete_LearnerSGDEConfiguration

# Register LearnerSGDEConfiguration in _pysgpp_swig:
_pysgpp_swig.LearnerSGDEConfiguration_swigregister(LearnerSGDEConfiguration)

class LearnerSGDE(DensityEstimator):
    r"""

    `LearnerSGDE(learnerSGDE)`  
    `LearnerSGDE(learnerSGDEConfig)`  
    `LearnerSGDE(gridConfig, adaptivityConfig, solverConfig, regularizationConfig,
        crossvalidationConfig)`  

    Constructors
    ------------
    * `LearnerSGDE(learnerSGDE)`  

    * `LearnerSGDE(learnerSGDEConfig)`  

    * `LearnerSGDE(gridConfig, adaptivityConfig, solverConfig, regularizationConfig,
        crossvalidationConfig)`  

        Constructor.  

        Parameters:  
        * `gridConfig` :  
            grid configuration  
        * `adaptivityConfig` :  
            adaptive refinement configuration  
        * `solverConfig` :  
            solver configuration (CG)  
        * `regularizationConfig` :  
            config for regularization operator  
        * `crossvalidationConfig` :  
            configuration for the cross validation  

    C++ includes: LearnerSGDE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `LearnerSGDE(learnerSGDE)`  

        * `LearnerSGDE(learnerSGDEConfig)`  

        * `LearnerSGDE(gridConfig, adaptivityConfig, solverConfig, regularizationConfig,
            crossvalidationConfig)`  

            Constructor.  

            Parameters:  
            * `gridConfig` :  
                grid configuration  
            * `adaptivityConfig` :  
                adaptive refinement configuration  
            * `solverConfig` :  
                solver configuration (CG)  
            * `regularizationConfig` :  
                config for regularization operator  
            * `crossvalidationConfig` :  
                configuration for the cross validation  

        """
        _pysgpp_swig.LearnerSGDE_swiginit(self, _pysgpp_swig.new_LearnerSGDE(*args))
    __swig_destroy__ = _pysgpp_swig.delete_LearnerSGDE

    def pdf(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `pdf(points, res)`  

            Evaluation of the sparse grid density at a set of points.  

            Parameters:  
            * `points` :  
                DataMatrix (nrows = number of samples, ncols = dimensionality)  
            * `res` :  
                DataVector (size = number of samples) where the results are stored  

        * `pdf(x) -> double`  

            This methods evaluates the sparse grid density at a single point.  

            Parameters:  
            * `x` :  
                DataVector length equal to dimensionality  

        """
        return _pysgpp_swig.LearnerSGDE_pdf(self, *args)

    def cov(self, cov: "DataMatrix", bounds: "DataMatrix"=None) -> "void":
        r"""


        WARNING: Not yet implemented.  

        """
        return _pysgpp_swig.LearnerSGDE_cov(self, cov, bounds)

    def getSamples(self, *args) -> "std::shared_ptr< sgpp::base::DataMatrix >":
        r"""


        Overloaded function
        -------------------
        * `getSamples() -> std::shared_ptr< base::DataMatrix >`  

            returns the complete sample set  

        * `getSamples(dim) -> std::shared_ptr< base::DataVector >`  

            returns the samples in the given dimension  

            Parameters:  
            * `dim` :  

        """
        return _pysgpp_swig.LearnerSGDE_getSamples(self, *args)

    def getSurpluses(self) -> "sgpp::base::DataVector *":
        r"""


        returns the surpluses  

        """
        return _pysgpp_swig.LearnerSGDE_getSurpluses(self)

    def getGrid(self) -> "sgpp::base::Grid *":
        r"""


        returns the grid  

        """
        return _pysgpp_swig.LearnerSGDE_getGrid(self)

    def getSharedSurpluses(self) -> "std::shared_ptr< sgpp::base::DataVector >":
        r"""


        """
        return _pysgpp_swig.LearnerSGDE_getSharedSurpluses(self)

    def getSharedGrid(self) -> "std::shared_ptr< sgpp::base::Grid >":
        r"""


        """
        return _pysgpp_swig.LearnerSGDE_getSharedGrid(self)

    def train(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `train()`  

            Learns the data.  

        * `train(grid, alpha, trainData, lambdaReg)`  

            Does the learning step (i.e.  

            computes pdf) on a given grid, training set and regularization parameter
            lambda  

            Parameters:  
            * `grid` :  
                grid  
            * `alpha` :  
                coefficient vector  
            * `trainData` :  
                sample set  
            * `lambdaReg` :  
                regularization parameter  

        """
        return _pysgpp_swig.LearnerSGDE_train(self, *args)

    def trainOnline(self, labels: "DataVector", testData: "DataMatrix", testLabels: "DataVector", validData: "DataMatrix", validLabels: "DataVector", classLabels: "DataVector", maxDataPasses: "size_t", refType: "std::string", refMonitor: "std::string", refPeriod: "size_t", accDeclineThreshold: "double", accDeclineBufferSize: "size_t", minRefInterval: "size_t", usePrior: "bool") -> "void":
        r"""


        Performs the sparse grid density estimation via online learning.  

        Parameters
        ----------
        * `labels` :  
            The training labels  
        * `testData` :  
            The test data  
        * `testLabels` :  
            The corresponding test labels  
        * `validData` :  
            The validation data  
        * `validLabels` :  
            The corresponding validation labels  
        * `classLabels` :  
            The ocurring class labels (e.g. -1,1)  
        * `maxDataPasses` :  
            The number of passes over the whole training data  
        * `refType` :  
            The refinement indicator (surplus, zero-crossings or data-based)  
        * `refMonitor` :  
            The refinement strategy (periodic or convergence-based)  
        * `refPeriod` :  
            The refinement interval (if periodic refinement is chosen)  
        * `accDeclineThreshold` :  
            The convergence threshold (if convergence-based refinement is chosen)  
        * `accDeclineBufferSize` :  
            The number of accuracy measurements which are used to check convergence (if
            convergence-based refinement is chosen)  
        * `minRefInterval` :  
            The minimum number of data points (or data batches) which have to be
            processed before next refinement can be scheduled (if convergence-based
            refinement is chosen)  
        * `usePrior` :  
            Specifies whether prior probabilities should be used to predict class labels  

        """
        return _pysgpp_swig.LearnerSGDE_trainOnline(self, labels, testData, testLabels, validData, validLabels, classLabels, maxDataPasses, refType, refMonitor, refPeriod, accDeclineThreshold, accDeclineBufferSize, minRefInterval, usePrior)

    def storeResults(self, testDataset: "DataMatrix") -> "void":
        r"""


        Stores classified data, grids and density function evaluations to csv files.  

        Parameters
        ----------
        * `testDataset` :  
            The data for which class labels should be predicted  

        """
        return _pysgpp_swig.LearnerSGDE_storeResults(self, testDataset)

    def predict(self, testDataset: "DataMatrix", predictedLabels: "DataVector") -> "void":
        r"""


        Predicts class labels based on the trained model.  

        Parameters
        ----------
        * `testDataset` :  
            The data for which class labels should be predicted  
        * `predictedLabels` :  
            The predicted class labels  

        """
        return _pysgpp_swig.LearnerSGDE_predict(self, testDataset, predictedLabels)

    def getAccuracy(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `getAccuracy(testDataset, referenceLabels, threshold) -> double`  

            Computes the classification accuracy.  

            Parameters:  
            * `testDataset` :  
                The data for which class labels should be predicted  
            * `referenceLabels` :  
                The corresponding actual class labels  
            * `threshold` :  
                The decision threshold (e.g. for class labels -1, 1 -> threshold = 0)  

            Returns:
            The resulting accuracy  

        * `getAccuracy(referenceLabels, threshold, predictedLabels) -> double`  

            Computes the classification accuracy.  

            Parameters:  
            * `referenceLabels` :  
                The actual class labels  
            * `threshold` :  
                The decision threshold (e.g. for class labels -1, 1 -> threshold = 0)  
            * `predictedLabels` :  
                The predicted class labels  

            Returns:
            The resulting accuracy  

        """
        return _pysgpp_swig.LearnerSGDE_getAccuracy(self, *args)

    def getError(self, data: "DataMatrix", labels: "DataVector", threshold: "double const", errorType: "std::string") -> "double":
        r"""


        Error evaluation required for convergence-based refinement.  

        Parameters
        ----------
        * `data` :  
            The data points to measure the error on  
        * `labels` :  
            The corresponding class labels  
        * `threshold` :  
            The decision threshold (e.g. for class labels -1, 1 -> threshold = 0)  
        * `errorType` :  
            The error type (only "Acc" possible, i.e. classification error based on
            accuracy)  

        Returns
        -------
        The error evaluation  

        """
        return _pysgpp_swig.LearnerSGDE_getError(self, data, labels, threshold, errorType)
    error = property(_pysgpp_swig.LearnerSGDE_error_get, _pysgpp_swig.LearnerSGDE_error_set)
    avgErrors = property(_pysgpp_swig.LearnerSGDE_avgErrors_get, _pysgpp_swig.LearnerSGDE_avgErrors_set)

# Register LearnerSGDE in _pysgpp_swig:
_pysgpp_swig.LearnerSGDE_swigregister(LearnerSGDE)

class RegressionLearner(object):
    r"""

    `RegressionLearner(gridConfig, adaptivityConfig, solverConfig,
        finalSolverConfig, regularizationConfig)`  
    `RegressionLearner(gridConfig, adaptivityConfig, solverConfig,
        finalSolverConfig, regularizationConfig, terms)`  

    The RegressionLearner class Solves a regression problem with continuous target
    vector.  

    Constructors
    ------------
    * `RegressionLearner(gridConfig, adaptivityConfig, solverConfig,
        finalSolverConfig, regularizationConfig)`  

        RegressionLearner.  

        Parameters:  
        * `gridConfig` :  
        * `adaptivityConfig` :  
        * `solverConfig` :  
            is the solver used during each adaptivity step  
        * `finalSolverConfig` :  
            is the solver used to build the final model  
        * `regularizationConfig` :  

    * `RegressionLearner(gridConfig, adaptivityConfig, solverConfig,
        finalSolverConfig, regularizationConfig, terms)`  

        RegressionLearner.  

        Parameters:  
        * `gridConfig` :  
        * `adaptivityConfig` :  
        * `solverConfig` :  
            is the solver used during each adaptivity step  
        * `finalSolverConfig` :  
            is the solver used to build the final model  
        * `regularizationConfig` :  
        * `terms` :  
            is a vector that contains all desired interaction terms. For example, if
            we want to include grid points that model an interaction between the
            first and the second predictor, we would include the vector [1,2] in
            terms.  

    C++ includes: RegressionLearner.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `RegressionLearner(gridConfig, adaptivityConfig, solverConfig,
            finalSolverConfig, regularizationConfig)`  

            RegressionLearner.  

            Parameters:  
            * `gridConfig` :  
            * `adaptivityConfig` :  
            * `solverConfig` :  
                is the solver used during each adaptivity step  
            * `finalSolverConfig` :  
                is the solver used to build the final model  
            * `regularizationConfig` :  

        * `RegressionLearner(gridConfig, adaptivityConfig, solverConfig,
            finalSolverConfig, regularizationConfig, terms)`  

            RegressionLearner.  

            Parameters:  
            * `gridConfig` :  
            * `adaptivityConfig` :  
            * `solverConfig` :  
                is the solver used during each adaptivity step  
            * `finalSolverConfig` :  
                is the solver used to build the final model  
            * `regularizationConfig` :  
            * `terms` :  
                is a vector that contains all desired interaction terms. For example, if
                we want to include grid points that model an interaction between the
                first and the second predictor, we would include the vector [1,2] in
                terms.  

        """
        _pysgpp_swig.RegressionLearner_swiginit(self, _pysgpp_swig.new_RegressionLearner(*args))

    def train(self, trainDataset: "DataMatrix", classes: "DataVector") -> "void":
        r"""


        train fits a sparse grid regression model.  

        Parameters
        ----------
        * `trainDataset` :  
            is the design matrix  
        * `classes` :  
            is the (continuous) target  

        """
        return _pysgpp_swig.RegressionLearner_train(self, trainDataset, classes)

    def predict(self, data: "DataMatrix") -> "sgpp::base::DataVector":
        r"""


        predict  

        Parameters
        ----------
        * `data` :  
            are observations  

        Returns
        -------
        the predicted target for matrix data  

        """
        return _pysgpp_swig.RegressionLearner_predict(self, data)

    def getGridSize(self) -> "size_t":
        r"""


        getGridSize  

        Returns
        -------
        the size of the grid  

        """
        return _pysgpp_swig.RegressionLearner_getGridSize(self)

    def getGrid(self) -> "sgpp::base::Grid &":
        r"""


        getGrid  

        Returns
        -------
        the grid  

        """
        return _pysgpp_swig.RegressionLearner_getGrid(self)

    def getMSE(self, data: "DataMatrix", y: "DataVector") -> "double":
        r"""


        getMSE  

        Parameters
        ----------
        * `data` :  
            is the design matrix  
        * `y` :  
            is the target  

        Returns
        -------
        the mean-squared-error of the prediction of the model for the matrix data  

        """
        return _pysgpp_swig.RegressionLearner_getMSE(self, data, y)

    def getWeights(self) -> "sgpp::base::DataVector":
        r"""


        getWeights  

        Returns
        -------
        the weights  

        """
        return _pysgpp_swig.RegressionLearner_getWeights(self)

    def setWeights(self, weights: "DataVector") -> "void":
        r"""


        setWeights  

        Parameters
        ----------
        * `weights` :  
            are the new weights.  

        """
        return _pysgpp_swig.RegressionLearner_setWeights(self, weights)
    __swig_destroy__ = _pysgpp_swig.delete_RegressionLearner

# Register RegressionLearner in _pysgpp_swig:
_pysgpp_swig.RegressionLearner_swigregister(RegressionLearner)

class ClassificationLearner(object):
    r"""

    `ClassificationLearner(gridConfig, adaptivityConfig, solverConfig,
        finalSolverConfig, regularizationConfig)`  
    `ClassificationLearner(gridConfig, adaptivityConfig, solverConfig,
        finalSolverConfig, regularizationConfig, terms)`  

    The ClassificationLearner class Solves a classification problem.  

    Constructors
    ------------
    * `ClassificationLearner(gridConfig, adaptivityConfig, solverConfig,
        finalSolverConfig, regularizationConfig)`  

        ClassificationLearner.  

        Parameters:  
        * `gridConfig` :  
        * `adaptivityConfig` :  
        * `solverConfig` :  
            is the solver used during each adaptivity step  
        * `finalSolverConfig` :  
            is the solver used to build the final model  
        * `regularizationConfig` :  

    * `ClassificationLearner(gridConfig, adaptivityConfig, solverConfig,
        finalSolverConfig, regularizationConfig, terms)`  

        ClassificationLearner.  

        Parameters:  
        * `gridConfig` :  
        * `adaptivityConfig` :  
        * `solverConfig` :  
            is the solver used during each adaptivity step  
        * `finalSolverConfig` :  
            is the solver used to build the final model  
        * `regularizationConfig` :  
        * `terms` :  
            is a vector that contains all desired interaction terms. For example, if
            we want to include grid points that model an interaction between the
            first and the second predictor, we would include the vector [1,2] in
            terms.  

    C++ includes: ClassificationLearner.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `ClassificationLearner(gridConfig, adaptivityConfig, solverConfig,
            finalSolverConfig, regularizationConfig)`  

            ClassificationLearner.  

            Parameters:  
            * `gridConfig` :  
            * `adaptivityConfig` :  
            * `solverConfig` :  
                is the solver used during each adaptivity step  
            * `finalSolverConfig` :  
                is the solver used to build the final model  
            * `regularizationConfig` :  

        * `ClassificationLearner(gridConfig, adaptivityConfig, solverConfig,
            finalSolverConfig, regularizationConfig, terms)`  

            ClassificationLearner.  

            Parameters:  
            * `gridConfig` :  
            * `adaptivityConfig` :  
            * `solverConfig` :  
                is the solver used during each adaptivity step  
            * `finalSolverConfig` :  
                is the solver used to build the final model  
            * `regularizationConfig` :  
            * `terms` :  
                is a vector that contains all desired interaction terms. For example, if
                we want to include grid points that model an interaction between the
                first and the second predictor, we would include the vector [1,2] in
                terms.  

        """
        _pysgpp_swig.ClassificationLearner_swiginit(self, _pysgpp_swig.new_ClassificationLearner(*args))

    def train(self, trainDataset: "DataMatrix", classes: "DataVector") -> "void":
        r"""


        train fits a sparse grid regression model.  

        Parameters
        ----------
        * `trainDataset` :  
            is the design matrix  
        * `classes` :  
            is the (continuous) target  

        """
        return _pysgpp_swig.ClassificationLearner_train(self, trainDataset, classes)

    def predict(self, data: "DataMatrix") -> "sgpp::base::DataVector":
        r"""


        predict  

        Parameters
        ----------
        * `data` :  
            are observations  

        Returns
        -------
        the predicted target for matrix data  

        """
        return _pysgpp_swig.ClassificationLearner_predict(self, data)

    def predictWithCertainty(self, data: "DataMatrix") -> "std::pair< sgpp::base::DataVector,sgpp::base::DataVector >":
        r"""


        predict  

        Parameters
        ----------
        * `data` :  
            are observations  

        Returns
        -------
        the predicted target for matrix data and the certainty of the model, that the
        observation belongs to the predicted class.  

        """
        return _pysgpp_swig.ClassificationLearner_predictWithCertainty(self, data)

    def getGridSize(self) -> "size_t":
        r"""


        getGridSize  

        Returns
        -------
        the grid size  

        """
        return _pysgpp_swig.ClassificationLearner_getGridSize(self)

    def getAccuracy(self, data: "DataMatrix", y: "DataVector") -> "double":
        r"""


        getAccuracy  

        Parameters
        ----------
        * `data` :  
            is the design matrix  
        * `y` :  
            is the target  

        Returns
        -------
        the accuracy of the prediction of the model for the matrix data  

        """
        return _pysgpp_swig.ClassificationLearner_getAccuracy(self, data, y)
    __swig_destroy__ = _pysgpp_swig.delete_ClassificationLearner

# Register ClassificationLearner in _pysgpp_swig:
_pysgpp_swig.ClassificationLearner_swigregister(ClassificationLearner)

class NearestNeighbors(object):
    r"""

    `NearestNeighbors(rows, cols)`  

    The NearestNeighbors class.  

    Generates interactions for images, that only consider interactions between
    pixels that are close to each other, measured by an $ l_2 $-distance. The pixel-
    neighborhood for a threshold of $ \sqrt{2} $ is  

    Constructors
    ------------
    * `NearestNeighbors(rows, cols)`  

        NearestNeighbors.  

        Parameters:  
        * `rows` :  
            is the number of rows of each image  
        * `cols` :  
            is the number of columns of each image  

    C++ includes: NearestNeighbors.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, rows: "size_t", cols: "size_t"):
        r"""


        NearestNeighbors.  

        Parameters
        ----------
        * `rows` :  
            is the number of rows of each image  
        * `cols` :  
            is the number of columns of each image  

        """
        _pysgpp_swig.NearestNeighbors_swiginit(self, _pysgpp_swig.new_NearestNeighbors(rows, cols))

    def getAllInteractions(self, level: "size_t", threshold: "double") -> "std::vector< std::vector< size_t,std::allocator< size_t > >,std::allocator< std::vector< size_t,std::allocator< size_t > > > >":
        r"""


        calculates all interaction terms with l2Distance(center, other) $\leq$
        threshold  

        Parameters
        ----------
        * `level` :  
            is the maximum level of interactions to include  
        * `threshold` :  
            is the maximum distance  

        Returns
        -------
        all interactions  

        """
        return _pysgpp_swig.NearestNeighbors_getAllInteractions(self, level, threshold)
    __swig_destroy__ = _pysgpp_swig.delete_NearestNeighbors

# Register NearestNeighbors in _pysgpp_swig:
_pysgpp_swig.NearestNeighbors_swigregister(NearestNeighbors)

class LearnerSGD(object):
    r"""

    `LearnerSGD(gridConfig, adaptivityConfig, pTrainData, pTrainLabels, pTestData,
        pTestLabels, pValData, pValLabels, lambda, gamma, batchSize, useValidData)`  

    LearnerSGD learns the data using stochastic gradient descent.  

    Constructors
    ------------
    * `LearnerSGD(gridConfig, adaptivityConfig, pTrainData, pTrainLabels, pTestData,
        pTestLabels, pValData, pValLabels, lambda, gamma, batchSize, useValidData)`  

        Constructor.  

        Parameters:  
        * `gridConfig` :  
            The grid configuration  
        * `adaptivityConfig` :  
            The refinement configuration  
        * `pTrainData` :  
            The training dataset  
        * `pTrainLabels` :  
            The corresponding training labels  
        * `pTestData` :  
            The test dataset  
        * `pTestLabels` :  
            The corresponding test labels  
        * `pValData` :  
            The validation dataset  
        * `pValLabels` :  
            The corresponding validation labels  
        * `lambda` :  
            The regularization parameter  
        * `gamma` :  
            The learning parameter (i.e. step width)  
        * `batchSize` :  
            The number of data points which are considered to compute the error
            contributions for predictive refinement  
        * `useValidData` :  
            Specifies if validation data should be used for all error computations  

    C++ includes: LearnerSGD.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, gridConfig: "RegularGridConfiguration", adaptivityConfig: "AdaptivityConfiguration", pTrainData: "DataMatrix", pTrainLabels: "DataVector", pTestData: "DataMatrix", pTestLabels: "DataVector", pValData: "DataMatrix", pValLabels: "DataVector", _lambda: "double", gamma: "double", batchSize: "size_t", useValidData: "bool"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `gridConfig` :  
            The grid configuration  
        * `adaptivityConfig` :  
            The refinement configuration  
        * `pTrainData` :  
            The training dataset  
        * `pTrainLabels` :  
            The corresponding training labels  
        * `pTestData` :  
            The test dataset  
        * `pTestLabels` :  
            The corresponding test labels  
        * `pValData` :  
            The validation dataset  
        * `pValLabels` :  
            The corresponding validation labels  
        * `lambda` :  
            The regularization parameter  
        * `gamma` :  
            The learning parameter (i.e. step width)  
        * `batchSize` :  
            The number of data points which are considered to compute the error
            contributions for predictive refinement  
        * `useValidData` :  
            Specifies if validation data should be used for all error computations  

        """
        _pysgpp_swig.LearnerSGD_swiginit(self, _pysgpp_swig.new_LearnerSGD(gridConfig, adaptivityConfig, pTrainData, pTrainLabels, pTestData, pTestLabels, pValData, pValLabels, _lambda, gamma, batchSize, useValidData))
    __swig_destroy__ = _pysgpp_swig.delete_LearnerSGD

    def initialize(self) -> "void":
        r"""


        Initializes the SGD learner (creates grid etc.).  

        """
        return _pysgpp_swig.LearnerSGD_initialize(self)

    def train(self, maxDataPasses: "size_t", refType: "std::string", refMonitor: "std::string", refPeriod: "size_t", errorDeclineThreshold: "double", errorDeclineBufferSize: "size_t", minRefInterval: "size_t") -> "void":
        r"""


        Implements online learning using stochastic gradient descent.  

        Parameters
        ----------
        * `maxDataPasses` :  
            The number of passes over the whole training data  
        * `refType` :  
            The refinement indicator (surplus, zero-crossings or data-based)  
        * `refMonitor` :  
            The refinement strategy (periodic or convergence-based)  
        * `refPeriod` :  
            The refinement interval (if periodic refinement is chosen)  
        * `errorDeclineThreshold` :  
            The convergence threshold (if convergence-based refinement is chosen)  
        * `errorDeclineBufferSize` :  
            The number of error measurements which are used to check convergence (if
            convergence-based refinement is chosen)  
        * `minRefInterval` :  
            The minimum number of data points which have to be processed before next
            refinement can be scheduled (if convergence-based refinement is chosen)  

        """
        return _pysgpp_swig.LearnerSGD_train(self, maxDataPasses, refType, refMonitor, refPeriod, errorDeclineThreshold, errorDeclineBufferSize, minRefInterval)

    def getAccuracy(self, testData: "DataMatrix", testLabels: "DataVector", threshold: "double") -> "double":
        r"""


        Computes the classification accuracy on the given dataset.  

        Parameters
        ----------
        * `testData` :  
            The data for which class labels should be predicted  
        * `testLabels` :  
            The corresponding actual class labels  
        * `threshold` :  
            The decision threshold (e.g. for class labels -1, 1 -> threshold = 0)  

        Returns
        -------
        The resulting accuracy  

        """
        return _pysgpp_swig.LearnerSGD_getAccuracy(self, testData, testLabels, threshold)

    def storeResults(self, testDataset: "DataMatrix") -> "void":
        r"""


        Stores classified data, grids and function evaluations to csv files.  

        Parameters
        ----------
        * `testDataset` :  
            Data points for which the model is evaluated  

        """
        return _pysgpp_swig.LearnerSGD_storeResults(self, testDataset)
    error = property(_pysgpp_swig.LearnerSGD_error_get, _pysgpp_swig.LearnerSGD_error_set)
    avgErrors = property(_pysgpp_swig.LearnerSGD_avgErrors_get, _pysgpp_swig.LearnerSGD_avgErrors_set)

# Register LearnerSGD in _pysgpp_swig:
_pysgpp_swig.LearnerSGD_swigregister(LearnerSGD)

class LearnerSVM(object):
    r"""

    `LearnerSVM(gridConfig, adaptConfig, pTrainData, pTrainLabels, pTestData,
        pTestLabels, pValidData, pValidLabels)`  

    LearnerSVM learns the data using support vector machines and sparse grid
    kernels.  

    As learning algorithm the Pegasos-method is implemented.  

    Constructors
    ------------
    * `LearnerSVM(gridConfig, adaptConfig, pTrainData, pTrainLabels, pTestData,
        pTestLabels, pValidData, pValidLabels)`  

        Constructor.  

        Parameters:  
        * `gridConfig` :  
            The grid configuration  
        * `adaptConfig` :  
            The refinement configuration  
        * `pTrainData` :  
            The training dataset  
        * `pTrainLabels` :  
            The corresponding training labels  
        * `pTestData` :  
            The test dataset  
        * `pTestLabels` :  
            The corresponding test labels  
        * `pValidData` :  
            The validation dataset  
        * `pValidLabels` :  
            The corresponding validation labels  

    C++ includes: LearnerSVM.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, gridConfig: "RegularGridConfiguration", adaptConfig: "AdaptivityConfiguration", pTrainData: "DataMatrix", pTrainLabels: "DataVector", pTestData: "DataMatrix", pTestLabels: "DataVector", pValidData: "DataMatrix", pValidLabels: "DataVector"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `gridConfig` :  
            The grid configuration  
        * `adaptConfig` :  
            The refinement configuration  
        * `pTrainData` :  
            The training dataset  
        * `pTrainLabels` :  
            The corresponding training labels  
        * `pTestData` :  
            The test dataset  
        * `pTestLabels` :  
            The corresponding test labels  
        * `pValidData` :  
            The validation dataset  
        * `pValidLabels` :  
            The corresponding validation labels  

        """
        _pysgpp_swig.LearnerSVM_swiginit(self, _pysgpp_swig.new_LearnerSVM(gridConfig, adaptConfig, pTrainData, pTrainLabels, pTestData, pTestLabels, pValidData, pValidLabels))
    __swig_destroy__ = _pysgpp_swig.delete_LearnerSVM

    def initialize(self, budget: "size_t") -> "void":
        r"""


        Initializes the SVM learner.  

        Parameters
        ----------
        * `budget` :  
            The max. number of stored support vectors  

        """
        return _pysgpp_swig.LearnerSVM_initialize(self, budget)

    def train(self, maxDataPasses: "size_t", _lambda: "double", betaRef: "double", refType: "std::string", refMonitor: "std::string", refPeriod: "size_t", errorDeclineThreshold: "double", errorDeclineBufferSize: "size_t", minRefInterval: "size_t") -> "void":
        r"""


        Implements support vector learning with sparse grid kernels.  

        Parameters
        ----------
        * `maxDataPasses` :  
            The number of passes over the whole training data  
        * `lambda` :  
            The regularization parameter  
        * `betaRef` :  
            Weighting factor for grid points; used within combined-measure refinement  
        * `refType` :  
            The refinement indicator (surplus, zero-crossings or data-based)  
        * `refMonitor` :  
            The refinement strategy (periodic or convergence-based)  
        * `refPeriod` :  
            The refinement interval (if periodic refinement is chosen)  
        * `errorDeclineThreshold` :  
            The convergence threshold (if convergence-based refinement is chosen)  
        * `errorDeclineBufferSize` :  
            The number of error measurements which are used to check convergence (if
            convergence-based refinement is chosen)  
        * `minRefInterval` :  
            The minimum number of data points which have to be processed before next
            refinement can be scheduled (if convergence-based refinement is chosen)  

        """
        return _pysgpp_swig.LearnerSVM_train(self, maxDataPasses, _lambda, betaRef, refType, refMonitor, refPeriod, errorDeclineThreshold, errorDeclineBufferSize, minRefInterval)

    def storeResults(self, testDataset: "DataMatrix") -> "void":
        r"""


        Stores classified data, grids and function evaluations to csv files.  

        Parameters
        ----------
        * `testDataset` :  
            Data points for which the model is evaluated  

        """
        return _pysgpp_swig.LearnerSVM_storeResults(self, testDataset)

    def getAccuracy(self, *args) -> "double":
        r"""


        Overloaded function
        -------------------
        * `getAccuracy(referenceLabels, threshold, predictedLabels) -> double`  

            Computes the classification accuracy.  

            Parameters:  
            * `referenceLabels` :  
                The actual class labels  
            * `threshold` :  
                The decision threshold (e.g. for class labels -1, 1 -> threshold = 0)  
            * `predictedLabels` :  
                The predicted class labels  

            Returns:
            The resulting accuracy  

        * `getAccuracy(testDataset, referenceLabels, threshold) -> double`  

            Computes the classification accuracy on the given dataset.  

            Parameters:  
            * `testDataset` :  
                The data for which class labels should be predicted  
            * `referenceLabels` :  
                The corresponding actual class labels  
            * `threshold` :  
                The decision threshold (e.g. for class labels -1, 1 -> threshold = 0)  

            Returns:
            The resulting accuracy  

        """
        return _pysgpp_swig.LearnerSVM_getAccuracy(self, *args)

    def predict(self, testData: "DataMatrix", predictedLabels: "DataVector") -> "void":
        r"""


        Predicts class labels based on the trained model.  

        Parameters
        ----------
        * `testData` :  
            The data for which class labels should be predicted  
        * `predictedLabels` :  
            The predicted class labels  

        """
        return _pysgpp_swig.LearnerSVM_predict(self, testData, predictedLabels)

    def getError(self, data: "DataMatrix", labels: "DataVector", errorType: "std::string") -> "double":
        r"""


        Computes specified error type (e.g.  

        MSE).  

        Parameters
        ----------
        * `data` :  
            The data points  
        * `labels` :  
            The corresponding class labels  
        * `errorType` :  
            The type of the error measurement (MSE or Hinge loss)  

        Returns
        -------
        The error estimation  

        """
        return _pysgpp_swig.LearnerSVM_getError(self, data, labels, errorType)
    error = property(_pysgpp_swig.LearnerSVM_error_get, _pysgpp_swig.LearnerSVM_error_set)
    avgErrors = property(_pysgpp_swig.LearnerSVM_avgErrors_get, _pysgpp_swig.LearnerSVM_avgErrors_set)

# Register LearnerSVM in _pysgpp_swig:
_pysgpp_swig.LearnerSVM_swigregister(LearnerSVM)

class PrimalDualSVM(object):
    r"""

    `PrimalDualSVM(dim, inputDim, budget, useBias)`  

    Implementation of a support vector machine in primal formulation which
    additionally stores support vectors.  

    For non-linear classification, sparse grid kernels are applied.  

    Constructors
    ------------
    * `PrimalDualSVM(dim, inputDim, budget, useBias)`  

        Constructor.  

        Parameters:  
        * `dim` :  
            The dimension of the feature space (i.e. grid size)  
        * `inputDim` :  
            The dimension of the data  
        * `budget` :  
            The max number of support vectors  
        * `useBias` :  
            Indicates whether bias should be used  

    C++ includes: PrimalDualSVM.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dim: "size_t", inputDim: "size_t", budget: "size_t", useBias: "bool"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `dim` :  
            The dimension of the feature space (i.e. grid size)  
        * `inputDim` :  
            The dimension of the data  
        * `budget` :  
            The max number of support vectors  
        * `useBias` :  
            Indicates whether bias should be used  

        """
        _pysgpp_swig.PrimalDualSVM_swiginit(self, _pysgpp_swig.new_PrimalDualSVM(dim, inputDim, budget, useBias))
    __swig_destroy__ = _pysgpp_swig.delete_PrimalDualSVM

    def predictRaw(self, grid: "Grid", x: "DataVector", dataDim: "size_t", trans: "bool"=False) -> "double":
        r"""


        Raw prediction for a given data point and grid.  

        Parameters
        ----------
        * `grid` :  
            The sparse grid which defines the transformation  
        * `x` :  
            The data point  
        * `dataDim` :  
            Dimension of x  
        * `trans` :  
            Indicates whether x is already transformed into feature space  

        Returns
        -------
        The raw prediction value  

        """
        return _pysgpp_swig.PrimalDualSVM_predictRaw(self, grid, x, dataDim, trans)

    def predict(self, grid: "Grid", x: "DataVector", dataDim: "size_t") -> "int":
        r"""


        Class prediction for a given data point and grid.  

        Parameters
        ----------
        * `grid` :  
            The sparse grid which defines the transformation  
        * `x` :  
            The data point  
        * `dataDim` :  
            Dimension of x  

        Returns
        -------
        The predicted class label (-1 or 1)  

        """
        return _pysgpp_swig.PrimalDualSVM_predict(self, grid, x, dataDim)

    def add(self, grid: "Grid", x: "DataVector", alpha: "double", dataDim: "size_t") -> "void":
        r"""


        Adds a data point to the set of support vectors.  

        Parameters
        ----------
        * `grid` :  
            The sparse grid which defines the transformation  
        * `x` :  
            The data point  
        * `alpha` :  
            The corresponding weight  
        * `dataDim` :  
            Dimension of x  

        """
        return _pysgpp_swig.PrimalDualSVM_add(self, grid, x, alpha, dataDim)

    def multiply(self, scalar: "double") -> "void":
        r"""


        Scales the normal vector w.  

        Parameters
        ----------
        * `scalar` :  
            The scaling factor  

        """
        return _pysgpp_swig.PrimalDualSVM_multiply(self, scalar)
    svs = property(_pysgpp_swig.PrimalDualSVM_svs_get, _pysgpp_swig.PrimalDualSVM_svs_set)
    alphas = property(_pysgpp_swig.PrimalDualSVM_alphas_get, _pysgpp_swig.PrimalDualSVM_alphas_set)
    norms = property(_pysgpp_swig.PrimalDualSVM_norms_get, _pysgpp_swig.PrimalDualSVM_norms_set)
    w = property(_pysgpp_swig.PrimalDualSVM_w_get, _pysgpp_swig.PrimalDualSVM_w_set)
    w2 = property(_pysgpp_swig.PrimalDualSVM_w2_get, _pysgpp_swig.PrimalDualSVM_w2_set)

# Register PrimalDualSVM in _pysgpp_swig:
_pysgpp_swig.PrimalDualSVM_swigregister(PrimalDualSVM)

class MultiGridRefinementFunctor(RefinementFunctor):
    r"""


    Abstract super-class for refinement functors operating on multiple grids.  

    C++ includes: MultiGridRefinementFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setGridIndex(self, grid_index: "size_t") -> "void":
        r"""


        Sets the index (into the vector of grids) of the grid to be refined.  

        Parameters
        ----------
        * `grid_index` :  
            The index of the grid to be refined  

        """
        return _pysgpp_swig.MultiGridRefinementFunctor_setGridIndex(self, grid_index)

    def getNumGrids(self) -> "size_t":
        r"""


        Returns the number of grids the functor can / does refine.  

        """
        return _pysgpp_swig.MultiGridRefinementFunctor_getNumGrids(self)

    def preComputeEvaluations(self) -> "void":
        r"""


        Used if expensive computations (eg.  

        grid evaluations) are cached, usually for one refinement step.  

        """
        return _pysgpp_swig.MultiGridRefinementFunctor_preComputeEvaluations(self)
    __swig_destroy__ = _pysgpp_swig.delete_MultiGridRefinementFunctor

# Register MultiGridRefinementFunctor in _pysgpp_swig:
_pysgpp_swig.MultiGridRefinementFunctor_swigregister(MultiGridRefinementFunctor)

class MultiSurplusRefinementFunctor(MultiGridRefinementFunctor):
    r"""

    `MultiSurplusRefinementFunctor(grids, alphas, refinements_num=1,
        level_penalize=false, threshold=0.0)`  

    Wrapper of SurplusRefinementFunctor for multi grid scenarios.  

    Constructors
    ------------
    * `MultiSurplusRefinementFunctor(grids, alphas, refinements_num=1,
        level_penalize=false, threshold=0.0)`  

        Constructor.  

        Parameters:  
        * `grids` :  
            Vector of grids. current_grid_index specifies the grid to be refined  
        * `alphas` :  
            Vector of surpluses related to the grids  
        * `refinements_num` :  
            Maximum number of refinements done  
        * `level_penalize` :  
            If a level penalizing is multiplied to the score. Here, it determines
            whether surplus or volume refinement is used  
        * `threshold` :  
            Threshold for refinement scores  

    C++ includes: MultiSurplusRefinementFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grids: "std::vector< sgpp::base::Grid *,std::allocator< sgpp::base::Grid * > >", alphas: "std::vector< sgpp::base::DataVector *,std::allocator< sgpp::base::DataVector * > >", refinements_num: "size_t"=1, level_penalize: "bool"=False, threshold: "double"=0.0):
        r"""


        Constructor.  

        Parameters
        ----------
        * `grids` :  
            Vector of grids. current_grid_index specifies the grid to be refined  
        * `alphas` :  
            Vector of surpluses related to the grids  
        * `refinements_num` :  
            Maximum number of refinements done  
        * `level_penalize` :  
            If a level penalizing is multiplied to the score. Here, it determines
            whether surplus or volume refinement is used  
        * `threshold` :  
            Threshold for refinement scores  

        """
        _pysgpp_swig.MultiSurplusRefinementFunctor_swiginit(self, _pysgpp_swig.new_MultiSurplusRefinementFunctor(grids, alphas, refinements_num, level_penalize, threshold))
    __swig_destroy__ = _pysgpp_swig.delete_MultiSurplusRefinementFunctor

# Register MultiSurplusRefinementFunctor in _pysgpp_swig:
_pysgpp_swig.MultiSurplusRefinementFunctor_swigregister(MultiSurplusRefinementFunctor)

class ClassificationRefinementFunctor(MultiGridRefinementFunctor):
    r"""

    `ClassificationRefinementFunctor(grids, alphas, priors, refinements_num=1,
        coarsenings_num=1, level_penalize=true,
        thresholdType=sgpp::base::AdaptivityThresholdType::Absolute,
        refinementThreshold=0.0, coarseningThreshold=1.0, coarsenInitialPoints=true,
        minimumCoarseningIndex=0)`  

    Classification refinement builds up the combined grid of all classes, then
    iterates through it always keeping track of the neighbors to detect class
    changes between neighbors.  

    Only the children in the relevant dimension and direction will be added to the
    grid.  

    Constructors
    ------------
    * `ClassificationRefinementFunctor(grids, alphas, priors, refinements_num=1,
        coarsenings_num=1, level_penalize=true,
        thresholdType=sgpp::base::AdaptivityThresholdType::Absolute,
        refinementThreshold=0.0, coarseningThreshold=1.0, coarsenInitialPoints=true,
        minimumCoarseningIndex=0)`  

        Constructor.  

        Parameters:  
        * `grids` :  
            Vector of grids. current_grid_index specifies the grid to be refined  
        * `alphas` :  
            Vector of surpluses related to the grids  
        * `priors` :  
            Vector of priors related to the classificator  
        * `refinements_num` :  
            Maximum number of refinements done  
        * `coarsenings_num` :  
            Maximum number of coarsenings done  
        * `level_penalize` :  
            If a level penalizing is multiplied to the score (2^{|l|_1})  
        * `thresholdType` :  
            type of the threshold: absolute score value or relative score value  
        * `refinementThreshold` :  
            Threshold for refinement scores  
        * `coarseningThreshold` :  
            Threshold for coarsening scores  
        * `coarsenInitialPoints` :  
            Whether or not to coarsen initial grid points  
        * `minimumCoarseningIndex` :  
            Mimimum index of grid points that can be coarsened, used when
            coarsenInitialPoints = false.  

    C++ includes: ClassificationRefinementFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Constructor.  

        Parameters
        ----------
        * `grids` :  
            Vector of grids. current_grid_index specifies the grid to be refined  
        * `alphas` :  
            Vector of surpluses related to the grids  
        * `priors` :  
            Vector of priors related to the classificator  
        * `refinements_num` :  
            Maximum number of refinements done  
        * `coarsenings_num` :  
            Maximum number of coarsenings done  
        * `level_penalize` :  
            If a level penalizing is multiplied to the score (2^{|l|_1})  
        * `thresholdType` :  
            type of the threshold: absolute score value or relative score value  
        * `refinementThreshold` :  
            Threshold for refinement scores  
        * `coarseningThreshold` :  
            Threshold for coarsening scores  
        * `coarsenInitialPoints` :  
            Whether or not to coarsen initial grid points  
        * `minimumCoarseningIndex` :  
            Mimimum index of grid points that can be coarsened, used when
            coarsenInitialPoints = false.  

        """
        _pysgpp_swig.ClassificationRefinementFunctor_swiginit(self, _pysgpp_swig.new_ClassificationRefinementFunctor(*args))
    __swig_destroy__ = _pysgpp_swig.delete_ClassificationRefinementFunctor

    def adaptAllGrids(self) -> "std::vector< std::vector< size_t,std::allocator< size_t > >,std::allocator< std::vector< size_t,std::allocator< size_t > > > >":
        r"""


        Refine and Coarsen all grids of the model.  

        Returns
        -------
        vector that for each class contains a list of indices of deleted grid points  

        """
        return _pysgpp_swig.ClassificationRefinementFunctor_adaptAllGrids(self)

# Register ClassificationRefinementFunctor in _pysgpp_swig:
_pysgpp_swig.ClassificationRefinementFunctor_swigregister(ClassificationRefinementFunctor)

class DataBasedRefinementFunctor(MultiGridRefinementFunctor):
    r"""

    `DataBasedRefinementFunctor(grids, alphas, priors, data, targets,
        refinements_num=1, level_penalize=false, coeff_a=std::vector< double >(),
        threshold=0.0)`  

    Data based refinement uses data points to find refinement candidates.  

    For the given data sets class-intersection sets H_k are computed. A grid points
    is included in H_k if for at least on class l PDF_k(point) > coeff_a_k * mu_k
    AND PDF_l(point) > coeff_a_l * mu_l. To determine the score of a grid point, the
    number of data points from H_k within the support of this grid point is taken  

    Constructors
    ------------
    * `DataBasedRefinementFunctor(grids, alphas, priors, data, targets,
        refinements_num=1, level_penalize=false, coeff_a=std::vector< double >(),
        threshold=0.0)`  

        Constructor.  

        Parameters:  
        * `grids` :  
            Vector of grids. current_grid_index specifies the grid to be refined  
        * `alphas` :  
            Vector of surpluses related to the grids  
        * `priors` :  
            Vector of priors related to the classificator  
        * `data` :  
            The data used to compute the sets H_k  
        * `targets` :  
            The classes for data  
        * `refinements_num` :  
            Maximum number of refinements done  
        * `level_penalize` :  
            If a level penalizing is multiplied to the score (2^{|l|_1})  
        * `coeff_a` :  
            Scaling coefficients for the computation of H_k. Per default 1.0  
        * `threshold` :  
            Threshold for refinement scores  

    C++ includes: DataBasedRefinementFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Constructor.  

        Parameters
        ----------
        * `grids` :  
            Vector of grids. current_grid_index specifies the grid to be refined  
        * `alphas` :  
            Vector of surpluses related to the grids  
        * `priors` :  
            Vector of priors related to the classificator  
        * `data` :  
            The data used to compute the sets H_k  
        * `targets` :  
            The classes for data  
        * `refinements_num` :  
            Maximum number of refinements done  
        * `level_penalize` :  
            If a level penalizing is multiplied to the score (2^{|l|_1})  
        * `coeff_a` :  
            Scaling coefficients for the computation of H_k. Per default 1.0  
        * `threshold` :  
            Threshold for refinement scores  

        """
        _pysgpp_swig.DataBasedRefinementFunctor_swiginit(self, _pysgpp_swig.new_DataBasedRefinementFunctor(*args))
    __swig_destroy__ = _pysgpp_swig.delete_DataBasedRefinementFunctor

    def setData(self, data: "DataMatrix", targets: "DataVector") -> "void":
        r"""


        Set the training data + targets which is the basis for determining relevant data
        points.  

        This method is only necessary in data-streaming scenarios where the training
        data changes overall.  

        Parameters
        ----------
        * `data` :  
            Pointer to the (subset of) training data used  
        * `targets` :  
            Pointer to the related targets  

        """
        return _pysgpp_swig.DataBasedRefinementFunctor_setData(self, data, targets)

    def computeH(self) -> "void":
        r"""


        Recomputes the set of relevant data (the set H).  

        If the training data is changed, call this method to actually re-compute H.
        Might require a lot of time depending on the size of the training data.  

        """
        return _pysgpp_swig.DataBasedRefinementFunctor_computeH(self)

    def getHk(self, index: "size_t") -> "sgpp::base::DataMatrix &":
        r"""


        Returns a ref to the specified H_k, used for debugging /plotting.  

        Parameters
        ----------
        * `index` :  
            The index k for H_k  

        """
        return _pysgpp_swig.DataBasedRefinementFunctor_getHk(self, index)

# Register DataBasedRefinementFunctor in _pysgpp_swig:
_pysgpp_swig.DataBasedRefinementFunctor_swigregister(DataBasedRefinementFunctor)

class GridPointBasedRefinementFunctor(MultiGridRefinementFunctor):
    r"""

    `GridPointBasedRefinementFunctor(grids, alphas, priors, refinements_num=1,
        level_penalize=false, pre_compute=false, threshold=0.0)`  

    Grid Point based refinement for classification problems solved by a SG density
    estimation approach.  

    The scoring is only based on function values of the respective PDF at grid
    points.  

    Constructors
    ------------
    * `GridPointBasedRefinementFunctor(grids, alphas, priors, refinements_num=1,
        level_penalize=false, pre_compute=false, threshold=0.0)`  

        Constructor.  

        Parameters:  
        * `grids` :  
            Vector of grids. current_grid_index specifies the grid to be refined  
        * `alphas` :  
            Vector of surpluses related to the grids  
        * `priors` :  
            Vector of priors related to the classificator  
        * `refinements_num` :  
            Maximum number of refinements done  
        * `level_penalize` :  
            If a level penalizing is multiplied to the score (2^{|l|_1})  
        * `pre_compute` :  
            Flag for precomputation of necessary grid evals. If true
            preComputeEvaluations needs to be called before each refinement step  
        * `threshold` :  
            Threshold for refinement scores  

    C++ includes: GridPointBasedRefinementFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grids: "std::vector< sgpp::base::Grid *,std::allocator< sgpp::base::Grid * > >", alphas: "std::vector< sgpp::base::DataVector *,std::allocator< sgpp::base::DataVector * > >", priors: "DoubleVector", refinements_num: "size_t"=1, level_penalize: "bool"=False, pre_compute: "bool"=False, threshold: "double"=0.0):
        r"""


        Constructor.  

        Parameters
        ----------
        * `grids` :  
            Vector of grids. current_grid_index specifies the grid to be refined  
        * `alphas` :  
            Vector of surpluses related to the grids  
        * `priors` :  
            Vector of priors related to the classificator  
        * `refinements_num` :  
            Maximum number of refinements done  
        * `level_penalize` :  
            If a level penalizing is multiplied to the score (2^{|l|_1})  
        * `pre_compute` :  
            Flag for precomputation of necessary grid evals. If true
            preComputeEvaluations needs to be called before each refinement step  
        * `threshold` :  
            Threshold for refinement scores  

        """
        _pysgpp_swig.GridPointBasedRefinementFunctor_swiginit(self, _pysgpp_swig.new_GridPointBasedRefinementFunctor(grids, alphas, priors, refinements_num, level_penalize, pre_compute, threshold))
    __swig_destroy__ = _pysgpp_swig.delete_GridPointBasedRefinementFunctor

# Register GridPointBasedRefinementFunctor in _pysgpp_swig:
_pysgpp_swig.GridPointBasedRefinementFunctor_swigregister(GridPointBasedRefinementFunctor)

class ZeroCrossingRefinementFunctor(MultiGridRefinementFunctor):
    r"""

    `ZeroCrossingRefinementFunctor(grids, alphas, priors, refinements_num=1,
        level_penalize=false, pre_compute=false, threshold=0.0)`  

    Zero-crossing-based refinement uses zero crossings of the difference PDFS f_1 -
    f_2 to determine areas of interest for the refinement process.  

    The signs of a grid point pair evaluated at two PDFs are compared and only if
    the signs differ (a zero crossing lies between them) are they considered for the
    scoring.  

    The pairs of grid points are geometric neighbors, determined for each dimension
    separately.  

    Constructors
    ------------
    * `ZeroCrossingRefinementFunctor(grids, alphas, priors, refinements_num=1,
        level_penalize=false, pre_compute=false, threshold=0.0)`  

        Constructor.  

        Parameters:  
        * `grids` :  
            Vector of grids. current_grid_index specifies the grid to be refined  
        * `alphas` :  
            Vector of surpluses related to the grids  
        * `priors` :  
            Vector of priors related to the classificator  
        * `refinements_num` :  
            Maximum number of refinements done  
        * `level_penalize` :  
            If a level penalizing is multiplied to the score (2^{|l|_1})  
        * `pre_compute` :  
            Flag for precomputation of necessary grid evals. If true
            preComputeEvaluations needs to be called before each refinement step  
        * `threshold` :  
            Threshold for refinement scores  

    C++ includes: ZeroCrossingRefinementFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grids: "std::vector< sgpp::base::Grid *,std::allocator< sgpp::base::Grid * > >", alphas: "std::vector< sgpp::base::DataVector *,std::allocator< sgpp::base::DataVector * > >", priors: "DoubleVector", refinements_num: "size_t"=1, level_penalize: "bool"=False, pre_compute: "bool"=False, threshold: "double"=0.0):
        r"""


        Constructor.  

        Parameters
        ----------
        * `grids` :  
            Vector of grids. current_grid_index specifies the grid to be refined  
        * `alphas` :  
            Vector of surpluses related to the grids  
        * `priors` :  
            Vector of priors related to the classificator  
        * `refinements_num` :  
            Maximum number of refinements done  
        * `level_penalize` :  
            If a level penalizing is multiplied to the score (2^{|l|_1})  
        * `pre_compute` :  
            Flag for precomputation of necessary grid evals. If true
            preComputeEvaluations needs to be called before each refinement step  
        * `threshold` :  
            Threshold for refinement scores  

        """
        _pysgpp_swig.ZeroCrossingRefinementFunctor_swiginit(self, _pysgpp_swig.new_ZeroCrossingRefinementFunctor(grids, alphas, priors, refinements_num, level_penalize, pre_compute, threshold))
    __swig_destroy__ = _pysgpp_swig.delete_ZeroCrossingRefinementFunctor

# Register ZeroCrossingRefinementFunctor in _pysgpp_swig:
_pysgpp_swig.ZeroCrossingRefinementFunctor_swigregister(ZeroCrossingRefinementFunctor)

class DensityEstimationTypeParser(object):
    r"""


    C++ includes: DensityEstimationTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::datadriven::DensityEstimationType":
        r"""


        Convert strings to values sgpp::datadriven::DensityEstimationType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a
            sgpp::datadriven::DensityEstimationType.  

        Returns
        -------
        the corresponding sgpp::datadriven::DensityEstimationType.  

        """
        return _pysgpp_swig.DensityEstimationTypeParser_parse(input)

    @staticmethod
    def toString(type: "sgpp::datadriven::DensityEstimationType") -> "std::string const &":
        r"""


        generate string representations for values of
        sgpp::datadriven::DensityEstimationType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::datadriven::DensityEstimationType.  

        """
        return _pysgpp_swig.DensityEstimationTypeParser_toString(type)

    def __init__(self):
        _pysgpp_swig.DensityEstimationTypeParser_swiginit(self, _pysgpp_swig.new_DensityEstimationTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_DensityEstimationTypeParser

# Register DensityEstimationTypeParser in _pysgpp_swig:
_pysgpp_swig.DensityEstimationTypeParser_swigregister(DensityEstimationTypeParser)

def DensityEstimationTypeParser_parse(input: "std::string const &") -> "sgpp::datadriven::DensityEstimationType":
    r"""


    Convert strings to values sgpp::datadriven::DensityEstimationType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a
        sgpp::datadriven::DensityEstimationType.  

    Returns
    -------
    the corresponding sgpp::datadriven::DensityEstimationType.  

    """
    return _pysgpp_swig.DensityEstimationTypeParser_parse(input)

def DensityEstimationTypeParser_toString(type: "sgpp::datadriven::DensityEstimationType") -> "std::string const &":
    r"""


    generate string representations for values of
    sgpp::datadriven::DensityEstimationType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::datadriven::DensityEstimationType.  

    """
    return _pysgpp_swig.DensityEstimationTypeParser_toString(type)

class MatrixDecompositionTypeParser(object):
    r"""


    C++ includes: MatrixDecompositionTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::datadriven::MatrixDecompositionType":
        r"""


        Convert strings to values sgpp::datadriven::MatrixDecompositionType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a
            sgpp::datadriven::MatrixDecompositionType.  

        Returns
        -------
        the corresponding sgpp::datadriven::MatrixDecompositionType.  

        """
        return _pysgpp_swig.MatrixDecompositionTypeParser_parse(input)

    @staticmethod
    def toString(type: "sgpp::datadriven::MatrixDecompositionType") -> "std::string const &":
        r"""


        generate string representations for values of
        sgpp::datadriven::MatrixDecompositionType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::datadriven::MatrixDecompositionType.  

        """
        return _pysgpp_swig.MatrixDecompositionTypeParser_toString(type)

    def __init__(self):
        _pysgpp_swig.MatrixDecompositionTypeParser_swiginit(self, _pysgpp_swig.new_MatrixDecompositionTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_MatrixDecompositionTypeParser

# Register MatrixDecompositionTypeParser in _pysgpp_swig:
_pysgpp_swig.MatrixDecompositionTypeParser_swigregister(MatrixDecompositionTypeParser)

def MatrixDecompositionTypeParser_parse(input: "std::string const &") -> "sgpp::datadriven::MatrixDecompositionType":
    r"""


    Convert strings to values sgpp::datadriven::MatrixDecompositionType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a
        sgpp::datadriven::MatrixDecompositionType.  

    Returns
    -------
    the corresponding sgpp::datadriven::MatrixDecompositionType.  

    """
    return _pysgpp_swig.MatrixDecompositionTypeParser_parse(input)

def MatrixDecompositionTypeParser_toString(type: "sgpp::datadriven::MatrixDecompositionType") -> "std::string const &":
    r"""


    generate string representations for values of
    sgpp::datadriven::MatrixDecompositionType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::datadriven::MatrixDecompositionType.  

    """
    return _pysgpp_swig.MatrixDecompositionTypeParser_toString(type)

class RegularizationTypeParser(object):
    r"""


    C++ includes: RegularizationTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::datadriven::RegularizationType":
        r"""


        Convert strings to values sgpp::datadriven::RegularizationType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a
            sgpp::datadriven::RegularizationType.  

        Returns
        -------
        the corresponding sgpp::datadriven::RegularizationType.  

        """
        return _pysgpp_swig.RegularizationTypeParser_parse(input)

    @staticmethod
    def toString(type: "sgpp::datadriven::RegularizationType") -> "std::string const &":
        r"""


        generate string representations for values of
        sgpp::datadriven::RegularizationType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::datadriven::RegularizationType.  

        """
        return _pysgpp_swig.RegularizationTypeParser_toString(type)

    def __init__(self):
        _pysgpp_swig.RegularizationTypeParser_swiginit(self, _pysgpp_swig.new_RegularizationTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_RegularizationTypeParser

# Register RegularizationTypeParser in _pysgpp_swig:
_pysgpp_swig.RegularizationTypeParser_swigregister(RegularizationTypeParser)

def RegularizationTypeParser_parse(input: "std::string const &") -> "sgpp::datadriven::RegularizationType":
    r"""


    Convert strings to values sgpp::datadriven::RegularizationType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a
        sgpp::datadriven::RegularizationType.  

    Returns
    -------
    the corresponding sgpp::datadriven::RegularizationType.  

    """
    return _pysgpp_swig.RegularizationTypeParser_parse(input)

def RegularizationTypeParser_toString(type: "sgpp::datadriven::RegularizationType") -> "std::string const &":
    r"""


    generate string representations for values of
    sgpp::datadriven::RegularizationType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::datadriven::RegularizationType.  

    """
    return _pysgpp_swig.RegularizationTypeParser_toString(type)

DataSourceFileType_NONE = _pysgpp_swig.DataSourceFileType_NONE
DataSourceFileType_ARFF = _pysgpp_swig.DataSourceFileType_ARFF
DataSourceFileType_CSV = _pysgpp_swig.DataSourceFileType_CSV
DataSourceShufflingType_random = _pysgpp_swig.DataSourceShufflingType_random
DataSourceShufflingType_sequential = _pysgpp_swig.DataSourceShufflingType_sequential
class DataSourceConfig(object):
    r"""


    Configuration structure used for all kinds of SampleProviders including default
    values.  

    C++ includes: DataSourceConfig.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    filePath = property(_pysgpp_swig.DataSourceConfig_filePath_get, _pysgpp_swig.DataSourceConfig_filePath_set)
    fileType = property(_pysgpp_swig.DataSourceConfig_fileType_get, _pysgpp_swig.DataSourceConfig_fileType_set)
    isCompressed = property(_pysgpp_swig.DataSourceConfig_isCompressed_get, _pysgpp_swig.DataSourceConfig_isCompressed_set)
    numBatches = property(_pysgpp_swig.DataSourceConfig_numBatches_get, _pysgpp_swig.DataSourceConfig_numBatches_set)
    batchSize = property(_pysgpp_swig.DataSourceConfig_batchSize_get, _pysgpp_swig.DataSourceConfig_batchSize_set)
    validationPortion = property(_pysgpp_swig.DataSourceConfig_validationPortion_get, _pysgpp_swig.DataSourceConfig_validationPortion_set)
    hasTargets = property(_pysgpp_swig.DataSourceConfig_hasTargets_get, _pysgpp_swig.DataSourceConfig_hasTargets_set)
    dataTransformationConfig = property(_pysgpp_swig.DataSourceConfig_dataTransformationConfig_get, _pysgpp_swig.DataSourceConfig_dataTransformationConfig_set)
    shuffling = property(_pysgpp_swig.DataSourceConfig_shuffling_get, _pysgpp_swig.DataSourceConfig_shuffling_set)
    randomSeed = property(_pysgpp_swig.DataSourceConfig_randomSeed_get, _pysgpp_swig.DataSourceConfig_randomSeed_set)
    epochs = property(_pysgpp_swig.DataSourceConfig_epochs_get, _pysgpp_swig.DataSourceConfig_epochs_set)
    readinCutoff = property(_pysgpp_swig.DataSourceConfig_readinCutoff_get, _pysgpp_swig.DataSourceConfig_readinCutoff_set)
    readinClasses = property(_pysgpp_swig.DataSourceConfig_readinClasses_get, _pysgpp_swig.DataSourceConfig_readinClasses_set)
    readinColumns = property(_pysgpp_swig.DataSourceConfig_readinColumns_get, _pysgpp_swig.DataSourceConfig_readinColumns_set)
    testFilePath = property(_pysgpp_swig.DataSourceConfig_testFilePath_get, _pysgpp_swig.DataSourceConfig_testFilePath_set)
    testFileType = property(_pysgpp_swig.DataSourceConfig_testFileType_get, _pysgpp_swig.DataSourceConfig_testFileType_set)
    testHasTargets = property(_pysgpp_swig.DataSourceConfig_testHasTargets_get, _pysgpp_swig.DataSourceConfig_testHasTargets_set)
    testIsCompressed = property(_pysgpp_swig.DataSourceConfig_testIsCompressed_get, _pysgpp_swig.DataSourceConfig_testIsCompressed_set)
    testNumBatches = property(_pysgpp_swig.DataSourceConfig_testNumBatches_get, _pysgpp_swig.DataSourceConfig_testNumBatches_set)
    testBatchSize = property(_pysgpp_swig.DataSourceConfig_testBatchSize_get, _pysgpp_swig.DataSourceConfig_testBatchSize_set)
    testReadinCutoff = property(_pysgpp_swig.DataSourceConfig_testReadinCutoff_get, _pysgpp_swig.DataSourceConfig_testReadinCutoff_set)
    testReadinClasses = property(_pysgpp_swig.DataSourceConfig_testReadinClasses_get, _pysgpp_swig.DataSourceConfig_testReadinClasses_set)
    testReadinColumns = property(_pysgpp_swig.DataSourceConfig_testReadinColumns_get, _pysgpp_swig.DataSourceConfig_testReadinColumns_set)

    def __init__(self):
        _pysgpp_swig.DataSourceConfig_swiginit(self, _pysgpp_swig.new_DataSourceConfig())
    __swig_destroy__ = _pysgpp_swig.delete_DataSourceConfig

# Register DataSourceConfig in _pysgpp_swig:
_pysgpp_swig.DataSourceConfig_swigregister(DataSourceConfig)

class DataShufflingFunctor(object):
    r"""

    `DataShufflingFunctor()`  
    `DataShufflingFunctor(rhs)`  
    `DataShufflingFunctor(rhs)`  

    A class to provide functionality to shuffle (reorder) the data samples before
    the sample provider accesses it.  

    This is neccessary for cross validation and general shuffling of data.  

    Constructors
    ------------
    * `DataShufflingFunctor()`  

    * `DataShufflingFunctor(rhs)`  

    * `DataShufflingFunctor(rhs)`  

    C++ includes: DataShufflingFunctor.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_DataShufflingFunctor

    def clone(self) -> "sgpp::datadriven::DataShufflingFunctor *":
        r"""


        Polymorphic clone pattern.  

        Returns
        -------
        deep copy of this object. New object is owned by caller.  

        """
        return _pysgpp_swig.DataShufflingFunctor_clone(self)

# Register DataShufflingFunctor in _pysgpp_swig:
_pysgpp_swig.DataShufflingFunctor_swigregister(DataShufflingFunctor)

class DataSourceShufflingTypeParser(object):
    r"""


    Convenience class to convert strings to
    sgpp::datadriven::DataSourceShufflingType and generate string representations
    for values of sgpp::datadriven::DataSourceShufflingType.  

    C++ includes: DataSourceShufflingTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::datadriven::DataSourceShufflingType":
        r"""


        Convert strings to values sgpp::datadriven::DataSourceShufflingType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a
            sgpp::datadriven::DataSourceShufflingType.  

        Returns
        -------
        the corresponding sgpp::datadriven::DataSourceShufflingType.  

        """
        return _pysgpp_swig.DataSourceShufflingTypeParser_parse(input)

    @staticmethod
    def toString(type: "sgpp::datadriven::DataSourceShufflingType") -> "std::string const &":
        r"""


        generate string representations for values of
        sgpp::datadriven::DataSourceShufflingType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::datadriven::DataSourceShufflingType.  

        """
        return _pysgpp_swig.DataSourceShufflingTypeParser_toString(type)

    def __init__(self):
        _pysgpp_swig.DataSourceShufflingTypeParser_swiginit(self, _pysgpp_swig.new_DataSourceShufflingTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_DataSourceShufflingTypeParser

# Register DataSourceShufflingTypeParser in _pysgpp_swig:
_pysgpp_swig.DataSourceShufflingTypeParser_swigregister(DataSourceShufflingTypeParser)

def DataSourceShufflingTypeParser_parse(input: "std::string const &") -> "sgpp::datadriven::DataSourceShufflingType":
    r"""


    Convert strings to values sgpp::datadriven::DataSourceShufflingType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a
        sgpp::datadriven::DataSourceShufflingType.  

    Returns
    -------
    the corresponding sgpp::datadriven::DataSourceShufflingType.  

    """
    return _pysgpp_swig.DataSourceShufflingTypeParser_parse(input)

def DataSourceShufflingTypeParser_toString(type: "sgpp::datadriven::DataSourceShufflingType") -> "std::string const &":
    r"""


    generate string representations for values of
    sgpp::datadriven::DataSourceShufflingType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::datadriven::DataSourceShufflingType.  

    """
    return _pysgpp_swig.DataSourceShufflingTypeParser_toString(type)

class DataShufflingFunctorFactory(object):
    r"""

    `DataShufflingFunctorFactory()`  

    Concrete factory to build an instance of sgpp::datadriven::DataShufflingFunctor.  

    Constructors
    ------------
    * `DataShufflingFunctorFactory()`  

        Default constructor.  

    C++ includes: DataShufflingFunctorFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.DataShufflingFunctorFactory_swiginit(self, _pysgpp_swig.new_DataShufflingFunctorFactory())

    def buildDataShufflingFunctor(self, config: "DataSourceConfig") -> "sgpp::datadriven::DataShufflingFunctor *":
        r"""


        Create an instance of a sgpp::datadriven::DataShufflingFunctor object based on
        the configuration.  

        Parameters
        ----------
        * `config` :  
            configuration for the data source  

        Returns
        -------
        Fully configured instance of a sgpp::datadriven::DataShufflingFunctor object.  

        """
        return _pysgpp_swig.DataShufflingFunctorFactory_buildDataShufflingFunctor(self, config)
    __swig_destroy__ = _pysgpp_swig.delete_DataShufflingFunctorFactory

# Register DataShufflingFunctorFactory in _pysgpp_swig:
_pysgpp_swig.DataShufflingFunctorFactory_swigregister(DataShufflingFunctorFactory)

class DataShufflingFunctorRandom(DataShufflingFunctor):
    r"""

    `DataShufflingFunctorRandom(seed=1337)`  

    A simple shuffling functor for data samples that performs a random shuffling of
    the data.  

    A Feistel network is used to compute the permutation of [0...N-1] without linear
    memory complexity.  

    Constructors
    ------------
    * `DataShufflingFunctorRandom(seed=1337)`  

        Standard constructor.  

        Parameters:  
        * `seed` :  
            the seed for the random shuffling (seed == -1 corresponds to a random
            seed)  

    C++ includes: DataShufflingFunctorRandom.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, seed: "int64_t"=1337):
        r"""


        Standard constructor.  

        Parameters
        ----------
        * `seed` :  
            the seed for the random shuffling (seed == -1 corresponds to a random seed)  

        """
        _pysgpp_swig.DataShufflingFunctorRandom_swiginit(self, _pysgpp_swig.new_DataShufflingFunctorRandom(seed))
    __swig_destroy__ = _pysgpp_swig.delete_DataShufflingFunctorRandom

# Register DataShufflingFunctorRandom in _pysgpp_swig:
_pysgpp_swig.DataShufflingFunctorRandom_swigregister(DataShufflingFunctorRandom)

class DataShufflingFunctorSequential(DataShufflingFunctor):
    r"""


    A simple shuffling functor for data samples that performs no shuffling at all,
    i.e.  

    the permutation used is the identity itself.  

    C++ includes: DataShufflingFunctorSequential.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pysgpp_swig.DataShufflingFunctorSequential_swiginit(self, _pysgpp_swig.new_DataShufflingFunctorSequential())
    __swig_destroy__ = _pysgpp_swig.delete_DataShufflingFunctorSequential

# Register DataShufflingFunctorSequential in _pysgpp_swig:
_pysgpp_swig.DataShufflingFunctorSequential_swigregister(DataShufflingFunctorSequential)

class DataShufflingFunctorCrossValidation(DataShufflingFunctor):
    r"""

    `DataShufflingFunctorCrossValidation(crossValidationConfig, shuffling)`  

    A pseudo shuffling functor, that maps indices 0...foldSize-1 to the current fold
    while mapping the other indices sequentially to the rest of the dataset.  

    Another shuffling functor is chained to the results of this functor in order to
    retrieve a real shuffling.  

    Constructors
    ------------
    * `DataShufflingFunctorCrossValidation(crossValidationConfig, shuffling)`  

        Constructor.  

        Parameters:  
        * `crossValidationConfig` :  
            configuration for the cross validation  
        * `shuffling` :  
            the shuffling functor this functor is chained after  

    C++ includes: DataShufflingFunctorCrossValidation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, crossValidationConfig: "CrossvalidationConfiguration", shuffling: "DataShufflingFunctor"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `crossValidationConfig` :  
            configuration for the cross validation  
        * `shuffling` :  
            the shuffling functor this functor is chained after  

        """
        _pysgpp_swig.DataShufflingFunctorCrossValidation_swiginit(self, _pysgpp_swig.new_DataShufflingFunctorCrossValidation(crossValidationConfig, shuffling))

    def setFold(self, fold: "size_t") -> "void":
        r"""


        Set the index of the current fold.  

        Parameters
        ----------
        * `fold` :  
            the index of the current fold  

        """
        return _pysgpp_swig.DataShufflingFunctorCrossValidation_setFold(self, fold)

    def getCurrentFoldSize(self, numSamples: "size_t") -> "size_t":
        r"""


        Returns the size of the fold currently used for validation.  

        Parameters
        ----------
        * `numSamples` :  
            the number of samples in total  

        Returns
        -------
        size of current fold  

        """
        return _pysgpp_swig.DataShufflingFunctorCrossValidation_getCurrentFoldSize(self, numSamples)
    __swig_destroy__ = _pysgpp_swig.delete_DataShufflingFunctorCrossValidation

# Register DataShufflingFunctorCrossValidation in _pysgpp_swig:
_pysgpp_swig.DataShufflingFunctorCrossValidation_swigregister(DataShufflingFunctorCrossValidation)

class SampleProvider(object):
    r"""

    `SampleProvider()`  
    `SampleProvider(rhs)`  
    `SampleProvider(rhs)`  

    SampleProvider is an abstraction for object that provide sample data from
    various sources for example datasets from files (ARFF, CSV) or synthetic
    datasets generated by sampling functions ( Friedmann datasets).  

    Constructors
    ------------
    * `SampleProvider()`  

    * `SampleProvider(rhs)`  

    * `SampleProvider(rhs)`  

    C++ includes: SampleProvider.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SampleProvider

    def clone(self) -> "sgpp::datadriven::SampleProvider *":
        r"""


        Clone pattern for polymorphic cloning (mainly interresting for copy
        constructors).  

        Returns
        -------
        sgpp::datadriven::SampleProvider* pointer to clone of this class. This object is
        owned by the caller.  

        """
        return _pysgpp_swig.SampleProvider_clone(self)

    def getNextSamples(self, howMany: "size_t") -> "sgpp::datadriven::Dataset *":
        r"""


        Lets the user request a certain amount of samples.  

        This functionality is is designed for streaming algorithms where data is
        processed in batches.  

        Parameters
        ----------
        * `howMany` :  
            number requested amount of samples. The amount of actually provided samples
            can be smaller, if there is not sufficient data.  

        Returns
        -------
        sgpp::datadriven::Dataset* Pointer to a new sgpp::datadriven::Dataset object
        containing at most the requested amount of samples. This object is owned by the
        caller.  

        """
        return _pysgpp_swig.SampleProvider_getNextSamples(self, howMany)

    def getAllSamples(self) -> "sgpp::datadriven::Dataset *":
        r"""


        Asks to return all available samples.  

        This functionality is designed for returning all available samples from an
        entire file.  

        Returns
        -------
        sgpp::datadriven::Dataset* Pointer to a new sgpp::datadriven::Dataset object.
        This object is owned by the caller.  

        """
        return _pysgpp_swig.SampleProvider_getAllSamples(self)

    def getDim(self) -> "size_t":
        r"""


        Returns the maximal dimensionality of the data.  

        Returns
        -------
        dimensionality of the sgpp::datadriven::Dataset.  

        """
        return _pysgpp_swig.SampleProvider_getDim(self)

    def getNumSamples(self) -> "size_t":
        r"""


        Returns the number of samples availible or throws if not possible.  

        Returns
        -------
        the number of samples availible  

        """
        return _pysgpp_swig.SampleProvider_getNumSamples(self)

    def reset(self) -> "void":
        r"""


        Resets the state of the sample provider (e.g.  

        to start a new epoch)  

        """
        return _pysgpp_swig.SampleProvider_reset(self)

# Register SampleProvider in _pysgpp_swig:
_pysgpp_swig.SampleProvider_swigregister(SampleProvider)

class FileSampleProvider(SampleProvider):
    r"""


    sgpp::datadriven::FileSampleProvider is an specialization of
    sgpp::datadriven::SampleProvider and provides an interface for all sample
    providers that get their samples from files.  

    C++ includes: FileSampleProvider.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def readFile(self, *args) -> "void":
        r"""


        Read the contents of the file at the given path.  

        Has to throw an exception if file can not be opened or parsed. Results of
        parsing can be optained via sgpp::datadriven::SampleProvider member functions.  

        Parameters
        ----------
        * `filePath` :  
            valid path to an existing file.  
        * `hasTargets` :  
            whether the file has targets (i.e. supervised learning)  
        * `readinCutoff` :  
            data line number after which to stop reading. Default: MAX_UINT - 1  
        * `readinColumns` :  
            specifies a subset of columns (dimensions). Only these columns are read in
            Order sensitive. Default: empty which means all columns are considered  
        * `readinClasses` :  
            specifies a subset of classes. Only data lines with one of these classes is
            read in. Default: empty which means all classes are considered  

        """
        return _pysgpp_swig.FileSampleProvider_readFile(self, *args)

    def readString(self, *args) -> "void":
        r"""


        Read the contents of a string, for example a deflated archive.  

        Has to throw an exception if string can not be parsed. Results of parsing can be
        optained via sgpp::datadriven::SampleProvider member functions.  

        Parameters
        ----------
        * `input` :  
            the raw string input to parse  
        * `hasTargets` :  
            whether the file has targest (i.e. supervised learning)  
        * `readinCutoff` :  
            data line number after which to stop reading. Default: MAX_UINT - 1  
        * `readinColumns` :  
            specifies a subset of columns (dimensions). Only these columns are read in
            Order sensitive. Default: empty which means all columns are considered  
        * `readinClasses` :  
            specifies a subset of classes. Only data lines with one of these classes is
            read in. Default: empty which means all classes are considered  

        """
        return _pysgpp_swig.FileSampleProvider_readString(self, *args)
    __swig_destroy__ = _pysgpp_swig.delete_FileSampleProvider

# Register FileSampleProvider in _pysgpp_swig:
_pysgpp_swig.FileSampleProvider_swigregister(FileSampleProvider)

class ArffFileSampleProvider(FileSampleProvider):
    r"""

    `ArffFileSampleProvider(shuffling=nullptr)`  

    ArffFileSampleProvider allows reading data in ARFF format into a
    sgpp::datadriven::Dataset object.  

    Data can currently be either be a string formatted in ARFF or a file containing
    ARFF data.  

    Constructors
    ------------
    * `ArffFileSampleProvider(shuffling=nullptr)`  

        Default constructor.  

        Parameters:  
        * `shuffling` :  
            functor to permute the training data indexes  

    C++ includes: ArffFileSampleProvider.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, shuffling: "DataShufflingFunctor"=None):
        r"""


        Default constructor.  

        Parameters
        ----------
        * `shuffling` :  
            functor to permute the training data indexes  

        """
        _pysgpp_swig.ArffFileSampleProvider_swiginit(self, _pysgpp_swig.new_ArffFileSampleProvider(shuffling))

    def readFile(self, *args) -> "void":
        r"""


        Open an existing ARFF file, parse it and store its contents inside this class.  

        Throws if file can not be opened or parsed.  

        Parameters
        ----------
        * `filePath` :  
            Path to an existing file.  
        * `hasTargets` :  
            whether the file has targest (i.e. supervised learning)  
        * `readinCutoff` :  
            see FileSampleProvider.hpp  
        * `readinColumns` :  
            see FileSampleProvider.hpp  
        * `readinClasses` :  
            see FileSampleProvider.hpp  

        """
        return _pysgpp_swig.ArffFileSampleProvider_readFile(self, *args)

    def readString(self, *args) -> "void":
        r"""


        Parse contents of a string containing information in ARFF format, parse it and
        store its contents inside this class.  

        Throws if string can not be parsed.  

        Parameters
        ----------
        * `input` :  
            string containing information in ARFF file format  
        * `hasTargets` :  
            whether the file has targest (i.e. supervised learning)  
        * `readinCutoff` :  
            see FileSampleProvider.hpp  
        * `readinColumns` :  
            see FileSampleProvider.hpp  
        * `readinClasses` :  
            see FileSampleProvider.hpp  

        """
        return _pysgpp_swig.ArffFileSampleProvider_readString(self, *args)
    __swig_destroy__ = _pysgpp_swig.delete_ArffFileSampleProvider

# Register ArffFileSampleProvider in _pysgpp_swig:
_pysgpp_swig.ArffFileSampleProvider_swigregister(ArffFileSampleProvider)

class FileSampleDecorator(FileSampleProvider):
    r"""

    `FileSampleDecorator(rhs)`  
    `FileSampleDecorator(rhs)`  
    `FileSampleDecorator(fileSampleProvider)`  

    FileSampleDecorator provides an interface to provide generic manipulations for
    various kinds of sgpp::datadriven::FileSampleProvider using the decorator
    pattern.  

    Using inheritance and deligation we can manipulate input or output of
    sgpp::datadriven::FileSampleProvider member functions in a generic fashion e.g.
    apply decompression of compressed files before passing them to the actual
    sgpp::datadriven::FileSampleProvider without limiting ourselves to a specific
    implementation. Instead we use the decorated object's member functions as a
    black box.  

    Constructors
    ------------
    * `FileSampleDecorator(rhs)`  

    * `FileSampleDecorator(rhs)`  

    * `FileSampleDecorator(fileSampleProvider)`  

        Constructor.  

        Parameters:  
        * `fileSampleProvider` :  
            Pointer to a sgpp::datadriven::FileSampleProvider that will be wrapped
            as a deligate. The decorator will take ownership of this object and take
            care of its destruction.  

    C++ includes: FileSampleDecorator.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_FileSampleDecorator

    def readFile(self, *args) -> "void":
        r"""


        Reads a file's content from a file.  

        Parameters
        ----------
        * `fileName` :  
            path to the file  
        * `hasTargets` :  
            whether the file has targets (i.e. supervised learning)  
        * `readinCutoff` :  
            see FileSampleProvider.hpp  
        * `readinColumns` :  
            see FileSampleProvider.hpp  
        * `readinClasses` :  
            see FileSampleProvider.hpp  

        """
        return _pysgpp_swig.FileSampleDecorator_readFile(self, *args)

    def readString(self, *args) -> "void":
        r"""


        Reads a file's content.  

        Parameters
        ----------
        * `input` :  
            the file's content  
        * `hasTargets` :  
            whether the file has targets (i.e. supervised learning)  
        * `readinCutoff` :  
            see FileSampleProvider.hpp  
        * `readinColumns` :  
            see FileSampleProvider.hpp  
        * `readinClasses` :  
            see FileSampleProvider.hpp  

        """
        return _pysgpp_swig.FileSampleDecorator_readString(self, *args)

# Register FileSampleDecorator in _pysgpp_swig:
_pysgpp_swig.FileSampleDecorator_swigregister(FileSampleDecorator)

class RosenblattTransformationConfig(object):
    r"""


    Configuration structure for Rosenblatt transformation including default values.  

    C++ includes: RosenblattTransformationConfig.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numSamples = property(_pysgpp_swig.RosenblattTransformationConfig_numSamples_get, _pysgpp_swig.RosenblattTransformationConfig_numSamples_set)
    gridLevel = property(_pysgpp_swig.RosenblattTransformationConfig_gridLevel_get, _pysgpp_swig.RosenblattTransformationConfig_gridLevel_set)
    solverMaxIterations = property(_pysgpp_swig.RosenblattTransformationConfig_solverMaxIterations_get, _pysgpp_swig.RosenblattTransformationConfig_solverMaxIterations_set)
    solverEps = property(_pysgpp_swig.RosenblattTransformationConfig_solverEps_get, _pysgpp_swig.RosenblattTransformationConfig_solverEps_set)
    solverThreshold = property(_pysgpp_swig.RosenblattTransformationConfig_solverThreshold_get, _pysgpp_swig.RosenblattTransformationConfig_solverThreshold_set)

    def __init__(self):
        _pysgpp_swig.RosenblattTransformationConfig_swiginit(self, _pysgpp_swig.new_RosenblattTransformationConfig())
    __swig_destroy__ = _pysgpp_swig.delete_RosenblattTransformationConfig

# Register RosenblattTransformationConfig in _pysgpp_swig:
_pysgpp_swig.RosenblattTransformationConfig_swigregister(RosenblattTransformationConfig)

DataTransformationType_NONE = _pysgpp_swig.DataTransformationType_NONE
DataTransformationType_ROSENBLATT = _pysgpp_swig.DataTransformationType_ROSENBLATT
class DataTransformationConfig(object):
    r"""


    C++ includes: DataTransformationConfig.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_pysgpp_swig.DataTransformationConfig_type_get, _pysgpp_swig.DataTransformationConfig_type_set)
    rosenblattConfig = property(_pysgpp_swig.DataTransformationConfig_rosenblattConfig_get, _pysgpp_swig.DataTransformationConfig_rosenblattConfig_set)

    def __init__(self):
        _pysgpp_swig.DataTransformationConfig_swiginit(self, _pysgpp_swig.new_DataTransformationConfig())
    __swig_destroy__ = _pysgpp_swig.delete_DataTransformationConfig

# Register DataTransformationConfig in _pysgpp_swig:
_pysgpp_swig.DataTransformationConfig_swigregister(DataTransformationConfig)

class DataTransformation(object):
    r"""

    `DataTransformation()`  

    DataTransformation is an abstraction for an object that provides different
    transformations on datasets, for example Rosenblatt-transformation to get a
    uniform distribution over the unit cube.  

    Constructors
    ------------
    * `DataTransformation()`  

        Default constructor.  

    C++ includes: DataTransformation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_DataTransformation

    def initialize(self, dataset: "Dataset", config: "DataTransformationConfig") -> "void":
        r"""


        Initializes a data transformation for a given dataset according to the specified
        config.  

        Parameters
        ----------
        * `dataset` :  
            pointer to the dataset to be initialized  
        * `config` :  
            configuration containing parameters for initalization  

        """
        return _pysgpp_swig.DataTransformation_initialize(self, dataset, config)

    def doTransformation(self, dataset: "Dataset") -> "sgpp::datadriven::Dataset *":
        r"""


        Performs a data transformation on a given dataset for a data transformationn
        built with DataTransformationBuilder.  

        Parameters
        ----------
        * `dataset` :  
            pointer to the dataset to be transformed  

        Returns
        -------
        pointer to the transformed dataset  

        """
        return _pysgpp_swig.DataTransformation_doTransformation(self, dataset)

    def doInverseTransformation(self, dataset: "Dataset") -> "sgpp::datadriven::Dataset *":
        r"""


        Performs the backwards transformation on a given dataset for a data
        transformationn built with DataTransformationBuilder.  

        Parameters
        ----------
        * `dataset` :  
            pointer to the dataset to be transformed backwards  

        Returns
        -------
        pointer to the backwards transformed dataset  

        """
        return _pysgpp_swig.DataTransformation_doInverseTransformation(self, dataset)

# Register DataTransformation in _pysgpp_swig:
_pysgpp_swig.DataTransformation_swigregister(DataTransformation)

class DataTransformationTypeParser(object):
    r"""


    Convenience class to convert strings to sgpp::datadriven::DataTransformationType
    and generate string representations for values of
    sgpp::datadriven::DataTransformationType.  

    C++ includes: DataTransformationTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::datadriven::DataTransformationType":
        r"""


        Convert strings to values sgpp::datadriven::DataTransformationType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a
            sgpp::datadriven::DataTransformationType.  

        Returns
        -------
        the corresponding sgpp::datadriven::DataTransformationType.  

        """
        return _pysgpp_swig.DataTransformationTypeParser_parse(input)

    @staticmethod
    def toString(type: "sgpp::datadriven::DataTransformationType") -> "std::string const &":
        r"""


        Generate string representations for values of
        sgpp::datadriven::DataTransformationType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::datadriven::DataTransformationType.  

        """
        return _pysgpp_swig.DataTransformationTypeParser_toString(type)

    def __init__(self):
        _pysgpp_swig.DataTransformationTypeParser_swiginit(self, _pysgpp_swig.new_DataTransformationTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_DataTransformationTypeParser

# Register DataTransformationTypeParser in _pysgpp_swig:
_pysgpp_swig.DataTransformationTypeParser_swigregister(DataTransformationTypeParser)

def DataTransformationTypeParser_parse(input: "std::string const &") -> "sgpp::datadriven::DataTransformationType":
    r"""


    Convert strings to values sgpp::datadriven::DataTransformationType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a
        sgpp::datadriven::DataTransformationType.  

    Returns
    -------
    the corresponding sgpp::datadriven::DataTransformationType.  

    """
    return _pysgpp_swig.DataTransformationTypeParser_parse(input)

def DataTransformationTypeParser_toString(type: "sgpp::datadriven::DataTransformationType") -> "std::string const &":
    r"""


    Generate string representations for values of
    sgpp::datadriven::DataTransformationType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::datadriven::DataTransformationType.  

    """
    return _pysgpp_swig.DataTransformationTypeParser_toString(type)

class RosenblattTransformation(DataTransformation):
    r"""

    `RosenblattTransformation()`  

    Constructors
    ------------
    * `RosenblattTransformation()`  

        Default constructor.  

    C++ includes: RosenblattTransformation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.RosenblattTransformation_swiginit(self, _pysgpp_swig.new_RosenblattTransformation())

    def createSGDELearner(self, dim: "size_t", config: "RosenblattTransformationConfig") -> "sgpp::datadriven::LearnerSGDE":
        r"""


        Helper function It configures and creates a SGDE learner with meaningful
        parameters.  

        """
        return _pysgpp_swig.RosenblattTransformation_createSGDELearner(self, dim, config)
    __swig_destroy__ = _pysgpp_swig.delete_RosenblattTransformation

# Register RosenblattTransformation in _pysgpp_swig:
_pysgpp_swig.RosenblattTransformation_swigregister(RosenblattTransformation)

class DataSource(object):
    r"""

    `DataSource(config, sampleProvider)`  

    DataSource is a high level, easy to use interface for accessing data provided by
    a all kinds of sgpp::datadriven::SampleProvider.  

    Should be used by end users.  

    Constructors
    ------------
    * `DataSource(config, sampleProvider)`  

        Constructor.  

        Parameters:  
        * `config` :  
            configuration object used for the data source  
        * `sampleProvider` :  
            the sample provider to operate on.  

    C++ includes: DataSource.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_DataSource

    def getConfig(self) -> "sgpp::datadriven::DataSourceConfig const &":
        r"""


        Read only access to the configuration used by DataSource and underlying
        SampleProvider.  

        Returns
        -------
        Current configuration object.  

        """
        return _pysgpp_swig.DataSource_getConfig(self)

    def getNextSamples(self) -> "sgpp::datadriven::Dataset *":
        r"""


        Request data from the underlying SampleProvider as specified in the provided
        configuration object upon construction.  

        Returns
        -------
        sgpp::datadriven::Dataset containing requested amount of samples (if available).  

        """
        return _pysgpp_swig.DataSource_getNextSamples(self)

    def getAllSamples(self) -> "sgpp::datadriven::Dataset *":
        r"""


        Request all data from the underlying SampleProvider object upon construction.  

        Returns
        -------
        sgpp::datadriven::Dataset containing requested amount of samples (if available).  

        """
        return _pysgpp_swig.DataSource_getAllSamples(self)

    def getCurrentIteration(self) -> "size_t":
        r"""


        Return how many batches have already been requested from this DataSource.  

        Required for range based for loops using the DataSourceIterator.  

        Returns
        -------
        the amount of batches that have already been requested.  

        """
        return _pysgpp_swig.DataSource_getCurrentIteration(self)

    def getValidationData(self) -> "sgpp::datadriven::Dataset *":
        r"""


        Returns the data that is used for validation.  

        Returns
        -------
        pointer to the validation dataset  

        """
        return _pysgpp_swig.DataSource_getValidationData(self)

# Register DataSource in _pysgpp_swig:
_pysgpp_swig.DataSource_swigregister(DataSource)

class DataSourceSplitting(DataSource):
    r"""

    `DataSourceSplitting(config, sampleProvider)`  

    DataSourceSlitting is a high level interface to provide functionality for
    processing data epoch-wise with a validation set that is retrieved at
    initialization time using the first samples the sample provider provides.  

    Constructors
    ------------
    * `DataSourceSplitting(config, sampleProvider)`  

        Constructor.  

        Parameters:  
        * `config` :  
            configuration object used for the data source  
        * `sampleProvider` :  
            the sample provider to operate on.  

    C++ includes: DataSourceSplitting.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, config: "DataSourceConfig", sampleProvider: "SampleProvider"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `config` :  
            configuration object used for the data source  
        * `sampleProvider` :  
            the sample provider to operate on.  

        """
        _pysgpp_swig.DataSourceSplitting_swiginit(self, _pysgpp_swig.new_DataSourceSplitting(config, sampleProvider))

    def reset(self) -> "void":
        r"""


        Resets the state of the the sample provider to begin a new training epoch.  

        """
        return _pysgpp_swig.DataSourceSplitting_reset(self)
    __swig_destroy__ = _pysgpp_swig.delete_DataSourceSplitting

# Register DataSourceSplitting in _pysgpp_swig:
_pysgpp_swig.DataSourceSplitting_swigregister(DataSourceSplitting)

class DataSourceCrossValidation(DataSource):
    r"""

    `DataSourceCrossValidation(dataSourceConfig, crossValidationconfig, shuffling,
        sampleProvider)`  

    DataSourceCrossValidation is a high level interface to provide functionality for
    processing data using a cross validation enviroment.  

    That is retrieving a certain fold for validation and the rest of the data for
    training. Note that memory-wise this is very costly and not tractable for large
    data.  

    Constructors
    ------------
    * `DataSourceCrossValidation(dataSourceConfig, crossValidationconfig, shuffling,
        sampleProvider)`  

        Constructor.  

        Parameters:  
        * `dataSourceConfig` :  
            configuration of the data source  
        * `crossValidationconfig` :  
            configuration of the cross validation  
        * `shuffling` :  
            cross validation shuffling that is used by the sample provider instance  
        * `sampleProvider` :  
            the sample provider to operate on.  

    C++ includes: DataSourceCrossValidation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dataSourceConfig: "DataSourceConfig", crossValidationconfig: "CrossvalidationConfiguration", shuffling: "DataShufflingFunctorCrossValidation", sampleProvider: "SampleProvider"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `dataSourceConfig` :  
            configuration of the data source  
        * `crossValidationconfig` :  
            configuration of the cross validation  
        * `shuffling` :  
            cross validation shuffling that is used by the sample provider instance  
        * `sampleProvider` :  
            the sample provider to operate on.  

        """
        _pysgpp_swig.DataSourceCrossValidation_swiginit(self, _pysgpp_swig.new_DataSourceCrossValidation(dataSourceConfig, crossValidationconfig, shuffling, sampleProvider))

    def setFold(self, foldIdx: "size_t") -> "void":
        r"""


        Sets the next fold idx to be used for cross validation.  

        Parameters
        ----------
        * `foldIdx` :  
            index of the fold  

        """
        return _pysgpp_swig.DataSourceCrossValidation_setFold(self, foldIdx)

    def reset(self) -> "void":
        r"""


        Resets the state of the the sample provider to begin a new training epoch.  

        """
        return _pysgpp_swig.DataSourceCrossValidation_reset(self)

    def getCrossValidationConfig(self) -> "sgpp::datadriven::CrossvalidationConfiguration const &":
        r"""


        Gets the configuration for the cross validation.  

        Returns
        -------
        configuration for the cross validation  

        """
        return _pysgpp_swig.DataSourceCrossValidation_getCrossValidationConfig(self)
    __swig_destroy__ = _pysgpp_swig.delete_DataSourceCrossValidation

# Register DataSourceCrossValidation in _pysgpp_swig:
_pysgpp_swig.DataSourceCrossValidation_swigregister(DataSourceCrossValidation)

FitterType_RegressionLeastSquares = _pysgpp_swig.FitterType_RegressionLeastSquares
FitterType_DensityEstimation = _pysgpp_swig.FitterType_DensityEstimation
FitterType_Classification = _pysgpp_swig.FitterType_Classification
class FitterConfiguration(object):
    r"""

    `FitterConfiguration()`  
    `FitterConfiguration(rhs)`  
    `FitterConfiguration(rhs)`  

    General configuration object for fitters.  

    Bundles all structures needed to build a sparse grid, fit a sparse grid based
    model, and perform adaptive refinement.  

    Constructors
    ------------
    * `FitterConfiguration()`  

        Sets up a Fitter configuration with its default values.  

    * `FitterConfiguration(rhs)`  

        Copy constructor.  

        Parameters:  
        * `rhs` :  
            const reference to the scorer object to copy from.  

    * `FitterConfiguration(rhs)`  

        Move constructor.  

        Parameters:  
        * `rhs` :  
            R-value reference to a scorer object to moved from.  

    C++ includes: FitterConfiguration.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_FitterConfiguration

    def clone(self) -> "sgpp::datadriven::FitterConfiguration *":
        r"""


        Polymorphic clone pattern.  

        Returns
        -------
        deep copy of this object. New object is owned by caller.  

        """
        return _pysgpp_swig.FitterConfiguration_clone(self)

    def getDatabaseConfig(self) -> "sgpp::datadriven::DatabaseConfiguration const &":
        r"""


        Returns the database configuration, i.e.  

        the filepath  

        Returns
        -------
        immutable DatabaseConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getDatabaseConfig(self)

    def getLearnerConfig(self) -> "sgpp::datadriven::LearnerConfiguration const &":
        r"""


        Returns the configuration for the learner's behaviour.  

        Returns
        -------
        immutable LearnerConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getLearnerConfig(self)

    def getParallelConfig(self) -> "sgpp::datadriven::ParallelConfiguration const &":
        r"""


        Returns the configuration for parallelization with ScaLAPACK.  

        Returns
        -------
        immutable ParallelConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getParallelConfig(self)

    def getGeometryConfig(self) -> "sgpp::datadriven::GeometryConfiguration const &":
        r"""


        """
        return _pysgpp_swig.FitterConfiguration_getGeometryConfig(self)

    def getGridConfig(self, *args) -> "sgpp::base::GeneralGridConfiguration &":
        r"""


        Overloaded function
        -------------------
        * `getGridConfig() -> base::GeneralGridConfiguration &`  

            Get or set initial conditions for the grid before adaptive refinement.  

            Returns:
            GeneralGridConfiguration  

        * `getGridConfig() -> const base::GeneralGridConfiguration &`  

            Get initial conditions for the grid before adaptive refinement.  

            Returns:
            immutable GeneralGridConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getGridConfig(self, *args)

    def getRefinementConfig(self, *args) -> "sgpp::base::AdaptivityConfiguration &":
        r"""


        Overloaded function
        -------------------
        * `getRefinementConfig() -> base::AdaptivityConfiguration &`  

            Get or set how the adaptivity algorithms for the grid should behave.  

            Returns:
            AdaptivityConfiguration  

        * `getRefinementConfig() -> const base::AdaptivityConfiguration &`  

            Get how the adaptivity algorithms for the grid should behave.  

            Returns:
            immutable AdaptivityConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getRefinementConfig(self, *args)

    def getCrossvalidationConfig(self, *args) -> "sgpp::datadriven::CrossvalidationConfiguration &":
        r"""


        Overloaded function
        -------------------
        * `getCrossvalidationConfig() -> datadriven::CrossvalidationConfiguration &`  

            Get or set how the crossvalidation should behave.  

            Returns:
            CrossvalidationConfiguration  

        * `getCrossvalidationConfig() -> const datadriven::CrossvalidationConfiguration
            &`  

            Get how the crossvalidation should behave.  

            Returns:
            immutable CrossvalidationConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getCrossvalidationConfig(self, *args)

    def getDensityEstimationConfig(self, *args) -> "sgpp::datadriven::DensityEstimationConfiguration &":
        r"""


        Overloaded function
        -------------------
        * `getDensityEstimationConfig() -> datadriven::DensityEstimationConfiguration &`  

            Get or set how the density estimation should behave.  

            Returns:
            DensityEstimationConfiguration  

        * `getDensityEstimationConfig() -> const
            datadriven::DensityEstimationConfiguration &`  

            Get how the density estimation should behave.  

            Returns:
            immutable DensityEstimationConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getDensityEstimationConfig(self, *args)

    def getSolverRefineConfig(self, *args) -> "sgpp::solver::SLESolverConfiguration &":
        r"""


        Overloaded function
        -------------------
        * `getSolverRefineConfig() -> solver::SLESolverConfiguration &`  

            Get or set configuration for the linear system solver which should be used
            while building adaptive grids.  

            Returns:
            SLESolverConfiguration  

        * `getSolverRefineConfig() -> const solver::SLESolverConfiguration &`  

            Get configuration for the linear system solver which should be used while
            building adaptive grids.  

            Returns:
            immutable SLESolverConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getSolverRefineConfig(self, *args)

    def getSolverFinalConfig(self, *args) -> "sgpp::solver::SLESolverConfiguration &":
        r"""


        Overloaded function
        -------------------
        * `getSolverFinalConfig() -> solver::SLESolverConfiguration &`  

            Get or set configuration for the linear system solver when solving the
            final, refined system.  

            Returns:
            SLESolverConfiguration  

        * `getSolverFinalConfig() -> const solver::SLESolverConfiguration &`  

            Get configuration for the linear system solver when solving the final,
            refined system.  

            Returns:
            immutable SLESolverConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getSolverFinalConfig(self, *args)

    def getRegularizationConfig(self, *args) -> "sgpp::datadriven::RegularizationConfiguration &":
        r"""


        Overloaded function
        -------------------
        * `getRegularizationConfig() -> datadriven::RegularizationConfiguration &`  

            Get or set the type of regularization operation to use.  

            Returns:
            RegularizationConfiguration  

        * `getRegularizationConfig() -> const datadriven::RegularizationConfiguration &`  

            Get the type of regularization operation to use.  

            Returns:
            immutable RegularizationConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getRegularizationConfig(self, *args)

    def getMultipleEvalConfig(self, *args) -> "sgpp::datadriven::OperationMultipleEvalConfiguration &":
        r"""


        Overloaded function
        -------------------
        * `getMultipleEvalConfig() -> datadriven::OperationMultipleEvalConfiguration &`  

            Get or set implementation (openMP, MPI, GPU) that should be used for
            #sgpp::base::OperationMultipleEval.  

            Returns:
            current OperationMultipleEvalConfiguration  

        * `getMultipleEvalConfig() -> const
            datadriven::OperationMultipleEvalConfiguration &`  

            Get implementation (openMP, MPI, GPU) that should be used for
            #sgpp::base::OperationMultipleEval.  

            Returns:
            immutable OperationMultipleEvalConfiguration  

        """
        return _pysgpp_swig.FitterConfiguration_getMultipleEvalConfig(self, *args)

    def setupDefaults(self) -> "void":
        r"""


        set default values for all members based on the desired scenario.  

        """
        return _pysgpp_swig.FitterConfiguration_setupDefaults(self)

    def readParams(self, parser: "sgpp::datadriven::DataMiningConfigParser const &") -> "void":
        r"""


        obtain parameters from a parser  

        Parameters
        ----------
        * `parser` :  
            the parser object to read from  

        """
        return _pysgpp_swig.FitterConfiguration_readParams(self, parser)

# Register FitterConfiguration in _pysgpp_swig:
_pysgpp_swig.FitterConfiguration_swigregister(FitterConfiguration)

class FitterConfigurationLeastSquares(FitterConfiguration):
    r"""

    `FitterConfigurationLeastSquares()`  

    Configuration for fitter scenarios using least squares optimization.  

    Constructors
    ------------
    * `FitterConfigurationLeastSquares()`  

    C++ includes: FitterConfigurationLeastSquares.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        """
        _pysgpp_swig.FitterConfigurationLeastSquares_swiginit(self, _pysgpp_swig.new_FitterConfigurationLeastSquares())
    __swig_destroy__ = _pysgpp_swig.delete_FitterConfigurationLeastSquares

# Register FitterConfigurationLeastSquares in _pysgpp_swig:
_pysgpp_swig.FitterConfigurationLeastSquares_swigregister(FitterConfigurationLeastSquares)

class FitterConfigurationDensityEstimation(FitterConfiguration):
    r"""

    `FitterConfigurationDensityEstimation()`  

    Configuration for fitter scenarios using density estimation.  

    Constructors
    ------------
    * `FitterConfigurationDensityEstimation()`  

    C++ includes: FitterConfigurationDensityEstimation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        """
        _pysgpp_swig.FitterConfigurationDensityEstimation_swiginit(self, _pysgpp_swig.new_FitterConfigurationDensityEstimation())
    __swig_destroy__ = _pysgpp_swig.delete_FitterConfigurationDensityEstimation

# Register FitterConfigurationDensityEstimation in _pysgpp_swig:
_pysgpp_swig.FitterConfigurationDensityEstimation_swigregister(FitterConfigurationDensityEstimation)

class FitterConfigurationClassification(FitterConfigurationDensityEstimation):
    r"""

    `FitterConfigurationClassification()`  

    Configuration for fitter scenarios using classification.  

    Constructors
    ------------
    * `FitterConfigurationClassification()`  

    C++ includes: FitterConfigurationClassification.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        """
        _pysgpp_swig.FitterConfigurationClassification_swiginit(self, _pysgpp_swig.new_FitterConfigurationClassification())
    __swig_destroy__ = _pysgpp_swig.delete_FitterConfigurationClassification

# Register FitterConfigurationClassification in _pysgpp_swig:
_pysgpp_swig.FitterConfigurationClassification_swigregister(FitterConfigurationClassification)

class FitterTypeParser(object):
    r"""


    Convenience class to convert strings to sgpp::datadriven::FitterType and
    generate string representations for values of sgpp::datadriven::FitterType.  

    C++ includes: FitterTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::datadriven::FitterType":
        r"""


        Convert strings to values sgpp::datadriven::FitterType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a sgpp::datadriven::FitterType.  

        Returns
        -------
        the corresponding sgpp::datadriven::FitterType.  

        """
        return _pysgpp_swig.FitterTypeParser_parse(input)

    @staticmethod
    def toString(type: "sgpp::datadriven::FitterType") -> "std::string const &":
        r"""


        generate string representations for values of
        sgpp::datadriven::ScorerMetricType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::datadriven::FitterType.  

        """
        return _pysgpp_swig.FitterTypeParser_toString(type)

    def __init__(self):
        _pysgpp_swig.FitterTypeParser_swiginit(self, _pysgpp_swig.new_FitterTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_FitterTypeParser

# Register FitterTypeParser in _pysgpp_swig:
_pysgpp_swig.FitterTypeParser_swigregister(FitterTypeParser)

def FitterTypeParser_parse(input: "std::string const &") -> "sgpp::datadriven::FitterType":
    r"""


    Convert strings to values sgpp::datadriven::FitterType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a sgpp::datadriven::FitterType.  

    Returns
    -------
    the corresponding sgpp::datadriven::FitterType.  

    """
    return _pysgpp_swig.FitterTypeParser_parse(input)

def FitterTypeParser_toString(type: "sgpp::datadriven::FitterType") -> "std::string const &":
    r"""


    generate string representations for values of
    sgpp::datadriven::ScorerMetricType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::datadriven::FitterType.  

    """
    return _pysgpp_swig.FitterTypeParser_toString(type)

class ModelFittingBase(object):
    r"""

    `ModelFittingBase()`  
    `ModelFittingBase(rhs)`  
    `ModelFittingBase(rhs)`  

    Base class for arbitrary machine learning models based on adaptive sparse grids.  

    A model tries to generalize high dimensional training data by using sparse
    grids. An underlying model can be trained using training data, its accuracy can
    be improved by using the adaptivity of sparse grids and the underlying grid(s)
    of a model can be retrained on other data. Once a model is trained it can be
    evaluated on unseen data.  

    Constructors
    ------------
    * `ModelFittingBase()`  

        Default constructor.  

    * `ModelFittingBase(rhs)`  

        Copy constructor - we cannot deep copy all member variables yet.  

        Parameters:  
        * `rhs` :  
            const reference to the scorer object to copy from.  

    * `ModelFittingBase(rhs)`  

        Move constructor.  

        Parameters:  
        * `rhs` :  
            R-value reference to a scorer object to moved from.  

    C++ includes: ModelFittingBase.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_ModelFittingBase

    def fit(self, dataset: "Dataset") -> "void":
        r"""


        Polymorphic clone pattern.  

        Returns
        -------
        deep copy of this object. New object is owned by caller. Fit the grid to the
        dataset by determinig the weights of an initial grid  

        Parameters
        ----------
        * `dataset` :  
            the training dataset that is used to fit the model.  

        """
        return _pysgpp_swig.ModelFittingBase_fit(self, dataset)

    def adapt(self) -> "bool":
        r"""


        Improve accuracy of the model on the given training data by adaptive refinement
        or coarsening of the grid.  

        Returns
        -------
        true if refinement or coarsening was performed, else false.  

        """
        return _pysgpp_swig.ModelFittingBase_adapt(self)

    def update(self, dataset: "Dataset") -> "void":
        r"""


        Train the grid of an existing model with new samples.  

        Parameters
        ----------
        * `dataset` :  
            the training dataset that is used to fit the model.  

        """
        return _pysgpp_swig.ModelFittingBase_update(self, dataset)

    def evaluate(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `evaluate(sample) -> double`  

            Evaluate the fitted model at a single data point.  

            Parameters:  
            * `sample` :  
                vector with the coordinates in all dimensions of that sample.  

            Returns:
            evaluation of the model.  

        * `evaluate(samples, results)`  

            Evaluate the fitted model on a set of data points.  

            Parameters:  
            * `samples` :  
                matrix where each row represents a sample and the columns contain the
                coordinates in all dimensions of that sample.  
            * `results` :  
                vector where each row will contain the evaluation of the respective
                sample on the current model.  

        """
        return _pysgpp_swig.ModelFittingBase_evaluate(self, *args)

    def computeResidual(self, validationData: "DataMatrix") -> "double":
        r"""


        Should compute some kind of Residual to evaluate the fit of the model.  

        In the case of density estimation, this is || R * alpha_lambda - b_val ||_2  

        This is useful for unsupervised learning models, where normal evaluation cannot
        be used as there are no targets.  

        Parameters
        ----------
        * `validationData` :  
            Matrix for validation data  

        Returns
        -------
        the residual score  

        """
        return _pysgpp_swig.ModelFittingBase_computeResidual(self, validationData)

    def updateRegularization(self, _lambda: "double") -> "void":
        r"""


        Updates the regularization parameter lambda of the underlying model.  

        Parameters
        ----------
        * `lambda` :  
            the new lambda parameter  

        """
        return _pysgpp_swig.ModelFittingBase_updateRegularization(self, _lambda)

    def reset(self) -> "void":
        r"""


        Resets the state of the entire model.  

        """
        return _pysgpp_swig.ModelFittingBase_reset(self)

    def resetTraining(self) -> "void":
        r"""


        Resets any trained representations of the model, but does not reset the entire
        state.  

        """
        return _pysgpp_swig.ModelFittingBase_resetTraining(self)

    def getProcessGrid(self) -> "std::shared_ptr< sgpp::datadriven::BlacsProcessGrid >":
        r"""


        Returns
        -------
        the BLACS process grid, useful if the fitter uses ScaLAPACK  

        """
        return _pysgpp_swig.ModelFittingBase_getProcessGrid(self)

    def getFitterConfiguration(self, *args) -> "sgpp::datadriven::FitterConfiguration &":
        r"""


        Overloaded function
        -------------------
        * `getFitterConfiguration() -> FitterConfiguration &`  

            Get or set the configuration of the fitter object.  

            Returns:
            configuration of the fitter object  

        * `getFitterConfiguration() -> const FitterConfiguration &`  

            Get the configuration of the fitter object.  

            Returns:
            configuration of the fitter object  

        """
        return _pysgpp_swig.ModelFittingBase_getFitterConfiguration(self, *args)
    verboseSolver = property(_pysgpp_swig.ModelFittingBase_verboseSolver_get, _pysgpp_swig.ModelFittingBase_verboseSolver_set)

    def getDataset(self) -> "sgpp::datadriven::Dataset *":
        r"""


        """
        return _pysgpp_swig.ModelFittingBase_getDataset(self)

# Register ModelFittingBase in _pysgpp_swig:
_pysgpp_swig.ModelFittingBase_swigregister(ModelFittingBase)

class ModelFittingBaseSingleGrid(ModelFittingBase):
    r"""

    `ModelFittingBaseSingleGrid()`  
    `ModelFittingBaseSingleGrid(rhs)`  
    `ModelFittingBaseSingleGrid(rhs)`  

    Base class for models operating on a single grid (i.e.  

    Least-Squares-Regression and density estimation  

    Constructors
    ------------
    * `ModelFittingBaseSingleGrid()`  

        Default constructor.  

    * `ModelFittingBaseSingleGrid(rhs)`  

        Copy constructor - we cannot deep copy all member variables yet.  

        Parameters:  
        * `rhs` :  
            const reference to the scorer object to copy from.  

    * `ModelFittingBaseSingleGrid(rhs)`  

        Move constructor.  

        Parameters:  
        * `rhs` :  
            R-value reference to a scorer object to moved from.  

    C++ includes: ModelFittingBaseSingleGrid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_ModelFittingBaseSingleGrid

    def getGrid(self) -> "sgpp::datadriven::Grid &":
        r"""


        Get the underlying grid object for the current model.  

        Returns
        -------
        the grid object.  

        """
        return _pysgpp_swig.ModelFittingBaseSingleGrid_getGrid(self)

    def getSurpluses(self) -> "sgpp::datadriven::DataVector &":
        r"""


        Get the surpluses of the current grid.  

        Returns
        -------
        vector of surpluses.  

        """
        return _pysgpp_swig.ModelFittingBaseSingleGrid_getSurpluses(self)

    def storeFitter(self) -> "std::string":
        r"""


        """
        return _pysgpp_swig.ModelFittingBaseSingleGrid_storeFitter(self)

# Register ModelFittingBaseSingleGrid in _pysgpp_swig:
_pysgpp_swig.ModelFittingBaseSingleGrid_swigregister(ModelFittingBaseSingleGrid)

class ModelFittingLeastSquares(ModelFittingBaseSingleGrid):
    r"""

    `ModelFittingLeastSquares(config)`  

    Fitter object that encapsulates the usage of sparse grid based regression with
    identity as regularization.  

    Allows usage of different grids, different solvers and different regularization
    techniques based on the provided configuration objects.  

    Constructors
    ------------
    * `ModelFittingLeastSquares(config)`  

        Constructor.  

        Parameters:  
        * `config` :  
            configuration object that specifies grid, refinement, and regularization  

    C++ includes: ModelFittingLeastSquares.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, config: "FitterConfigurationLeastSquares"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `config` :  
            configuration object that specifies grid, refinement, and regularization  

        """
        _pysgpp_swig.ModelFittingLeastSquares_swiginit(self, _pysgpp_swig.new_ModelFittingLeastSquares(config))

    def evaluate(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `evaluate(sample) -> double`  

            Evaluate the fitted regression model at a single data point - requires a
            trained grid.  

            Parameters:  
            * `sample` :  
                vector with the coordinates in all dimensions of that sample.  

            Returns:
            evaluation of the trained grid.  

        * `evaluate(samples, results)`  

            Evaluate the fitted model on a set of data points - requires a trained grid.  

            Parameters:  
            * `samples` :  
                matrix where each row represents a sample and the columns contain the
                coordinates in all dimensions of that sample.  
            * `results` :  
                vector where each row will contain the evaluation of the respective
                sample on the current model.  

        """
        return _pysgpp_swig.ModelFittingLeastSquares_evaluate(self, *args)
    __swig_destroy__ = _pysgpp_swig.delete_ModelFittingLeastSquares

# Register ModelFittingLeastSquares in _pysgpp_swig:
_pysgpp_swig.ModelFittingLeastSquares_swigregister(ModelFittingLeastSquares)

class ModelFittingDensityEstimation(ModelFittingBaseSingleGrid):
    r"""

    `ModelFittingDensityEstimation()`  

    Abstract super class to encapsulate density estimation models such as using
    offline/-online splitting or conjugate gradients in order to solve the system.  

    Constructors
    ------------
    * `ModelFittingDensityEstimation()`  

        Default constructor.  

    C++ includes: ModelFittingDensityEstimation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def fit(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `fit(dataset)`  

            Fit the grid to the given dataset by determining the surpluses of the
            initial grid by the SGDE approach.  

            Requires only data samples and no targets (since those are irrelevant for
            the density estimation whatsoever)  

            Parameters:  
            * `dataset` :  
                the training dataset that is used to fit the model.  

        * `fit(dataset)`  

            Polymorphic clone pattern.  

            Returns:
            deep copy of this object. New object is owned by caller. Fit the grid to the
            dataset by determinig the weights of an initial grid  

            Parameters:  
            * `dataset` :  
                the training dataset that is used to fit the model.  

        """
        return _pysgpp_swig.ModelFittingDensityEstimation_fit(self, *args)

    def update(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `update(samples)`  

            Updates the model based on new data samples (streaming, batch learning).  

            Requires only the data samples and no targets (since those are irrelevant
            for the density estimation whatsoever)  

            Parameters:  
            * `samples` :  
                the new data samples  

        * `update(dataset)`  

            Train the grid of an existing model with new samples.  

            Parameters:  
            * `dataset` :  
                the training dataset that is used to fit the model.  

        """
        return _pysgpp_swig.ModelFittingDensityEstimation_update(self, *args)

    def evaluate(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `evaluate(sample) -> double`  

            Evaluate the fitted model at a single data point.  

            Parameters:  
            * `sample` :  
                vector with the coordinates in all dimensions of that sample.  

            Returns:
            evaluation of the model.  

        * `evaluate(samples, results)`  

            Evaluate the fitted model on a set of data points.  

            Parameters:  
            * `samples` :  
                matrix where each row represents a sample and the columns contain the
                coordinates in all dimensions of that sample.  
            * `results` :  
                vector where each row will contain the evaluation of the respective
                sample on the current model.  

        """
        return _pysgpp_swig.ModelFittingDensityEstimation_evaluate(self, *args)

    def adapt(self, *args) -> "bool":
        r"""


        Overloaded function
        -------------------
        * `adapt() -> bool`  

            Improve accuracy of the fit on the given training data by adaptive
            refinement or coarsening of the grid and recalculate weights.  

            Returns:
            true if refinement or coarsening could be performed based on the refinement
            configuration, else false.  

        * `adapt(newNoPoints, deletedGridPoints) -> bool`  

            Performs refinement and coarsening given the new grid size and the points to
            coarsened.  

            Parameters:  
            * `newNoPoints` :  
                the grid size after refinement and coarsening  
            * `deletedGridPoints` :  
                a list of indexes for grid points that will be removed  

            Returns:
            if the grid was refined (true)  

        """
        return _pysgpp_swig.ModelFittingDensityEstimation_adapt(self, *args)
    __swig_destroy__ = _pysgpp_swig.delete_ModelFittingDensityEstimation

# Register ModelFittingDensityEstimation in _pysgpp_swig:
_pysgpp_swig.ModelFittingDensityEstimation_swigregister(ModelFittingDensityEstimation)

class ModelFittingDensityEstimationCombi(ModelFittingDensityEstimation):
    r"""

    `ModelFittingDensityEstimationCombi()`  
    `ModelFittingDensityEstimationCombi(config)`  
    `ModelFittingDensityEstimationCombi(config, objectStore)`  

    Abstract super class to encapsulate density estimation models working with
    multiple Grids.  

    Constructors
    ------------
    * `ModelFittingDensityEstimationCombi()`  

        Default constructor.  

    * `ModelFittingDensityEstimationCombi(config)`  

        Constructor from a configuration object generated by the datamining
        pipeline.  

        Parameters:  
        * `config` :  
            configuration object generated by the datamining pipeline  

    * `ModelFittingDensityEstimationCombi(config, objectStore)`  

        Construct from a configuration object generated from the datamining pipeline
        and a object store to obtain and store already decomposed offline objects.  

        Parameters:  
        * `config` :  
            Configuration object generated by the datamining pipeline.  
        * `objectStore` :  
            Offline object store.  

    C++ includes: ModelFittingDensityEstimationCombi.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `ModelFittingDensityEstimationCombi()`  

            Default constructor.  

        * `ModelFittingDensityEstimationCombi(config)`  

            Constructor from a configuration object generated by the datamining
            pipeline.  

            Parameters:  
            * `config` :  
                configuration object generated by the datamining pipeline  

        * `ModelFittingDensityEstimationCombi(config, objectStore)`  

            Construct from a configuration object generated from the datamining pipeline
            and a object store to obtain and store already decomposed offline objects.  

            Parameters:  
            * `config` :  
                Configuration object generated by the datamining pipeline.  
            * `objectStore` :  
                Offline object store.  

        """
        _pysgpp_swig.ModelFittingDensityEstimationCombi_swiginit(self, _pysgpp_swig.new_ModelFittingDensityEstimationCombi(*args))

    def fit(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `fit(newDataset)`  

            Fit the grids to the given dataset by determining the surpluses of the
            initial grid by the SGDE approach.  

            Requires only data samples and no targets (since those are irrelevant for
            the density estimation whatsoever)  

            Parameters:  
            * `newDataset` :  
                the training dataset that is used to fit the model.  

        * `fit(newDataset)`  

            Fit the grids to the given dataset by determining the weights of the initial
            grid by the SGDE approach.  

            Parameters:  
            * `newDataset` :  
                the training dataset that is used to fit the model.  

        """
        return _pysgpp_swig.ModelFittingDensityEstimationCombi_fit(self, *args)

    def update(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `update(samples)`  

            Updates the model based on new data samples (streaming, batch learning).  

            Requires only the data samples and no targets (since those are irrelevant
            for the density estimation whatsoever)  

            Parameters:  
            * `samples` :  
                the new data samples  

        * `update(dataset)`  

            Train the grid of an existing model with new samples.  

            Parameters:  
            * `dataset` :  
                the training dataset that is used to fit the model.  

        """
        return _pysgpp_swig.ModelFittingDensityEstimationCombi_update(self, *args)

    def evaluate(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `evaluate(sample) -> double`  

            Evaluate the fitted density at a single data point - requires a trained
            grid.  

            Parameters:  
            * `sample` :  
                vector with the coordinates in all dimensions of that sample.  

            Returns:
            evaluation of the trained grid.  

        * `evaluate(samples, results)`  

            Evaluate the fitted density on a set of data points - requires a trained
            grid.  

            Parameters:  
            * `samples` :  
                matrix where each row represents a sample and the columns contain the
                coordinates in all dimensions of that sample.  
            * `results` :  
                vector where each row will contain the evaluation of the respective
                sample on the current model.  

        """
        return _pysgpp_swig.ModelFittingDensityEstimationCombi_evaluate(self, *args)

    def adapt(self, *args) -> "bool":
        r"""


        Overloaded function
        -------------------
        * `adapt() -> bool`  

            Refines the component with the biggest error.  

            Returns:
            if a component was refined  

        * `adapt(newNoPoints, deletedGridPoints) -> bool`  

            Currently not implemented for this class due to missing strategy for
            dimensional adaptive refinement.  

            Throws an application_exception.  

        """
        return _pysgpp_swig.ModelFittingDensityEstimationCombi_adapt(self, *args)
    __swig_destroy__ = _pysgpp_swig.delete_ModelFittingDensityEstimationCombi

# Register ModelFittingDensityEstimationCombi in _pysgpp_swig:
_pysgpp_swig.ModelFittingDensityEstimationCombi_swigregister(ModelFittingDensityEstimationCombi)

class ModelFittingClassification(ModelFittingBase):
    r"""

    `ModelFittingClassification(config)`  
    `ModelFittingClassification(config, objectStore)`  

    Fitter object that encapsulates density based classification using instances of
    ModelFittingDensityEstimation for each class.  

    Constructors
    ------------
    * `ModelFittingClassification(config)`  

        Constructor.  

        Parameters:  
        * `config` :  
            configuration object that specifies grid, refinement, and regularization  

    * `ModelFittingClassification(config, objectStore)`  

        Constructor with specified object store.  

        Parameters:  
        * `config` :  
            Configuration object that specifies grid, refinement, and regularization  
        * `objectStore` :  
            Offline object store for already decomposed offline objects.  

    C++ includes: ModelFittingClassification.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `ModelFittingClassification(config)`  

            Constructor.  

            Parameters:  
            * `config` :  
                configuration object that specifies grid, refinement, and regularization  

        * `ModelFittingClassification(config, objectStore)`  

            Constructor with specified object store.  

            Parameters:  
            * `config` :  
                Configuration object that specifies grid, refinement, and regularization  
            * `objectStore` :  
                Offline object store for already decomposed offline objects.  

        """
        _pysgpp_swig.ModelFittingClassification_swiginit(self, _pysgpp_swig.new_ModelFittingClassification(*args))

    def evaluate(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `evaluate(sample) -> double`  

            Predict the class of a data sample based on the density of the sample for
            each model.  

            Parameters:  
            * `sample` :  
                the sample point to classify  

            Returns:
            the predicted class label  

        * `evaluate(samples, results)`  

            Predicts the class for a set of data points based on the learned densities
            for each class.  

            Parameters:  
            * `samples` :  
                matrix where each row represents a data sample  
            * `results` :  
                vector to output the predicted classes  

        """
        return _pysgpp_swig.ModelFittingClassification_evaluate(self, *args)

    def storeClassificator(self) -> "void":
        r"""


        store Fitter into text file in folder /datadriven/classificator/  

        """
        return _pysgpp_swig.ModelFittingClassification_storeClassificator(self)

    def getModels(self) -> "std::vector< std::unique_ptr< sgpp::datadriven::ModelFittingDensityEstimation >,std::allocator< std::unique_ptr< sgpp::datadriven::ModelFittingDensityEstimation > > > *":
        r"""


        obtain the density estimation models per each class.  

        To be used in VisualizerClassification  

        """
        return _pysgpp_swig.ModelFittingClassification_getModels(self)

    def getClassIdx(self) -> "std::map< double,size_t,std::less< double >,std::allocator< std::pair< double const,size_t > > >":
        r"""


        obtain the index mapping for each label class.  

        To be used in VisualizerClassification  

        """
        return _pysgpp_swig.ModelFittingClassification_getClassIdx(self)
    __swig_destroy__ = _pysgpp_swig.delete_ModelFittingClassification

# Register ModelFittingClassification in _pysgpp_swig:
_pysgpp_swig.ModelFittingClassification_swigregister(ModelFittingClassification)

class VisualizationParameters(object):
    r"""


    C++ includes: VisualizationParameters.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    perplexity = property(_pysgpp_swig.VisualizationParameters_perplexity_get, _pysgpp_swig.VisualizationParameters_perplexity_set)
    theta = property(_pysgpp_swig.VisualizationParameters_theta_get, _pysgpp_swig.VisualizationParameters_theta_set)
    seed = property(_pysgpp_swig.VisualizationParameters_seed_get, _pysgpp_swig.VisualizationParameters_seed_set)
    maxNumberIterations = property(_pysgpp_swig.VisualizationParameters_maxNumberIterations_get, _pysgpp_swig.VisualizationParameters_maxNumberIterations_set)
    targetDimension = property(_pysgpp_swig.VisualizationParameters_targetDimension_get, _pysgpp_swig.VisualizationParameters_targetDimension_set)
    numberCores = property(_pysgpp_swig.VisualizationParameters_numberCores_get, _pysgpp_swig.VisualizationParameters_numberCores_set)

    def __init__(self):
        _pysgpp_swig.VisualizationParameters_swiginit(self, _pysgpp_swig.new_VisualizationParameters())
    __swig_destroy__ = _pysgpp_swig.delete_VisualizationParameters

# Register VisualizationParameters in _pysgpp_swig:
_pysgpp_swig.VisualizationParameters_swigregister(VisualizationParameters)

VisualizationFileType_CSV = _pysgpp_swig.VisualizationFileType_CSV
VisualizationFileType_json = _pysgpp_swig.VisualizationFileType_json
class VisualizationGeneralConfig(object):
    r"""


    C++ includes: VisualizationGeneralConfig.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    execute = property(_pysgpp_swig.VisualizationGeneralConfig_execute_get, _pysgpp_swig.VisualizationGeneralConfig_execute_set)
    algorithm = property(_pysgpp_swig.VisualizationGeneralConfig_algorithm_get, _pysgpp_swig.VisualizationGeneralConfig_algorithm_set)
    targetFileType = property(_pysgpp_swig.VisualizationGeneralConfig_targetFileType_get, _pysgpp_swig.VisualizationGeneralConfig_targetFileType_set)
    numBatches = property(_pysgpp_swig.VisualizationGeneralConfig_numBatches_get, _pysgpp_swig.VisualizationGeneralConfig_numBatches_set)
    crossValidation = property(_pysgpp_swig.VisualizationGeneralConfig_crossValidation_get, _pysgpp_swig.VisualizationGeneralConfig_crossValidation_set)
    targetDirectory = property(_pysgpp_swig.VisualizationGeneralConfig_targetDirectory_get, _pysgpp_swig.VisualizationGeneralConfig_targetDirectory_set)

    def __init__(self):
        _pysgpp_swig.VisualizationGeneralConfig_swiginit(self, _pysgpp_swig.new_VisualizationGeneralConfig())
    __swig_destroy__ = _pysgpp_swig.delete_VisualizationGeneralConfig

# Register VisualizationGeneralConfig in _pysgpp_swig:
_pysgpp_swig.VisualizationGeneralConfig_swigregister(VisualizationGeneralConfig)

class VisualizerConfiguration(object):
    r"""

    `VisualizerConfiguration()`  

    Constructors
    ------------
    * `VisualizerConfiguration()`  

        Default Constructor.  

    C++ includes: VisualizerConfiguration.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default Constructor.  

        """
        _pysgpp_swig.VisualizerConfiguration_swiginit(self, _pysgpp_swig.new_VisualizerConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_VisualizerConfiguration

    def setupDefaults(self) -> "void":
        r"""


        set default values for all members based on the desired scenario.  

        """
        return _pysgpp_swig.VisualizerConfiguration_setupDefaults(self)

    def readParams(self, parser: "sgpp::datadriven::DataMiningConfigParser const &") -> "void":
        r"""


        obtain parameters from a parser  

        Parameters
        ----------
        * `parser` :  
            the parser object to read from  

        """
        return _pysgpp_swig.VisualizerConfiguration_readParams(self, parser)

    def getGeneralConfig(self) -> "sgpp::datadriven::VisualizationGeneralConfig &":
        r"""


        read general configuration parameters  

        """
        return _pysgpp_swig.VisualizerConfiguration_getGeneralConfig(self)

    def getVisualizationParameters(self) -> "sgpp::datadriven::VisualizationParameters &":
        r"""


        read general configuration parameters  

        """
        return _pysgpp_swig.VisualizerConfiguration_getVisualizationParameters(self)

# Register VisualizerConfiguration in _pysgpp_swig:
_pysgpp_swig.VisualizerConfiguration_swigregister(VisualizerConfiguration)

class Visualizer(object):
    r"""

    `Visualizer()`  

    Constructors
    ------------
    * `Visualizer()`  

    C++ includes: Visualizer.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_Visualizer

    def runVisualization(self, model: "ModelFittingBase", dataSource: "DataSource", fold: "size_t", batch: "size_t") -> "void":
        r"""


        Method to run the visualization process for a given batch and fold.  

        Parameters
        ----------
        * `model` :  
            The model used to evaluate the visualization  
        * `dataSource` :  
            The datasource from where the data points are obtained  
        * `fold` :  
            The current fold being processed  
        * `batch` :  
            The current batch being processed  

        """
        return _pysgpp_swig.Visualizer_runVisualization(self, model, dataSource, fold, batch)

    def getVisualizerConfiguration(self) -> "sgpp::datadriven::VisualizerConfiguration const &":
        r"""


        Get the configuration of the visualizer object.  

        Returns
        -------
        configuration of the visualizer object  

        """
        return _pysgpp_swig.Visualizer_getVisualizerConfiguration(self)

# Register Visualizer in _pysgpp_swig:
_pysgpp_swig.Visualizer_swigregister(Visualizer)

class VisualizerDummy(Visualizer):
    r"""

    `VisualizerDummy()`  

    Constructors
    ------------
    * `VisualizerDummy()`  

        Default constructor.  

    C++ includes: VisualizerDummy.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.VisualizerDummy_swiginit(self, _pysgpp_swig.new_VisualizerDummy())
    __swig_destroy__ = _pysgpp_swig.delete_VisualizerDummy

# Register VisualizerDummy in _pysgpp_swig:
_pysgpp_swig.VisualizerDummy_swigregister(VisualizerDummy)

class VisualizerDensityEstimation(Visualizer):
    r"""

    `VisualizerDensityEstimation()`  
    `VisualizerDensityEstimation(config)`  

    Constructors
    ------------
    * `VisualizerDensityEstimation()`  

    * `VisualizerDensityEstimation(config)`  

        Constructor given a configuration.  

        Parameters:  
        * `config` :  
            The VisualizerConfiguration object which contains the configuration to
            run the visualization module  

    C++ includes: VisualizerDensityEstimation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `VisualizerDensityEstimation()`  

        * `VisualizerDensityEstimation(config)`  

            Constructor given a configuration.  

            Parameters:  
            * `config` :  
                The VisualizerConfiguration object which contains the configuration to
                run the visualization module  

        """
        _pysgpp_swig.VisualizerDensityEstimation_swiginit(self, _pysgpp_swig.new_VisualizerDensityEstimation(*args))
    __swig_destroy__ = _pysgpp_swig.delete_VisualizerDensityEstimation

# Register VisualizerDensityEstimation in _pysgpp_swig:
_pysgpp_swig.VisualizerDensityEstimation_swigregister(VisualizerDensityEstimation)

class VisualizerClassification(VisualizerDensityEstimation):
    r"""

    `VisualizerClassification()`  
    `VisualizerClassification(config)`  

    Constructors
    ------------
    * `VisualizerClassification()`  

    * `VisualizerClassification(config)`  

        Constructor given a configuration.  

        Parameters:  
        * `config` :  
            The VisualizerConfiguration object which contains the configuration to
            run the visualization module  

    C++ includes: VisualizerClassification.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `VisualizerClassification()`  

        * `VisualizerClassification(config)`  

            Constructor given a configuration.  

            Parameters:  
            * `config` :  
                The VisualizerConfiguration object which contains the configuration to
                run the visualization module  

        """
        _pysgpp_swig.VisualizerClassification_swiginit(self, _pysgpp_swig.new_VisualizerClassification(*args))
    __swig_destroy__ = _pysgpp_swig.delete_VisualizerClassification

# Register VisualizerClassification in _pysgpp_swig:
_pysgpp_swig.VisualizerClassification_swigregister(VisualizerClassification)

class Metric(object):
    r"""

    `Metric()`  
    `Metric(rhs)`  
    `Metric(rhs)`  

    We use metrics to quantify approximation quality of a trained model.  

    It should be calculated in the way that smaller is always better. This means,
    for example that classification accuracy should be negated.  

    Constructors
    ------------
    * `Metric()`  

        Default constructor.  

    * `Metric(rhs)`  

        Copy constructor.  

        Parameters:  
        * `rhs` :  
            const reference to the scorer object to copy from.  

    * `Metric(rhs)`  

        Move constructor.  

        Parameters:  
        * `rhs` :  
            R-value reference to a scorer object to moved from.  

    C++ includes: Metric.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_Metric

    def clone(self) -> "sgpp::datadriven::Metric *":
        r"""


        Polymorphic clone pattern.  

        Returns
        -------
        deep copy of this object. New object is owned by caller.  

        """
        return _pysgpp_swig.Metric_clone(self)

    def measure(self, predictedValues: "DataVector", trueValues: "DataVector", model: "ModelFittingBase", testDataset: "Dataset") -> "double":
        r"""


        Quantify the difference between predicted values and actual values.  

        Does not have an inner state.  

        Parameters
        ----------
        * `predictedValues` :  
            values calculated by the model for testing data  
        * `trueValues` :  
            actual values as taken from the dataset.  
        * `model` :  
            reference to the model  
        * `testDataset` :  
            dataset with test data  

        Returns
        -------
        Quantification of the difference.  

        """
        return _pysgpp_swig.Metric_measure(self, predictedValues, trueValues, model, testDataset)

    def measureLowerIsBetter(self, predictedValues: "DataVector", trueValues: "DataVector", model: "ModelFittingBase", testDataset: "Dataset") -> "double":
        r"""


        Quantify the difference between predicted values and actual values, where lower
        values indicate a better result.  

        Does not have an inner state.  

        Parameters
        ----------
        * `predictedValues` :  
            values calculated by the model for testing data  
        * `trueValues` :  
            actual values as taken from the dataset.  
        * `model` :  
            reference to the model  
        * `testDataset` :  
            dataset with test data  

        Returns
        -------
        Quantification of the difference.  

        """
        return _pysgpp_swig.Metric_measureLowerIsBetter(self, predictedValues, trueValues, model, testDataset)

# Register Metric in _pysgpp_swig:
_pysgpp_swig.Metric_swigregister(Metric)

class MSE(Metric):
    r"""


    Metric that quantifies the difference between predicted values and actual values
    in terms of mean squared error (MSE).  

    MSE is defined strictly positive such that smaller values are better.  

    C++ includes: MSE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pysgpp_swig.MSE_swiginit(self, _pysgpp_swig.new_MSE())
    __swig_destroy__ = _pysgpp_swig.delete_MSE

# Register MSE in _pysgpp_swig:
_pysgpp_swig.MSE_swigregister(MSE)

class Accuracy(Metric):
    r"""


    Metric that quantifies the difference between predicted values and actual values
    in terms of mean squared error (MSE).  

    MSE is defined strictly positive such that smaller values are better.  

    C++ includes: Accuracy.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pysgpp_swig.Accuracy_swiginit(self, _pysgpp_swig.new_Accuracy())
    __swig_destroy__ = _pysgpp_swig.delete_Accuracy

# Register Accuracy in _pysgpp_swig:
_pysgpp_swig.Accuracy_swigregister(Accuracy)

class NegativeLogLikelihood(Metric):
    r"""


    Metric that quantifies the likelihood of a dataset given the density function.  

    The smaller the negative log likelihood the better the fit  

    C++ includes: NegativeLogLikelihood.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pysgpp_swig.NegativeLogLikelihood_swiginit(self, _pysgpp_swig.new_NegativeLogLikelihood())
    __swig_destroy__ = _pysgpp_swig.delete_NegativeLogLikelihood

# Register NegativeLogLikelihood in _pysgpp_swig:
_pysgpp_swig.NegativeLogLikelihood_swigregister(NegativeLogLikelihood)

ScorerMetricType_mse = _pysgpp_swig.ScorerMetricType_mse
ScorerMetricType_nll = _pysgpp_swig.ScorerMetricType_nll
ScorerMetricType_accuracy = _pysgpp_swig.ScorerMetricType_accuracy
class ScorerConfiguration(object):
    r"""


    Set of parameters to define a scorer instance.  

    C++ includes: ScorerConfig.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    metric = property(_pysgpp_swig.ScorerConfiguration_metric_get, _pysgpp_swig.ScorerConfiguration_metric_set)

    def __init__(self):
        _pysgpp_swig.ScorerConfiguration_swiginit(self, _pysgpp_swig.new_ScorerConfiguration())
    __swig_destroy__ = _pysgpp_swig.delete_ScorerConfiguration

# Register ScorerConfiguration in _pysgpp_swig:
_pysgpp_swig.ScorerConfiguration_swigregister(ScorerConfiguration)

class ScorerMetricTypeParser(object):
    r"""


    Convenience class to convert strings to sgpp::datadriven::ScorerMetricType or
    sgpp::datadriven::RegularizationMetricType and generate string representations
    for values of sgpp::datadriven::ScorerMetricType or
    sgpp::datadriven::RegularizationMetricType.  

    C++ includes: ScorerMetricTypeParser.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parse(input: "std::string const &") -> "sgpp::datadriven::ScorerMetricType":
        r"""


        Convert strings to values sgpp::datadriven::ScorerMetricType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a
            sgpp::datadriven::ScorerMetricType.  

        Returns
        -------
        the corresponding sgpp::datadriven::ScorerMetricType.  

        """
        return _pysgpp_swig.ScorerMetricTypeParser_parse(input)

    @staticmethod
    def parseRegularizationMetric(input: "std::string const &") -> "sgpp::datadriven::RegularizationMetricType":
        r"""


        Convert strings to values sgpp::datadriven::RegularizationMetricType.  

        Throws if there is no valid representation  

        Parameters
        ----------
        * `input` :  
            case insensitive string representation of a
            sgpp::datadriven::RegularizationMetricType.  

        Returns
        -------
        the corresponding sgpp::datadriven::RegularizationMetricType.  

        """
        return _pysgpp_swig.ScorerMetricTypeParser_parseRegularizationMetric(input)

    @staticmethod
    def toString(type: "sgpp::datadriven::ScorerMetricType") -> "std::string const &":
        r"""


        generate string representations for values of
        sgpp::datadriven::ScorerMetricType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::datadriven::ScorerMetricType.  

        """
        return _pysgpp_swig.ScorerMetricTypeParser_toString(type)

    @staticmethod
    def regularizationMetricToString(type: "sgpp::datadriven::RegularizationMetricType") -> "std::string const &":
        r"""


        generate string representations for values of
        sgpp::datadriven::RegularizationMetricType.  

        Parameters
        ----------
        * `type` :  
            enum value.  

        Returns
        -------
        string representation of a sgpp::datadriven::RegularizationMetricType.  

        """
        return _pysgpp_swig.ScorerMetricTypeParser_regularizationMetricToString(type)

    def __init__(self):
        _pysgpp_swig.ScorerMetricTypeParser_swiginit(self, _pysgpp_swig.new_ScorerMetricTypeParser())
    __swig_destroy__ = _pysgpp_swig.delete_ScorerMetricTypeParser

# Register ScorerMetricTypeParser in _pysgpp_swig:
_pysgpp_swig.ScorerMetricTypeParser_swigregister(ScorerMetricTypeParser)

def ScorerMetricTypeParser_parse(input: "std::string const &") -> "sgpp::datadriven::ScorerMetricType":
    r"""


    Convert strings to values sgpp::datadriven::ScorerMetricType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a
        sgpp::datadriven::ScorerMetricType.  

    Returns
    -------
    the corresponding sgpp::datadriven::ScorerMetricType.  

    """
    return _pysgpp_swig.ScorerMetricTypeParser_parse(input)

def ScorerMetricTypeParser_parseRegularizationMetric(input: "std::string const &") -> "sgpp::datadriven::RegularizationMetricType":
    r"""


    Convert strings to values sgpp::datadriven::RegularizationMetricType.  

    Throws if there is no valid representation  

    Parameters
    ----------
    * `input` :  
        case insensitive string representation of a
        sgpp::datadriven::RegularizationMetricType.  

    Returns
    -------
    the corresponding sgpp::datadriven::RegularizationMetricType.  

    """
    return _pysgpp_swig.ScorerMetricTypeParser_parseRegularizationMetric(input)

def ScorerMetricTypeParser_toString(type: "sgpp::datadriven::ScorerMetricType") -> "std::string const &":
    r"""


    generate string representations for values of
    sgpp::datadriven::ScorerMetricType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::datadriven::ScorerMetricType.  

    """
    return _pysgpp_swig.ScorerMetricTypeParser_toString(type)

def ScorerMetricTypeParser_regularizationMetricToString(type: "sgpp::datadriven::RegularizationMetricType") -> "std::string const &":
    r"""


    generate string representations for values of
    sgpp::datadriven::RegularizationMetricType.  

    Parameters
    ----------
    * `type` :  
        enum value.  

    Returns
    -------
    string representation of a sgpp::datadriven::RegularizationMetricType.  

    """
    return _pysgpp_swig.ScorerMetricTypeParser_regularizationMetricToString(type)

class Scorer(object):
    r"""

    `Scorer(metric)`  
    `Scorer(rhs)`  

    Base class for supervised learning used to fit a model and quantify accuracy
    using a sgpp::datadriven::Metric with either testing or cross validation.  

    Splits a dataset into testing and training parts, trains the model and measures
    the accuracy.  

    Constructors
    ------------
    * `Scorer(metric)`  

        Constructor.  

        Parameters:  
        * `metric` :  
            sgpp::datadriven::Metric to to quantify approximation quality of a
            trained model. Scorer will take ownership of this object. puts a random
            seed.  

    * `Scorer(rhs)`  

        Move constructor.  

        Parameters:  
        * `rhs` :  
            R-value reference to a scorer object to moved from.  

    C++ includes: Scorer.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `Scorer(metric)`  

            Constructor.  

            Parameters:  
            * `metric` :  
                sgpp::datadriven::Metric to to quantify approximation quality of a
                trained model. Scorer will take ownership of this object. puts a random
                seed.  

        * `Scorer(rhs)`  

            Move constructor.  

            Parameters:  
            * `rhs` :  
                R-value reference to a scorer object to moved from.  

        """
        _pysgpp_swig.Scorer_swiginit(self, _pysgpp_swig.new_Scorer(*args))
    __swig_destroy__ = _pysgpp_swig.delete_Scorer

    def test(self, model: "ModelFittingBase", testDataset: "Dataset", lowerIsBetter: "bool"=False) -> "double":
        r"""


        evaluate the accuracy on the test set using the sgpp::datadriven::Metric.  

        Parameters
        ----------
        * `model` :  
            model to be fitted based on the train dataset.  
        * `testDataset` :  
            dataset used quantify accuracy using sgpp::datadriven::Metric.  
        * `lowerIsBetter` :  
            sets up the metric so that a lower score indicates a better result  

        Returns
        -------
        accuracy of the fit.  

        """
        return _pysgpp_swig.Scorer_test(self, model, testDataset, lowerIsBetter)

# Register Scorer in _pysgpp_swig:
_pysgpp_swig.Scorer_swigregister(Scorer)

class SparseGridMiner(object):
    r"""

    `SparseGridMiner(rhs)`  
    `SparseGridMiner(fitter, scorer, visualizer)`  
    `SparseGridMiner(rhs)`  

    SparseGridMiner models the entire mining process for data mining with sparse
    grids.  

    It aggregates and automates data input, fitting and validation modules and
    controls the mining process.  

    Constructors
    ------------
    * `SparseGridMiner(rhs)`  

        Copy constructor deleted - not all members can be copied or cloned .  

        Parameters:  
        * `rhs` :  
            the object to copy from  

    * `SparseGridMiner(fitter, scorer, visualizer)`  

        Constructor.  

        Parameters:  
        * `fitter` :  
            configured instance of fitter object that generalize the model. The
            miner instance will take ownership of the passed object.  
        * `scorer` :  
            configured instance of scorer object that will assess the quality of the
            generalization provided by the fitter on testing data. The miner
            instance will take ownership of the passed object.  
        * `visualizer` :  
            configured instance of the visualizer object that will execute the
            visualization module of the model. The miner instance will take
            ownership of the passed object  

    * `SparseGridMiner(rhs)`  

        Default Move constructor .  

        Parameters:  
        * `rhs` :  
            the object to move from  

    C++ includes: SparseGridMiner.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_SparseGridMiner

    def learn(self, verbose: "bool") -> "double":
        r"""


        Perform Learning cycle: Get samples from data source and based on the scoring
        procedure, generalize data by fitting and asses quality of the fit.  

        """
        return _pysgpp_swig.SparseGridMiner_learn(self, verbose)

    def getModel(self) -> "sgpp::datadriven::ModelFittingBase *":
        r"""


        Returns the trained model.  

        Returns
        -------
        the trained model  

        """
        return _pysgpp_swig.SparseGridMiner_getModel(self)

    def setModel(self, model: "ModelFittingBase") -> "void":
        r"""


        """
        return _pysgpp_swig.SparseGridMiner_setModel(self, model)

    def getVisualizer(self) -> "sgpp::datadriven::Visualizer *":
        r"""


        """
        return _pysgpp_swig.SparseGridMiner_getVisualizer(self)

    def test(self, testDataset: "Dataset") -> "double":
        r"""


        Evaluate the model on a certain test dataset.  

        Parameters
        ----------
        * `testDataset` :  
            dataset used quantify accuracy using sgpp::datadriven::Metric.  

        Returns
        -------
        score of the fit.  

        """
        return _pysgpp_swig.SparseGridMiner_test(self, testDataset)

# Register SparseGridMiner in _pysgpp_swig:
_pysgpp_swig.SparseGridMiner_swigregister(SparseGridMiner)

class SparseGridMinerSplitting(SparseGridMiner):
    r"""

    `SparseGridMinerSplitting(rhs)`  
    `SparseGridMinerSplitting(dataSource, fitter, scorer, visualizer)`  
    `SparseGridMinerSplitting(rhs)`  

    SparseGridMiner models a datamining process that involves a dataset that is
    first split into validation and training data.  

    The model is then trained on the training data for several epochs.  

    Constructors
    ------------
    * `SparseGridMinerSplitting(rhs)`  

        Copy constructor deleted - not all members can be copied or cloned .  

        Parameters:  
        * `rhs` :  
            the object to copy from  

    * `SparseGridMinerSplitting(dataSource, fitter, scorer, visualizer)`  

        Constructor.  

        Parameters:  
        * `dataSource` :  
            configured instance of data source object, that will provide samples to
            learn from. The miner instance will take ownership of the passed object.  
        * `fitter` :  
            configured instance of fitter object that generalize the model. The
            miner instance will take ownership of the passed object.  
        * `scorer` :  
            configured instance of scorer object that will assess the quality of the
            generalization provided by the fitter on testing data. The miner
            instance will take ownership of the passed object.  
        * `visualizer` :  
            configured instance of viusalizer object that will produce the output to
            visualize the model and its results  

    * `SparseGridMinerSplitting(rhs)`  

        Default Move constructor .  

        Parameters:  
        * `rhs` :  
            the object to move from  

    C++ includes: SparseGridMinerSplitting.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `SparseGridMinerSplitting(rhs)`  

            Copy constructor deleted - not all members can be copied or cloned .  

            Parameters:  
            * `rhs` :  
                the object to copy from  

        * `SparseGridMinerSplitting(dataSource, fitter, scorer, visualizer)`  

            Constructor.  

            Parameters:  
            * `dataSource` :  
                configured instance of data source object, that will provide samples to
                learn from. The miner instance will take ownership of the passed object.  
            * `fitter` :  
                configured instance of fitter object that generalize the model. The
                miner instance will take ownership of the passed object.  
            * `scorer` :  
                configured instance of scorer object that will assess the quality of the
                generalization provided by the fitter on testing data. The miner
                instance will take ownership of the passed object.  
            * `visualizer` :  
                configured instance of viusalizer object that will produce the output to
                visualize the model and its results  

        * `SparseGridMinerSplitting(rhs)`  

            Default Move constructor .  

            Parameters:  
            * `rhs` :  
                the object to move from  

        """
        _pysgpp_swig.SparseGridMinerSplitting_swiginit(self, _pysgpp_swig.new_SparseGridMinerSplitting(*args))
    __swig_destroy__ = _pysgpp_swig.delete_SparseGridMinerSplitting

    def optimizeLambda(self, verbose: "bool") -> "double":
        r"""


        Optimizes the lambda value for regularization.  

        In order to do this, multiple alpha vecotrs are created with different lambda
        values and Golden section search is used to quickly find the optimum.  

        """
        return _pysgpp_swig.SparseGridMinerSplitting_optimizeLambda(self, verbose)

    def evaluateLambda(self, _lambda: "double", verbose: "bool") -> "double":
        r"""


        Fit the model using a specific lambda value and return a score for this lambda.  

        """
        return _pysgpp_swig.SparseGridMinerSplitting_evaluateLambda(self, _lambda, verbose)

# Register SparseGridMinerSplitting in _pysgpp_swig:
_pysgpp_swig.SparseGridMinerSplitting_swigregister(SparseGridMinerSplitting)

class DataSourceBuilder(object):
    r"""

    `DataSourceBuilder()`  

    Generate an instance of sgpp::datadriven::DataSource using the Builder Pattern.  

    Constructors
    ------------
    * `DataSourceBuilder()`  

        Default constructor.  

    C++ includes: DataSourceBuilder.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.DataSourceBuilder_swiginit(self, _pysgpp_swig.new_DataSourceBuilder())

    def withPath(self, filePath: "std::string const &") -> "sgpp::datadriven::DataSourceBuilder &":
        r"""


        Optionally specify a valid path to a file that should be read if files are used.  

        If the file extension does not match a type from DataSourceFileType it has to be
        manually specified using DataSourceBuilder::withFileType.  

        Parameters
        ----------
        * `filePath` :  
            valid path to a file that should be read by the data source.  

        Returns
        -------
        Reference to this object, used for chaining.  

        """
        return _pysgpp_swig.DataSourceBuilder_withPath(self, filePath)

    def withCompression(self, isCompressed: "bool") -> "sgpp::datadriven::DataSourceBuilder &":
        r"""


        Optionally Specify if the file used is gz compressed.  

        If data source does not use any files, this is set to false by default.  

        Parameters
        ----------
        * `isCompressed` :  
            true if the file is compressed, false otherwise.  

        Returns
        -------
        Reference to this object, used for chaining.  

        """
        return _pysgpp_swig.DataSourceBuilder_withCompression(self, isCompressed)

    def withFileType(self, fileType: "sgpp::datadriven::DataSourceFileType") -> "sgpp::datadriven::DataSourceBuilder &":
        r"""


        Optionally Specify the file type if files are used.  

        If data source does not use any files, this is set to none by default. See
        DataSourceFileType for supported file types.  

        Parameters
        ----------
        * `fileType` :  
            value of  

        Returns
        -------
        Reference to this object, used for chaining.  

        """
        return _pysgpp_swig.DataSourceBuilder_withFileType(self, fileType)

    def inBatches(self, howMany: "size_t") -> "sgpp::datadriven::DataSourceBuilder &":
        r"""


        Optionally Specify the amount of batches if batch learning is used.  

        If no batch learning is used, all data is returned as a single batch (same as
        howMany=1).  

        Parameters
        ----------
        * `howMany` :  
            amount of batches used in batch learning scenario.  

        Returns
        -------
        Reference to this object, used for chaining.  

        """
        return _pysgpp_swig.DataSourceBuilder_inBatches(self, howMany)

    def withBatchSize(self, batchSize: "size_t") -> "sgpp::datadriven::DataSourceBuilder &":
        r"""


        Optionally Specify the batch size if batch learning is used.  

        If no batch learning is used this value defaults to 0 (all samples).  

        Parameters
        ----------
        * `batchSize` :  
            size of batches used in batch learning scenario.  

        Returns
        -------
        Reference to this object, used for chaining.  

        """
        return _pysgpp_swig.DataSourceBuilder_withBatchSize(self, batchSize)

    def splittingAssemble(self) -> "sgpp::datadriven::DataSourceSplitting *":
        r"""


        Based on the currently specified configuration, build and configure an instance
        of a data source object.  

        Returns
        -------
        Fully configured instance of sgpp::datadriven::DataSourceSplitting object.  

        """
        return _pysgpp_swig.DataSourceBuilder_splittingAssemble(self)

    def splittingFromConfig(self, config: "DataSourceConfig") -> "sgpp::datadriven::DataSourceSplitting *":
        r"""


        Factory method used to build an instance of a
        sgpp::datadriven::DataSourceSplitting object based on the passed configuration.  

        Parameters
        ----------
        * `config` :  
            configuration for the data source instance  

        Returns
        -------
        Fully configured instance of sgpp::datadriven::DataSourceSplitting object.  

        """
        return _pysgpp_swig.DataSourceBuilder_splittingFromConfig(self, config)

    def crossValidationAssemble(self) -> "sgpp::datadriven::DataSourceCrossValidation *":
        r"""


        Based on the currently specified configuration, build and configure an instance
        of a data source object that is able to perform cross validation.  

        Returns
        -------
        Fully configured instance of sgpp::datadriven::DataSourceCrossValidation object.  

        """
        return _pysgpp_swig.DataSourceBuilder_crossValidationAssemble(self)

    def crossValidationFromConfig(self, config: "DataSourceConfig", crossValidationConfig: "CrossvalidationConfiguration") -> "sgpp::datadriven::DataSourceCrossValidation *":
        r"""


        Factory method used to build an instance of a
        sgpp::datadriven::DataSourceCrossValidation object based on the passed
        configuration.  

        Parameters
        ----------
        * `config` :  
            configuration for the data source instance  
        * `crossValidationConfig` :  
            configuration for the cross validation  

        Returns
        -------
        Fully configured instance of sgpp::datadriven::DataSourceCrossValidation object.  

        """
        return _pysgpp_swig.DataSourceBuilder_crossValidationFromConfig(self, config, crossValidationConfig)
    __swig_destroy__ = _pysgpp_swig.delete_DataSourceBuilder

# Register DataSourceBuilder in _pysgpp_swig:
_pysgpp_swig.DataSourceBuilder_swigregister(DataSourceBuilder)

class ScorerFactory(object):
    r"""

    `ScorerFactory()`  

    Factory to build the scorer.  

    Constructors
    ------------
    * `ScorerFactory()`  

        Default constructor.  

    C++ includes: ScorerFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.ScorerFactory_swiginit(self, _pysgpp_swig.new_ScorerFactory())
    __swig_destroy__ = _pysgpp_swig.delete_ScorerFactory

    def buildScorer(self, parser: "sgpp::datadriven::DataMiningConfigParser const &") -> "sgpp::datadriven::Scorer *":
        r"""


        Assemble a sgpp::datadriven::Scorer object based on the configuration.  

        Parameters
        ----------
        * `parser` :  
            Instance of sgpp::datadriven::DataMiningConfigParser that reads the required
            data from the config file.  

        Returns
        -------
        Fully configured instance of a sgpp::datadriven::Scorer object.  

        """
        return _pysgpp_swig.ScorerFactory_buildScorer(self, parser)

    def buildRegularizationScorer(self, config: "RegularizationConfiguration") -> "sgpp::datadriven::Scorer *":
        r"""


        Assemble a sgpp::datadriven::Scorer for regularization optimization based on the
        configuration.  

        Parameters
        ----------
        * `config` :  
            regularization config  

        Returns
        -------
        Fully configured instance of a sgpp::datadriven::Scorer object.  

        """
        return _pysgpp_swig.ScorerFactory_buildRegularizationScorer(self, config)

# Register ScorerFactory in _pysgpp_swig:
_pysgpp_swig.ScorerFactory_swigregister(ScorerFactory)

class MinerFactory(object):
    r"""

    `MinerFactory()`  

    Abstract factory to build different kinds of Miners based on a configuration
    which is parsed from a file.  

    A miner consists of a data source, a fitter and a scorer. A concrete Factory
    class has to implement the required interfaces.  

    Constructors
    ------------
    * `MinerFactory()`  

        Default constructor.  

    C++ includes: MinerFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_MinerFactory

    def buildMiner(self, path: "std::string const &") -> "sgpp::datadriven::SparseGridMiner *":
        r"""


        Factory method to build a miner object based on a configuration file.  

        Parameters
        ----------
        * `path` :  
            Path to a configuration file that defines the structure of the miner object.  

        """
        return _pysgpp_swig.MinerFactory_buildMiner(self, path)

    def buildHPO(self, path: "std::string const &") -> "sgpp::datadriven::HyperparameterOptimizer *":
        r"""


        """
        return _pysgpp_swig.MinerFactory_buildHPO(self, path)

# Register MinerFactory in _pysgpp_swig:
_pysgpp_swig.MinerFactory_swigregister(MinerFactory)

class LeastSquaresRegressionMinerFactory(MinerFactory):
    r"""

    `LeastSquaresRegressionMinerFactory()`  

    Concrete Factory that builds an instance of sgpp::datadriven::SparseGridMiner
    for Least Squares Regression.  

    Constructors
    ------------
    * `LeastSquaresRegressionMinerFactory()`  

        Default constructor.  

    C++ includes: LeastSquaresRegressionMinerFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.LeastSquaresRegressionMinerFactory_swiginit(self, _pysgpp_swig.new_LeastSquaresRegressionMinerFactory())
    __swig_destroy__ = _pysgpp_swig.delete_LeastSquaresRegressionMinerFactory

# Register LeastSquaresRegressionMinerFactory in _pysgpp_swig:
_pysgpp_swig.LeastSquaresRegressionMinerFactory_swigregister(LeastSquaresRegressionMinerFactory)

class DensityEstimationMinerFactory(MinerFactory):
    r"""

    `DensityEstimationMinerFactory()`  

    Concrete Factory that builds an instance of sgpp::datadriven::SparseGridMiner
    for Density Estimation.  

    Constructors
    ------------
    * `DensityEstimationMinerFactory()`  

        Default constructor.  

    C++ includes: DensityEstimationMinerFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.DensityEstimationMinerFactory_swiginit(self, _pysgpp_swig.new_DensityEstimationMinerFactory())
    __swig_destroy__ = _pysgpp_swig.delete_DensityEstimationMinerFactory

# Register DensityEstimationMinerFactory in _pysgpp_swig:
_pysgpp_swig.DensityEstimationMinerFactory_swigregister(DensityEstimationMinerFactory)

class ClassificationMinerFactory(MinerFactory):
    r"""

    `ClassificationMinerFactory()`  

    Concrete Factory that builds an instance of sgpp::datadriven::SparseGridMiner
    for classification.  

    Constructors
    ------------
    * `ClassificationMinerFactory()`  

        Default constructor.  

    C++ includes: ClassificationMinerFactory.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.ClassificationMinerFactory_swiginit(self, _pysgpp_swig.new_ClassificationMinerFactory())
    __swig_destroy__ = _pysgpp_swig.delete_ClassificationMinerFactory

# Register ClassificationMinerFactory in _pysgpp_swig:
_pysgpp_swig.ClassificationMinerFactory_swigregister(ClassificationMinerFactory)

class OperationTest(object):
    r"""

    `OperationTest()`  

    Operation the tests the function that is applied the current Sparse
    sgpp::base::Grid at a given point.  

    Constructors
    ------------
    * `OperationTest()`  

        Constructor.  

    C++ includes: OperationTest.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationTest

    def test(self, alpha: "DataVector", data: "DataMatrix", classes: "DataVector") -> "double":
        r"""


        Computes the classification accuracy on some test data.  

        The function is evaluated at the given points. Tests on the classes {+1, -1},
        cut-off at 0.  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the sparse grid's base functions  
        * `data` :  
            the coordinates of the evaluation points  
        * `classes` :  
            sgpp::base::DataVector holding the class information  

        """
        return _pysgpp_swig.OperationTest_test(self, alpha, data, classes)

    def testMSE(self, alpha: "DataVector", data: "DataMatrix", refValues: "DataVector") -> "double":
        r"""


        Computes the regression accuracy on some test data.  

        The function is evaluated at the given points. Calculates the MSE between
        between the given values and the values evaluated on the sparse grid.  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the sparse grid's base functions  
        * `data` :  
            the coordinates of the evaluation points  
        * `refValues` :  
            sgpp::base::DataVector holding the reference function values  

        """
        return _pysgpp_swig.OperationTest_testMSE(self, alpha, data, refValues)

    def testWithCharacteristicNumber(self, alpha: "DataVector", data: "DataMatrix", classes: "DataVector", charaNumbers: "DataVector") -> "double":
        r"""


        Computes the classification accuracy on some test data.  

        The function is evaluated at the given points. Tests on the classes {+1, -1},
        cut-off at 0.  

        Also the number of the TP TN FP FN are determined  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the sparse grid's base functions  
        * `data` :  
            the coordinates of the evaluation points  
        * `classes` :  
            sgpp::base::DataVector the holds the class information  
        * `charaNumbers` :  
            the number of true positives, true negatives, false positives, false
            negatives (Vector of length 4)  

        """
        return _pysgpp_swig.OperationTest_testWithCharacteristicNumber(self, alpha, data, classes, charaNumbers)

    def calculateROCcurve(self, alpha: "DataVector", data: "DataMatrix", classes: "DataVector", thresholds: "DataVector", ROC_curve: "DataMatrix") -> "void":
        r"""


        Computes the classification accuracy on some test data.  

        The function is evaluated at the given points. Tests on the classes {+1, -1},
        cut-off variable at threshold  

        Also the number of the TP TN FP FN are determined  

        Parameters
        ----------
        * `alpha` :  
            the coefficients of the sparse grid's base functions  
        * `data` :  
            the coordinates of the evaluation points  
        * `classes` :  
            sgpp::base::DataVector the holds the class information  
        * `thresholds` :  
            the thresholds (between -1.0 and 1.0) for calculating the ROC curve  
        * `ROC_curve` :  
            DataMatrix into which the ROC curve is stored  

        """
        return _pysgpp_swig.OperationTest_calculateROCcurve(self, alpha, data, classes, thresholds, ROC_curve)

# Register OperationTest in _pysgpp_swig:
_pysgpp_swig.OperationTest_swigregister(OperationTest)

class OperationRegularizationDiagonal(OperationMatrix):
    r"""

    `OperationRegularizationDiagonal(storage, mode, k)`  

    Implementation of the application of a diagonal matrix to a DataVector for
    regularization.  

    This class implements several scaling possibilities.  

    Constructors
    ------------
    * `OperationRegularizationDiagonal(storage, mode, k)`  

        Constructor of OperationRegularizationDiagonal.  

        Constructor should most likely call init() in subclasses.  

        Parameters:  
        * `storage` :  
            Pointer to grid's storage object  
        * `mode` :  
            Mode, specifying which regularization to use. Example:
            OperationRegularizationDiagonal::HKMIX.  
        * `k` :  
            Parameter for $H^k$  

    C++ includes: OperationRegularizationDiagonal.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    HKMIX = _pysgpp_swig.OperationRegularizationDiagonal_HKMIX
    H0HKLAPLACE = _pysgpp_swig.OperationRegularizationDiagonal_H0HKLAPLACE
    ISOTROPIC_PENALTY = _pysgpp_swig.OperationRegularizationDiagonal_ISOTROPIC_PENALTY
    ANISOTROPIC_PENALTY = _pysgpp_swig.OperationRegularizationDiagonal_ANISOTROPIC_PENALTY
    __swig_destroy__ = _pysgpp_swig.delete_OperationRegularizationDiagonal

# Register OperationRegularizationDiagonal in _pysgpp_swig:
_pysgpp_swig.OperationRegularizationDiagonal_swigregister(OperationRegularizationDiagonal)

class OperationTransformation1D(object):
    r"""

    `OperationTransformation1D()`  

    Sample 1D Probability Density Function.  

    Constructors
    ------------
    * `OperationTransformation1D()`  

    C++ includes: OperationTransformation1D.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationTransformation1D

    def doTransformation1D(self, alpha1d: "DataVector", coord1d: "double") -> "double":
        r"""


        Transform 1d.  

        Parameters
        ----------
        * `alpha1d` :  
        * `coord1d` :  

        Returns
        -------  

        """
        return _pysgpp_swig.OperationTransformation1D_doTransformation1D(self, alpha1d, coord1d)

# Register OperationTransformation1D in _pysgpp_swig:
_pysgpp_swig.OperationTransformation1D_swigregister(OperationTransformation1D)

class OperationRosenblattTransformation(object):
    r"""

    `OperationRosenblattTransformation()`  

    Sampling on all dimensions.  

    Constructors
    ------------
    * `OperationRosenblattTransformation()`  

    C++ includes: OperationRosenblattTransformation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationRosenblattTransformation

    def doTransformation(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `doTransformation(alpha, points, pointscdf)`  

            Rosenblatt Transformation with mixed starting dimension.  

            Parameters:  
            * `alpha` :  
                Coefficient vector for current grid  
            * `points` :  
                Input DataMatrix (rows: # of samples, columns: # of dims)  
            * `pointscdf` :  
                Output DataMatrix (rows: # of samples, columns: # of dims)  

        * `doTransformation(alpha, points, pointscdf, dim_start)`  

            Rosenblatt Transformation with fixed starting dimension.  

            Parameters:  
            * `alpha` :  
                Coefficient vector for current grid  
            * `points` :  
                Input DataMatrix (rows: # of samples, columns: # of dims)  
            * `pointscdf` :  
                Output DataMatrix (rows: # of samples, columns: # of dims)  
            * `dim_start` :  
                starting dimension  

        """
        return _pysgpp_swig.OperationRosenblattTransformation_doTransformation(self, *args)

# Register OperationRosenblattTransformation in _pysgpp_swig:
_pysgpp_swig.OperationRosenblattTransformation_swigregister(OperationRosenblattTransformation)

class OperationInverseRosenblattTransformation(object):
    r"""

    `OperationInverseRosenblattTransformation()`  

    Sampling on all dimensions.  

    Constructors
    ------------
    * `OperationInverseRosenblattTransformation()`  

    C++ includes: OperationInverseRosenblattTransformation.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationInverseRosenblattTransformation

    def doTransformation(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `doTransformation(alpha, pointscdf, points)`  

            Rosenblatt Transformation with mixed starting dimension.  

            Parameters:  
            * `alpha` :  
                Coefficient vector for current grid  
            * `pointscdf` :  
                Input DataMatrix (rows: # of samples, columns: # of dims)  
            * `points` :  
                Output DataMatrix (rows: # of samples, columns: # of dims)  

        * `doTransformation(alpha, pointscdf, points, dim_start)`  

            Rosenblatt Transformation with fixed starting dimension.  

            Parameters:  
            * `alpha` :  
                Coefficient vector for current grid  
            * `pointscdf` :  
                Input DataMatrix (rows: # of samples, columns: # of dims)  
            * `points` :  
                Output DataMatrix (rows: # of samples, columns: # of dims)  
            * `dim_start` :  
                starting dimension  

        """
        return _pysgpp_swig.OperationInverseRosenblattTransformation_doTransformation(self, *args)

# Register OperationInverseRosenblattTransformation in _pysgpp_swig:
_pysgpp_swig.OperationInverseRosenblattTransformation_swigregister(OperationInverseRosenblattTransformation)

class OperationRosenblattTransformationKDE(object):
    r"""

    `OperationRosenblattTransformationKDE(kde, seed=std::mt19937_64::default_seed)`  

    Do transformation in all dimensions.  

    Constructors
    ------------
    * `OperationRosenblattTransformationKDE(kde,
        seed=std::mt19937_64::default_seed)`  

    C++ includes: OperationRosenblattTransformationKDE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        """
        _pysgpp_swig.OperationRosenblattTransformationKDE_swiginit(self, _pysgpp_swig.new_OperationRosenblattTransformationKDE(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OperationRosenblattTransformationKDE

    def doTransformation(self, pointsCdf: "DataMatrix", pointsUniform: "DataMatrix") -> "void":
        r"""


        Rosenblatt Transformation with mixed starting dimension.  

        Parameters
        ----------
        * `pointsCdf` :  
            Output base::DataMatrix (rows: # of samples, columns: # of dims)  
        * `pointsUniform` :  
            data points to be transformed base::DataMatrix (rows: # of samples, columns:
            # of dims)  

        """
        return _pysgpp_swig.OperationRosenblattTransformationKDE_doTransformation(self, pointsCdf, pointsUniform)

    def doShuffledTransformation(self, pointsCdf: "DataMatrix", pointsUniform: "DataMatrix") -> "void":
        r"""


        """
        return _pysgpp_swig.OperationRosenblattTransformationKDE_doShuffledTransformation(self, pointsCdf, pointsUniform)

    def doTransformation1D(self, x: "double", samples1d: "DataVector", sigma: "double", kern: "DataVector") -> "double":
        r"""


        Rosenblatt transformation for one data point with given samples and and kernel
        evaluations, see doTransformation for details.  

        Parameters
        ----------
        * `x` :  
            data point  
        * `samples1d` :  
            training samples in the dimension to be transformed  
        * `sigma` :  
            bandwidth of the kernels in the current dimension  
        * `kern` :  
            kernel evaluations  

        """
        return _pysgpp_swig.OperationRosenblattTransformationKDE_doTransformation1D(self, x, samples1d, sigma, kern)

# Register OperationRosenblattTransformationKDE in _pysgpp_swig:
_pysgpp_swig.OperationRosenblattTransformationKDE_swigregister(OperationRosenblattTransformationKDE)

class OperationInverseRosenblattTransformationKDE(object):
    r"""

    `OperationInverseRosenblattTransformationKDE(kde, sigmaFactor=6.0,
        inversionEpsilon=1e-10, seed=std::mt19937_64::default_seed)`  

    Do inverse transformation in all dimensions.  

    Constructors
    ------------
    * `OperationInverseRosenblattTransformationKDE(kde, sigmaFactor=6.0,
        inversionEpsilon=1e-10, seed=std::mt19937_64::default_seed)`  

    C++ includes: OperationInverseRosenblattTransformationKDE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        """
        _pysgpp_swig.OperationInverseRosenblattTransformationKDE_swiginit(self, _pysgpp_swig.new_OperationInverseRosenblattTransformationKDE(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OperationInverseRosenblattTransformationKDE

    def doTransformation(self, pointsUniform: "DataMatrix", pointsCdf: "DataMatrix") -> "void":
        r"""


        inverse Rosenblatt Transformation with mixed starting dimension  

        Parameters
        ----------
        * `pointsUniform` :  
            data points to be transformed DataMatrix (rows: # of samples, columns: # of
            dims)  
        * `pointsCdf` :  
            Output DataMatrix (rows: # of samples, columns: # of dims)  

        """
        return _pysgpp_swig.OperationInverseRosenblattTransformationKDE_doTransformation(self, pointsUniform, pointsCdf)

    def doShuffledTransformation(self, pointsUniform: "DataMatrix", pointsCdf: "DataMatrix") -> "void":
        r"""


        """
        return _pysgpp_swig.OperationInverseRosenblattTransformationKDE_doShuffledTransformation(self, pointsUniform, pointsCdf)

    def doTransformation1D(self, y: "double", samples1d: "DataVector", sigma: "double", xlower: "double", xupper: "double", ylower: "double", yupper: "double", kern: "DataVector") -> "double":
        r"""


        do the inverse Rosenblatt transformation for one data point for given samples  

        Parameters
        ----------
        * `y` :  
            data point to be inverted  
        * `samples1d` :  
            training samples in the dimension to be transformed  
        * `sigma` :  
            bandwidth of the kernels in the current dimension  
        * `xlower` :  
            lower bound for x-space  
        * `xupper` :  
            upper bound for x-space  
        * `ylower` :  
            lower bound for y-space  
        * `yupper` :  
            upper bound for y-space  
        * `kern` :  
            kernel evaluations  

        Returns
        -------
        error of inversion  

        """
        return _pysgpp_swig.OperationInverseRosenblattTransformationKDE_doTransformation1D(self, y, samples1d, sigma, xlower, xupper, ylower, yupper, kern)

    def getMaxInversionError(self) -> "double":
        r"""


        get the maximum error made during inversion  

        """
        return _pysgpp_swig.OperationInverseRosenblattTransformationKDE_getMaxInversionError(self)

# Register OperationInverseRosenblattTransformationKDE in _pysgpp_swig:
_pysgpp_swig.OperationInverseRosenblattTransformationKDE_swigregister(OperationInverseRosenblattTransformationKDE)

class OperationDensityMarginalizeKDE(object):
    r"""

    `OperationDensityMarginalizeKDE(kde)`  

    Marginalize Probability Density Function.  

    Constructors
    ------------
    * `OperationDensityMarginalizeKDE(kde)`  

    C++ includes: OperationDensityMarginalizeKDE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, kde: "KernelDensityEstimator"):
        r"""


        """
        _pysgpp_swig.OperationDensityMarginalizeKDE_swiginit(self, _pysgpp_swig.new_OperationDensityMarginalizeKDE(kde))
    __swig_destroy__ = _pysgpp_swig.delete_OperationDensityMarginalizeKDE

    def doMarginalize(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `doMarginalize(mdim, marginalizedKDE)`  

            Marginalizes (Density) functions in dimension mdim.  

            Parameters:  
            * `mdim` :  
                marginalize in dimension mdim  
            * `marginalizedKDE` :  
                marginalized kernel density  

        * `doMarginalize(mdims, marginalizedKDE)`  

            Marginalizes (Density) functions in all dimensions mdims.  

            Parameters:  
            * `mdims` :  
                marginalized in all dimensions in mdims  
            * `marginalizedKDE` :  
                marginalized kernel density  

        """
        return _pysgpp_swig.OperationDensityMarginalizeKDE_doMarginalize(self, *args)

    def margToDimX(self, mdim: "size_t", marginalizedKDE: "KernelDensityEstimator") -> "void":
        r"""


        Keep applying marginalizes to (Density) Functions, until it's reduced to 1
        dimension (dim_x)  

        Parameters
        ----------
        * `mdim` :  
            Target dimension, all other dimensions will be marginalized  
        * `marginalizedKDE` :  
            result of marginalization  

        """
        return _pysgpp_swig.OperationDensityMarginalizeKDE_margToDimX(self, mdim, marginalizedKDE)

    def margToDimXs(self, mdims: "SizeVector", marginalizedKDE: "KernelDensityEstimator") -> "void":
        r"""


        Keep applying marginalizes to (Density) Functions, until it's reduced to the
        dimensions in mdims.  

        Parameters
        ----------
        * `mdims` :  
            Target dimensions, all other dimensions will be marginalized  
        * `marginalizedKDE` :  
            result of marginalization  

        """
        return _pysgpp_swig.OperationDensityMarginalizeKDE_margToDimXs(self, mdims, marginalizedKDE)

# Register OperationDensityMarginalizeKDE in _pysgpp_swig:
_pysgpp_swig.OperationDensityMarginalizeKDE_swigregister(OperationDensityMarginalizeKDE)

class OperationDensityConditionalKDE(object):
    r"""

    `OperationDensityConditionalKDE(kde)`  

    Constructors
    ------------
    * `OperationDensityConditionalKDE(kde)`  

    C++ includes: OperationDensityConditionalKDE.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, kde: "KernelDensityEstimator"):
        r"""


        """
        _pysgpp_swig.OperationDensityConditionalKDE_swiginit(self, _pysgpp_swig.new_OperationDensityConditionalKDE(kde))
    __swig_destroy__ = _pysgpp_swig.delete_OperationDensityConditionalKDE

    def doConditional(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `doConditional(mdim, xbar, conditionalizedKDE)`  

            Conditional (Density) Functions.  

            Parameters:  
            * `mdim` :  
                Marginalize in dimension mdim  
            * `xbar` :  
                Point at which to conditionalize  
            * `conditionalizedKDE` :  
                conditionalized kernel density  

        * `doConditional(mdims, xbar, conditionalizedKDE)`  

            Conditional (Density) Functions.  

            Parameters:  
            * `mdims` :  
                Conditionalize in dimensions mdims  
            * `xbar` :  
                Point at which to conditionalize  
            * `conditionalizedKDE` :  
                conditionalized kernel density  

        """
        return _pysgpp_swig.OperationDensityConditionalKDE_doConditional(self, *args)

    def condToDimX(self, mdim: "size_t", xbar: "DataVector", conditionalizedKDE: "KernelDensityEstimator") -> "void":
        r"""


        Conditional (Density) Functions to a 1d density where the remaining dimension is
        mdim.  

        Parameters
        ----------
        * `mdim` :  
            conditionalize all dimensions but mdim  
        * `xbar` :  
            point at which to conditionalize  
        * `conditionalizedKDE` :  
            conditionalized kernel density  

        """
        return _pysgpp_swig.OperationDensityConditionalKDE_condToDimX(self, mdim, xbar, conditionalizedKDE)

    def condToDimXs(self, mdims: "SizeVector", xbar: "DataVector", conditionalizedKDE: "KernelDensityEstimator") -> "void":
        r"""


        Conditional (Density) Functions to a dd density where the remaining dimensions
        are mdims.  

        Parameters
        ----------
        * `mdims` :  
            conditionalize all dimensions but the ones in mdims  
        * `xbar` :  
            point at which to conditionalize  
        * `conditionalizedKDE` :  
            conditionalized kernel density  

        """
        return _pysgpp_swig.OperationDensityConditionalKDE_condToDimXs(self, mdims, xbar, conditionalizedKDE)

# Register OperationDensityConditionalKDE in _pysgpp_swig:
_pysgpp_swig.OperationDensityConditionalKDE_swigregister(OperationDensityConditionalKDE)

class OperationDensityMarginalize(object):
    r"""

    `OperationDensityMarginalize(grid)`  

    Marginalize Probability Density Function.  

    Constructors
    ------------
    * `OperationDensityMarginalize(grid)`  

    C++ includes: OperationDensityMarginalize.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid"):
        r"""


        """
        _pysgpp_swig.OperationDensityMarginalize_swiginit(self, _pysgpp_swig.new_OperationDensityMarginalize(grid))
    __swig_destroy__ = _pysgpp_swig.delete_OperationDensityMarginalize

    def doMarginalize(self, alpha: "DataVector", mg: "sgpp::base::Grid *&", malpha: "DataVector", mdim: "unsigned int") -> "void":
        r"""


        Marginalizes (Density) Functions.  

        Parameters
        ----------
        * `alpha` :  
            Coefficient vector for current grid  
        * `mg` :  
            Referenz of grid pointer  
        * `malpha` :  
            Coefficient vector for new grid (mg). Will be resized.  
        * `mdim` :  
            Marginalize in dimension mdim  

        Note: Because of adaptively refined sparse grids, we cannot simply generate a
        regular grid. Thus, we need to add point after point to the new grid mg  

        Compute coefficients for marginalized density Each coefficient has to be
        weighted with the integral of the basis functions in direction mdim  

        Attention: The integral of one basis functions changes for if another type of
        basis is used!  

        """
        return _pysgpp_swig.OperationDensityMarginalize_doMarginalize(self, alpha, mg, malpha, mdim)

# Register OperationDensityMarginalize in _pysgpp_swig:
_pysgpp_swig.OperationDensityMarginalize_swigregister(OperationDensityMarginalize)

class OperationDensityMargTo1D(object):
    r"""

    `OperationDensityMargTo1D(grid)`  

    Marginalize Probability Density Function.  

    Constructors
    ------------
    * `OperationDensityMargTo1D(grid)`  

    C++ includes: OperationDensityMargTo1D.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "Grid"):
        r"""


        """
        _pysgpp_swig.OperationDensityMargTo1D_swiginit(self, _pysgpp_swig.new_OperationDensityMargTo1D(grid))
    __swig_destroy__ = _pysgpp_swig.delete_OperationDensityMargTo1D

    def margToDimX(self, alpha: "DataVector", grid_x: "sgpp::base::Grid *&", alpha_x: "sgpp::base::DataVector *&", dim_x: "size_t") -> "void":
        r"""


        Keep applying marginalizes to (Density) Functions, until it's reduced to 1
        dimension (dim_x)  

        Parameters
        ----------
        * `alpha` :  
            Coefficient vector for current grid  
        * `grid_x` :  
            output 1D grid pointer  
        * `alpha_x` :  
            Coefficient vector for new grid (grid_x). Will be initialized.  
        * `dim_x` :  
            Target dimension, all other dimensions will be marginalized  

        """
        return _pysgpp_swig.OperationDensityMargTo1D_margToDimX(self, alpha, grid_x, alpha_x, dim_x)

    def margToDimXs(self, alpha: "DataVector", grid_x: "sgpp::base::Grid *&", alpha_x: "sgpp::base::DataVector *&", dim_x: "SizeVector") -> "void":
        r"""


        Keep applying marginalizes to (Density) Functions, until it's reduced to d
        dimensions (dim_x)  

        Parameters
        ----------
        * `alpha` :  
            Coefficient vector for current grid  
        * `grid_x` :  
            output 1D grid pointer  
        * `alpha_x` :  
            Coefficient vector for new grid (grid_x). Will be initialized.  
        * `dim_x` :  
            Target dimension, all other dimensions will be marginalized  

        """
        return _pysgpp_swig.OperationDensityMargTo1D_margToDimXs(self, alpha, grid_x, alpha_x, dim_x)

# Register OperationDensityMargTo1D in _pysgpp_swig:
_pysgpp_swig.OperationDensityMargTo1D_swigregister(OperationDensityMargTo1D)

class HashGridPointCompare(object):
    r"""


    C++ includes: OperationMakePositiveCandidateSetAlgorithm.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pysgpp_swig.HashGridPointCompare_swiginit(self, _pysgpp_swig.new_HashGridPointCompare())
    __swig_destroy__ = _pysgpp_swig.delete_HashGridPointCompare

# Register HashGridPointCompare in _pysgpp_swig:
_pysgpp_swig.HashGridPointCompare_swigregister(HashGridPointCompare)

class OperationMakePositiveCandidateSetAlgorithm(object):
    r"""

    `OperationMakePositiveCandidateSetAlgorithm(maxLevel)`  

    Constructors
    ------------
    * `OperationMakePositiveCandidateSetAlgorithm(maxLevel)`  

        Constructor.  

        Parameters:  
        * `maxLevel` :  
            maximum level for candidate set  

    C++ includes: OperationMakePositiveCandidateSetAlgorithm.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationMakePositiveCandidateSetAlgorithm

    def nextCandidates(self, grid: "Grid", alpha: "DataVector", levelSum: "size_t", candidates: "std::vector< std::shared_ptr< sgpp::base::HashGridPoint >,std::allocator< std::shared_ptr< sgpp::base::HashGridPoint > > > &") -> "void":
        r"""


        Load the next candidate set that contains grid points with the currently
        explored levelsum.  

        Parameters
        ----------
        * `grid` :  
            current sparse grid that needs to be extended  
        * `alpha` :  
            corresponding coefficient vector  
        * `levelSum` :  
            current levelsum to be explored  
        * `candidates` :  
            vector that contains the candidate set for the current levelsum  

        """
        return _pysgpp_swig.OperationMakePositiveCandidateSetAlgorithm_nextCandidates(self, grid, alpha, levelSum, candidates)

    def numCandidatesPerLevel(self) -> "sgpp::base::DataVector &":
        r"""


        Returns
        -------
        number of candidates that have been computed per levelsum  

        """
        return _pysgpp_swig.OperationMakePositiveCandidateSetAlgorithm_numCandidatesPerLevel(self)

    def costsComputingCandidates(self) -> "size_t":
        r"""


        Returns
        -------
        number of comparisons that have been computed in total  

        """
        return _pysgpp_swig.OperationMakePositiveCandidateSetAlgorithm_costsComputingCandidates(self)

    def costsComputingCandidatesPerIteration(self) -> "sgpp::base::DataVector &":
        r"""


        Returns
        -------
        number of comparisons that have been computed per iteration  

        """
        return _pysgpp_swig.OperationMakePositiveCandidateSetAlgorithm_costsComputingCandidatesPerIteration(self)

    def numCandidates(self) -> "size_t":
        r"""


        Returns
        -------
        total number of candidates  

        """
        return _pysgpp_swig.OperationMakePositiveCandidateSetAlgorithm_numCandidates(self)

    def numCandidatesPerIteration(self) -> "sgpp::base::DataVector &":
        r"""


        Returns
        -------
        number of candidates that have been computed per iteration  

        """
        return _pysgpp_swig.OperationMakePositiveCandidateSetAlgorithm_numCandidatesPerIteration(self)

    def setVerbose(self, pverbose: "bool") -> "void":
        r"""


        Set verbosity level.  

        Parameters
        ----------
        * `pverbose` :  
            verbosity level  

        """
        return _pysgpp_swig.OperationMakePositiveCandidateSetAlgorithm_setVerbose(self, pverbose)

# Register OperationMakePositiveCandidateSetAlgorithm in _pysgpp_swig:
_pysgpp_swig.OperationMakePositiveCandidateSetAlgorithm_swigregister(OperationMakePositiveCandidateSetAlgorithm)

class OperationMakePositiveFindIntersectionCandidates(OperationMakePositiveCandidateSetAlgorithm):
    r"""

    `OperationMakePositiveFindIntersectionCandidates(maxLevel)`  

    Constructors
    ------------
    * `OperationMakePositiveFindIntersectionCandidates(maxLevel)`  

    C++ includes: OperationMakePositiveCandidateSetAlgorithm.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, maxLevel: "size_t"):
        r"""


        """
        _pysgpp_swig.OperationMakePositiveFindIntersectionCandidates_swiginit(self, _pysgpp_swig.new_OperationMakePositiveFindIntersectionCandidates(maxLevel))
    __swig_destroy__ = _pysgpp_swig.delete_OperationMakePositiveFindIntersectionCandidates

# Register OperationMakePositiveFindIntersectionCandidates in _pysgpp_swig:
_pysgpp_swig.OperationMakePositiveFindIntersectionCandidates_swigregister(OperationMakePositiveFindIntersectionCandidates)

class OperationMakePositiveFindIntersectionCandidatesJoin(OperationMakePositiveFindIntersectionCandidates):
    r"""

    `OperationMakePositiveFindIntersectionCandidatesJoin(maxLevel)`  

    Constructors
    ------------
    * `OperationMakePositiveFindIntersectionCandidatesJoin(maxLevel)`  

    C++ includes: OperationMakePositiveCandidateSetAlgorithm.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, maxLevel: "size_t"):
        r"""


        """
        _pysgpp_swig.OperationMakePositiveFindIntersectionCandidatesJoin_swiginit(self, _pysgpp_swig.new_OperationMakePositiveFindIntersectionCandidatesJoin(maxLevel))
    __swig_destroy__ = _pysgpp_swig.delete_OperationMakePositiveFindIntersectionCandidatesJoin

# Register OperationMakePositiveFindIntersectionCandidatesJoin in _pysgpp_swig:
_pysgpp_swig.OperationMakePositiveFindIntersectionCandidatesJoin_swigregister(OperationMakePositiveFindIntersectionCandidatesJoin)

class OperationMakePositiveLoadFullGridCandidates(OperationMakePositiveCandidateSetAlgorithm):
    r"""

    `OperationMakePositiveLoadFullGridCandidates(maxLevel)`  

    Constructors
    ------------
    * `OperationMakePositiveLoadFullGridCandidates(maxLevel)`  

    C++ includes: OperationMakePositiveCandidateSetAlgorithm.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, maxLevel: "size_t"):
        r"""


        """
        _pysgpp_swig.OperationMakePositiveLoadFullGridCandidates_swiginit(self, _pysgpp_swig.new_OperationMakePositiveLoadFullGridCandidates(maxLevel))
    __swig_destroy__ = _pysgpp_swig.delete_OperationMakePositiveLoadFullGridCandidates

# Register OperationMakePositiveLoadFullGridCandidates in _pysgpp_swig:
_pysgpp_swig.OperationMakePositiveLoadFullGridCandidates_swigregister(OperationMakePositiveLoadFullGridCandidates)

class OperationMakePositiveHybridFindIntersectionCandidates(OperationMakePositiveFindIntersectionCandidates):
    r"""

    `OperationMakePositiveHybridFindIntersectionCandidates(maxLevel)`  

    Constructors
    ------------
    * `OperationMakePositiveHybridFindIntersectionCandidates(maxLevel)`  

    C++ includes: OperationMakePositiveCandidateSetAlgorithm.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, maxLevel: "size_t"):
        r"""


        """
        _pysgpp_swig.OperationMakePositiveHybridFindIntersectionCandidates_swiginit(self, _pysgpp_swig.new_OperationMakePositiveHybridFindIntersectionCandidates(maxLevel))
    __swig_destroy__ = _pysgpp_swig.delete_OperationMakePositiveHybridFindIntersectionCandidates

    def findIntersections(self, grid: "Grid", alpha: "DataVector", levelSum: "size_t", res: "std::unordered_map< size_t,std::shared_ptr< sgpp::base::HashGridPoint > > &") -> "void":
        r"""


        """
        return _pysgpp_swig.OperationMakePositiveHybridFindIntersectionCandidates_findIntersections(self, grid, alpha, levelSum, res)

# Register OperationMakePositiveHybridFindIntersectionCandidates in _pysgpp_swig:
_pysgpp_swig.OperationMakePositiveHybridFindIntersectionCandidates_swigregister(OperationMakePositiveHybridFindIntersectionCandidates)

MakePositiveCandidateSearchAlgorithm_FullGrid = _pysgpp_swig.MakePositiveCandidateSearchAlgorithm_FullGrid
MakePositiveCandidateSearchAlgorithm_Intersections = _pysgpp_swig.MakePositiveCandidateSearchAlgorithm_Intersections
MakePositiveCandidateSearchAlgorithm_HybridFullIntersections = _pysgpp_swig.MakePositiveCandidateSearchAlgorithm_HybridFullIntersections
MakePositiveCandidateSearchAlgorithm_IntersectionsJoin = _pysgpp_swig.MakePositiveCandidateSearchAlgorithm_IntersectionsJoin
MakePositiveInterpolationAlgorithm_SetToZero = _pysgpp_swig.MakePositiveInterpolationAlgorithm_SetToZero
MakePositiveInterpolationAlgorithm_InterpolateExp = _pysgpp_swig.MakePositiveInterpolationAlgorithm_InterpolateExp
MakePositiveInterpolationAlgorithm_InterpolateBoundaries1d = _pysgpp_swig.MakePositiveInterpolationAlgorithm_InterpolateBoundaries1d
MakePositiveInterpolationAlgorithm_InterpolateFunction = _pysgpp_swig.MakePositiveInterpolationAlgorithm_InterpolateFunction
class OperationMakePositive(object):
    r"""

    `OperationMakePositive(candidateSearchAlgorithm=MakePositiveCandidateSearchAlgor
        ithm::IntersectionsJoin,
        interpolationAlgorithm=MakePositiveInterpolationAlgorithm::SetToZero,
        generateConsistentGrid=true, verbose=false, f=nullptr)`  

    This class enforces the function value range of a sparse grid function to be
    larger than 0.  

    It uses a discretization based approach where we add the minimum amount of full
    grid points to enforce the positivity.  

    Constructors
    ------------
    * `OperationMakePositive(candidateSearchAlgorithm=MakePositiveCandidateSearchAlg
        orithm::IntersectionsJoin,
        interpolationAlgorithm=MakePositiveInterpolationAlgorithm::SetToZero,
        generateConsistentGrid=true, verbose=false, f=nullptr)`  

        Constructor.  

        Parameters:  
        * `candidateSearchAlgorithm` :  
            defines how to generate the full grid candidate set  
        * `interpolationAlgorithm` :  
            defines how to compute the coefficients for the new grid points  
        * `generateConsistentGrid` :  
            define if the hierarchical ancestors of all new grid points are inserted
            as well  
        * `verbose` :  
            print information or not  
        * `f` :  
            scalar function to be interpolated  

    C++ includes: OperationMakePositive.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Constructor.  

        Parameters
        ----------
        * `candidateSearchAlgorithm` :  
            defines how to generate the full grid candidate set  
        * `interpolationAlgorithm` :  
            defines how to compute the coefficients for the new grid points  
        * `generateConsistentGrid` :  
            define if the hierarchical ancestors of all new grid points are inserted as
            well  
        * `verbose` :  
            print information or not  
        * `f` :  
            scalar function to be interpolated  

        """
        _pysgpp_swig.OperationMakePositive_swiginit(self, _pysgpp_swig.new_OperationMakePositive(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OperationMakePositive

    def initialize(self, grid: "Grid", alpha: "DataVector") -> "void":
        r"""


        initializes the operation  

        Parameters
        ----------
        * `grid` :  
            Grid  
        * `alpha` :  
            coefficients  

        """
        return _pysgpp_swig.OperationMakePositive_initialize(self, grid, alpha)

    def makePositive(self, grid: "Grid", alpha: "DataVector", forcePositiveNodalValues: "bool"=False) -> "void":
        r"""


        Make the sparse grid function defined by grid and coefficient vector positive.  

        Parameters
        ----------
        * `grid` :  
            Grid where the new grid is stored  
        * `alpha` :  
            coefficient vector of new grid  
        * `forcePositiveNodalValues` :  
            nodal values are forced to be non-negative or not  

        """
        return _pysgpp_swig.OperationMakePositive_makePositive(self, grid, alpha, forcePositiveNodalValues)

    def makeCurrentNodalValuesPositive(self, grid: "Grid", alpha: "DataVector", tol: "double"=-1e-14) -> "void":
        r"""


        Enforce the function values at each grid point to larger than the specified
        tolerance.  

        The ones which are not are set to zero. For this function we need the
        hierarchization and dechierarchization operations.  

        Parameters
        ----------
        * `grid` :  
            grid  
        * `alpha` :  
            coefficient vector  
        * `tol` :  
            tolerance for negativity  

        """
        return _pysgpp_swig.OperationMakePositive_makeCurrentNodalValuesPositive(self, grid, alpha, tol)

    def getAddedGridPoints(self) -> "std::vector< size_t,std::allocator< size_t > > &":
        r"""


        Returns
        -------
        vector containing the indices of the added grid points  

        """
        return _pysgpp_swig.OperationMakePositive_getAddedGridPoints(self)

    def getAddedGridPointsForPositivity(self) -> "std::vector< size_t,std::allocator< size_t > > &":
        r"""


        Returns
        -------
        vector containing the indices which have just been added for positivity  

        """
        return _pysgpp_swig.OperationMakePositive_getAddedGridPointsForPositivity(self)

    def numAddedGridPoints(self) -> "size_t":
        r"""


        Returns
        -------
        number of newly added grid points  

        """
        return _pysgpp_swig.OperationMakePositive_numAddedGridPoints(self)

    def numAddedGridPointsForPositivity(self) -> "size_t":
        r"""


        Returns
        -------
        number of newly added grid points for guaranteeing positivity  

        """
        return _pysgpp_swig.OperationMakePositive_numAddedGridPointsForPositivity(self)

    def numAddedGridPointsForPositivityPerIteration(self) -> "sgpp::base::DataVector &":
        r"""


        Returns
        -------
        number of newly added grid points for guaranteeing positivity per iteration  

        """
        return _pysgpp_swig.OperationMakePositive_numAddedGridPointsForPositivityPerIteration(self)

    def getCandidateSetAlgorithm(self) -> "sgpp::datadriven::OperationMakePositiveCandidateSetAlgorithm &":
        r"""


        Returns
        -------
        candidate set algorithm  

        """
        return _pysgpp_swig.OperationMakePositive_getCandidateSetAlgorithm(self)

# Register OperationMakePositive in _pysgpp_swig:
_pysgpp_swig.OperationMakePositive_swigregister(OperationMakePositive)

class OperationLimitFunctionValueRange(object):
    r"""

    `OperationLimitFunctionValueRange(candiateSearch=MakePositiveCandidateSearchAlgo
        rithm::Intersections,
        interpolationAlgorithm=MakePositiveInterpolationAlgorithm::SetToZero,
        f=nullptr)`  

    Constructors
    ------------
    * `OperationLimitFunctionValueRange(candiateSearch=MakePositiveCandidateSearchAl
        gorithm::Intersections,
        interpolationAlgorithm=MakePositiveInterpolationAlgorithm::SetToZero,
        f=nullptr)`  

    C++ includes: OperationLimitFunctionValueRange.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        """
        _pysgpp_swig.OperationLimitFunctionValueRange_swiginit(self, _pysgpp_swig.new_OperationLimitFunctionValueRange(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OperationLimitFunctionValueRange

    def doLowerLimitation(self, grid: "Grid", alpha: "DataVector", ylower: "double", limitNodalValues: "bool"=True) -> "void":
        r"""


        """
        return _pysgpp_swig.OperationLimitFunctionValueRange_doLowerLimitation(self, grid, alpha, ylower, limitNodalValues)

    def doUpperLimitation(self, grid: "Grid", alpha: "DataVector", yupper: "double", limitNodalValues: "bool"=True) -> "void":
        r"""


        """
        return _pysgpp_swig.OperationLimitFunctionValueRange_doUpperLimitation(self, grid, alpha, yupper, limitNodalValues)

    def doLimitation(self, grid: "Grid", alpha: "DataVector", ylower: "double", yupper: "double", limitNodalValues: "bool"=True) -> "void":
        r"""


        """
        return _pysgpp_swig.OperationLimitFunctionValueRange_doLimitation(self, grid, alpha, ylower, yupper, limitNodalValues)

    def getAddedGridPoints(self) -> "std::vector< size_t,std::allocator< size_t > > &":
        r"""


        Returns
        -------
        vector containing the indices of the added grid points  

        """
        return _pysgpp_swig.OperationLimitFunctionValueRange_getAddedGridPoints(self)

    def getAddedGridPointsForRangeLimitation(self) -> "std::vector< size_t,std::allocator< size_t > > &":
        r"""


        Returns
        -------
        vector containing the indices which have just been added for range limiting  

        """
        return _pysgpp_swig.OperationLimitFunctionValueRange_getAddedGridPointsForRangeLimitation(self)

    def numAddedGridPoints(self) -> "size_t":
        r"""


        Returns
        -------
        number of newly added grid points  

        """
        return _pysgpp_swig.OperationLimitFunctionValueRange_numAddedGridPoints(self)

    def numAddedGridPointsForRangeLimitation(self) -> "size_t":
        r"""


        Returns
        -------
        number of newly added grid points for guaranteeing the range  

        """
        return _pysgpp_swig.OperationLimitFunctionValueRange_numAddedGridPointsForRangeLimitation(self)

# Register OperationLimitFunctionValueRange in _pysgpp_swig:
_pysgpp_swig.OperationLimitFunctionValueRange_swigregister(OperationLimitFunctionValueRange)

OperationMultipleEvalType_DEFAULT = _pysgpp_swig.OperationMultipleEvalType_DEFAULT
OperationMultipleEvalType_STREAMING = _pysgpp_swig.OperationMultipleEvalType_STREAMING
OperationMultipleEvalType_SUBSPACELINEAR = _pysgpp_swig.OperationMultipleEvalType_SUBSPACELINEAR
OperationMultipleEvalType_ADAPTIVE = _pysgpp_swig.OperationMultipleEvalType_ADAPTIVE
OperationMultipleEvalType_MORTONORDER = _pysgpp_swig.OperationMultipleEvalType_MORTONORDER
OperationMultipleEvalType_SCALAPACK = _pysgpp_swig.OperationMultipleEvalType_SCALAPACK
OperationMultipleEvalSubType_DEFAULT = _pysgpp_swig.OperationMultipleEvalSubType_DEFAULT
OperationMultipleEvalSubType_SIMPLE = _pysgpp_swig.OperationMultipleEvalSubType_SIMPLE
OperationMultipleEvalSubType_COMBINED = _pysgpp_swig.OperationMultipleEvalSubType_COMBINED
OperationMultipleEvalSubType_OCL = _pysgpp_swig.OperationMultipleEvalSubType_OCL
OperationMultipleEvalSubType_OCLFASTMP = _pysgpp_swig.OperationMultipleEvalSubType_OCLFASTMP
OperationMultipleEvalSubType_OCLMP = _pysgpp_swig.OperationMultipleEvalSubType_OCLMP
OperationMultipleEvalSubType_OCLMASKMP = _pysgpp_swig.OperationMultipleEvalSubType_OCLMASKMP
OperationMultipleEvalSubType_OCLOPT = _pysgpp_swig.OperationMultipleEvalSubType_OCLOPT
OperationMultipleEvalSubType_OCLUNIFIED = _pysgpp_swig.OperationMultipleEvalSubType_OCLUNIFIED
OperationMultipleEvalSubType_CUDA = _pysgpp_swig.OperationMultipleEvalSubType_CUDA
OperationMultipleEvalMPIType_NONE = _pysgpp_swig.OperationMultipleEvalMPIType_NONE
OperationMultipleEvalMPIType_MASTERSLAVE = _pysgpp_swig.OperationMultipleEvalMPIType_MASTERSLAVE
OperationMultipleEvalMPIType_HPX = _pysgpp_swig.OperationMultipleEvalMPIType_HPX
class OperationMultipleEvalConfiguration(object):
    r"""

    `OperationMultipleEvalConfiguration(type, subType, parameters,
        name="unnamed")`  
    `OperationMultipleEvalConfiguration(type, subType, mpiType, parameters,
        name="unnamed")`  
    `OperationMultipleEvalConfiguration(type=OperationMultipleEvalType::DEFAULT,
        subType=OperationMultipleEvalSubType::DEFAULT,
        mpiType=OperationMultipleEvalMPIType::NONE, name="unnamed")`  

    Constructors
    ------------
    * `OperationMultipleEvalConfiguration(type, subType, parameters,
        name="unnamed")`  

    * `OperationMultipleEvalConfiguration(type, subType, mpiType, parameters,
        name="unnamed")`  

    * `OperationMultipleEvalConfiguration(type=OperationMultipleEvalType::DEFAULT,
        subType=OperationMultipleEvalSubType::DEFAULT,
        mpiType=OperationMultipleEvalMPIType::NONE, name="unnamed")`  

    C++ includes: DatadrivenOperationCommon.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `OperationMultipleEvalConfiguration(type, subType, parameters,
            name="unnamed")`  

        * `OperationMultipleEvalConfiguration(type, subType, mpiType, parameters,
            name="unnamed")`  

        * `OperationMultipleEvalConfiguration(type=OperationMultipleEvalType::DEFAULT,
            subType=OperationMultipleEvalSubType::DEFAULT,
            mpiType=OperationMultipleEvalMPIType::NONE, name="unnamed")`  

        """
        _pysgpp_swig.OperationMultipleEvalConfiguration_swiginit(self, _pysgpp_swig.new_OperationMultipleEvalConfiguration(*args))

    def getMPIType(self) -> "sgpp::datadriven::OperationMultipleEvalMPIType":
        r"""


        """
        return _pysgpp_swig.OperationMultipleEvalConfiguration_getMPIType(self)

    def getType(self) -> "sgpp::datadriven::OperationMultipleEvalType":
        r"""


        """
        return _pysgpp_swig.OperationMultipleEvalConfiguration_getType(self)

    def getSubType(self) -> "sgpp::datadriven::OperationMultipleEvalSubType":
        r"""


        """
        return _pysgpp_swig.OperationMultipleEvalConfiguration_getSubType(self)

    def getParameters(self) -> "std::shared_ptr< sgpp::base::OperationConfiguration >":
        r"""


        """
        return _pysgpp_swig.OperationMultipleEvalConfiguration_getParameters(self)

    def getName(self) -> "std::string &":
        r"""


        """
        return _pysgpp_swig.OperationMultipleEvalConfiguration_getName(self)
    __swig_destroy__ = _pysgpp_swig.delete_OperationMultipleEvalConfiguration

# Register OperationMultipleEvalConfiguration in _pysgpp_swig:
_pysgpp_swig.OperationMultipleEvalConfiguration_swigregister(OperationMultipleEvalConfiguration)

class HeterogeneousBasis(object):
    r"""

    `HeterogeneousBasis()`  
    `HeterogeneousBasis(bases1d, isHierarchical=true)`  
    `HeterogeneousBasis(bases1d, isHierarchical=true)`  
    `HeterogeneousBasis(dim, basis1d, isHierarchical=true)`  

    Potentially hetereogeneous basis on full grids, i.e., a `dim`-dimensional vector
    of 1D bases of type sgpp::base::Basis.  

    In every dimension, a different basis may be used (or the same basis may be used
    for all dimensions).  

    Constructors
    ------------
    * `HeterogeneousBasis()`  

        Default constructor, corresponds to the zero-dimensional case.  

    * `HeterogeneousBasis(bases1d, isHierarchical=true)`  

        Constructor.  

        Parameters:  
        * `bases1d` :  
            vector of pointers to 1D bases (do not delete before this object)  
        * `isHierarchical` :  
            whether the basis is hierarchical or nodal  

    * `HeterogeneousBasis(bases1d, isHierarchical=true)`  

        Constructor.  

        Parameters:  
        * `bases1d` :  
            vector of unique_ptr to 1D bases (do not destruct before this object)  
        * `isHierarchical` :  
            whether the basis is hierarchical or nodal  

    * `HeterogeneousBasis(dim, basis1d, isHierarchical=true)`  

        Constructor for the case in which the same basis should be used for all
        dimensions.  

        Parameters:  
        * `dim` :  
            dimensionality  
        * `basis1d` :  
            1D basis (do not destruct before this object)  
        * `isHierarchical` :  
            whether the basis is hierarchical or nodal  

    C++ includes: HeterogeneousBasis.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `HeterogeneousBasis()`  

            Default constructor, corresponds to the zero-dimensional case.  

        * `HeterogeneousBasis(bases1d, isHierarchical=true)`  

            Constructor.  

            Parameters:  
            * `bases1d` :  
                vector of pointers to 1D bases (do not delete before this object)  
            * `isHierarchical` :  
                whether the basis is hierarchical or nodal  

        * `HeterogeneousBasis(bases1d, isHierarchical=true)`  

            Constructor.  

            Parameters:  
            * `bases1d` :  
                vector of unique_ptr to 1D bases (do not destruct before this object)  
            * `isHierarchical` :  
                whether the basis is hierarchical or nodal  

        * `HeterogeneousBasis(dim, basis1d, isHierarchical=true)`  

            Constructor for the case in which the same basis should be used for all
            dimensions.  

            Parameters:  
            * `dim` :  
                dimensionality  
            * `basis1d` :  
                1D basis (do not destruct before this object)  
            * `isHierarchical` :  
                whether the basis is hierarchical or nodal  

        """
        _pysgpp_swig.HeterogeneousBasis_swiginit(self, _pysgpp_swig.new_HeterogeneousBasis(*args))

    def __eq__(self, other: "HeterogeneousBasis") -> "bool":
        return _pysgpp_swig.HeterogeneousBasis___eq__(self, other)

    def __ne__(self, other: "HeterogeneousBasis") -> "bool":
        return _pysgpp_swig.HeterogeneousBasis___ne__(self, other)

    @staticmethod
    def hierarchizeLevelIndex(*args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `hierarchizeLevelIndex(level, index)`  

            Hierarchize level/index pair.  

            For every level $\ell \ge 0$ and index $i = 0, \dotsc, 2^\ell$, there is
            a unique level $0 \le \tilde{\ell} \le \ell$ and index $\tilde{i} = 0,
            \dotsc, 2^\tilde{\ell}$ such that  

            *   $i 2^{-\ell} =: x_{l,i} = x_{\tilde{l},\tilde{i}} := \tilde{i}
                2^{-\tilde{\ell}}$ and  
            *   $\tilde{i}$ is odd or $\tilde{l} = 0$.  

            Parameters:  
            * `level` :  
                $\ell$ before calling, $\tilde{\ell}$ after calling  
            * `index` :  
                $i$ before calling, $\tilde{i}$ after calling  

        * `hierarchizeLevelIndex(level, index)`  

            Hierarchize pair of level/index multi-indices.  

            Applies 1D version to each dimension.  

            Parameters:  
            * `level` :  
                $\vec{\ell}$ before calling, $\tilde{\vec{\ell}}$ after calling  
            * `index` :  
                $\vec{i}$ before calling, $\vec{\tilde{i}}$ after calling  

        * `hierarchizeLevelIndex(levels, indices)`  

            Hierarchize vector of level/index multi-indices.  

            Applies multi-index version to every entry.  

            Parameters:  
            * `levels` :  
                vector of $\vec{\ell}$ before calling, vector of
                $\tilde{\vec{\ell}}$ after calling  
            * `indices` :  
                vector of $\vec{i}$ before calling, vector of $\vec{\tilde{i}}$ after
                calling  

        """
        return _pysgpp_swig.HeterogeneousBasis_hierarchizeLevelIndex(*args)

    def eval(self, level: "LevelVector", index: "LevelVector", point: "DataVector") -> "double":
        r"""


        Evaluate basis function of given level and index at given point as the tensor
        product of the 1D bases.  

        If the basis is hierarchical, `hierarchizeLevelIndex` will be called before
        evaluating the 1D bases.  

        Parameters
        ----------
        * `level` :  
            level of the basis function  
        * `index` :  
            index of the basis function  
        * `point` :  
            point at which to evaluate the basis function  

        Returns
        -------
        value of the basis function at the given point  

        """
        return _pysgpp_swig.HeterogeneousBasis_eval(self, level, index, point)

    def getDimension(self) -> "size_t":
        r"""


        Returns
        -------
        dimensionality  

        """
        return _pysgpp_swig.HeterogeneousBasis_getDimension(self)

    def getBases1d(self) -> "std::vector< sgpp::base::Basis< sgpp::base::level_t,sgpp::base::index_t > *,std::allocator< sgpp::base::Basis< sgpp::base::level_t,sgpp::base::index_t > * > > const &":
        r"""


        Returns
        -------
        vector of pointers to 1D bases (do not delete before this object)  

        """
        return _pysgpp_swig.HeterogeneousBasis_getBases1d(self)

    def setBases1D(self, bases1d: "BasisVector") -> "void":
        r"""


        Parameters
        ----------
        * `bases1d` :  
            vector of pointers to 1D bases (do not delete before this object)  

        """
        return _pysgpp_swig.HeterogeneousBasis_setBases1D(self, bases1d)

    def isHierarchical(self) -> "bool":
        r"""


        Returns
        -------
        whether the basis is hierarchical or nodal  

        """
        return _pysgpp_swig.HeterogeneousBasis_isHierarchical(self)

    def setIsHierarchical(self, isHierarchical: "bool") -> "void":
        r"""


        Parameters
        ----------
        * `isHierarchical` :  
            whether the basis is hierarchical or nodal  

        """
        return _pysgpp_swig.HeterogeneousBasis_setIsHierarchical(self, isHierarchical)
    __swig_destroy__ = _pysgpp_swig.delete_HeterogeneousBasis

# Register HeterogeneousBasis in _pysgpp_swig:
_pysgpp_swig.HeterogeneousBasis_swigregister(HeterogeneousBasis)

def HeterogeneousBasis_hierarchizeLevelIndex(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `hierarchizeLevelIndex(level, index)`  

        Hierarchize level/index pair.  

        For every level $\ell \ge 0$ and index $i = 0, \dotsc, 2^\ell$, there is
        a unique level $0 \le \tilde{\ell} \le \ell$ and index $\tilde{i} = 0,
        \dotsc, 2^\tilde{\ell}$ such that  

        *   $i 2^{-\ell} =: x_{l,i} = x_{\tilde{l},\tilde{i}} := \tilde{i}
            2^{-\tilde{\ell}}$ and  
        *   $\tilde{i}$ is odd or $\tilde{l} = 0$.  

        Parameters:  
        * `level` :  
            $\ell$ before calling, $\tilde{\ell}$ after calling  
        * `index` :  
            $i$ before calling, $\tilde{i}$ after calling  

    * `hierarchizeLevelIndex(level, index)`  

        Hierarchize pair of level/index multi-indices.  

        Applies 1D version to each dimension.  

        Parameters:  
        * `level` :  
            $\vec{\ell}$ before calling, $\tilde{\vec{\ell}}$ after calling  
        * `index` :  
            $\vec{i}$ before calling, $\vec{\tilde{i}}$ after calling  

    * `hierarchizeLevelIndex(levels, indices)`  

        Hierarchize vector of level/index multi-indices.  

        Applies multi-index version to every entry.  

        Parameters:  
        * `levels` :  
            vector of $\vec{\ell}$ before calling, vector of
            $\tilde{\vec{\ell}}$ after calling  
        * `indices` :  
            vector of $\vec{i}$ before calling, vector of $\vec{\tilde{i}}$ after
            calling  

    """
    return _pysgpp_swig.HeterogeneousBasis_hierarchizeLevelIndex(*args)

class FullGrid(object):
    r"""

    `FullGrid()`  
    `FullGrid(level, basis, hasBoundary=true,
        levelOccupancy=FullGrid::LevelOccupancy::TwoToThePowerOfL)`  

    Full grid essentially represented by its level and a HeterogeneousBasis.  

    Constructors
    ------------
    * `FullGrid()`  

        Default constructor, corresponds to the zero-dimensional case.  

    * `FullGrid(level, basis, hasBoundary=true,
        levelOccupancy=FullGrid::LevelOccupancy::TwoToThePowerOfL)`  

        Constructor.  

        Parameters:  
        * `level` :  
            level of the full grid  
        * `basis` :  
            type of basis functions for evaluating on the full grid  
        * `hasBoundary` :  
            whether the full grid has points on the boundary  
        * `levelOccupancy` :  
            how many points are added to the grid per level  

    C++ includes: FullGrid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LevelOccupancy_TwoToThePowerOfL = _pysgpp_swig.FullGrid_LevelOccupancy_TwoToThePowerOfL
    LevelOccupancy_Linear = _pysgpp_swig.FullGrid_LevelOccupancy_Linear

    @staticmethod
    def getNumberOfPointsFromLevel(*args) -> "sgpp::combigrid::index_t":
        r"""


        Overloaded function
        -------------------
        * `getNumberOfPointsFromLevel(level,
            levelOccupancy=FullGrid::LevelOccupancy::TwoToThePowerOfL, hasBoundary=true)
            -> index_t`  

        * `getNumberOfPointsFromLevel(level,
            levelOccupancy=FullGrid::LevelOccupancy::TwoToThePowerOfL, hasBoundary=true)
            -> index_t`  

        """
        return _pysgpp_swig.FullGrid_getNumberOfPointsFromLevel(*args)

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `FullGrid()`  

            Default constructor, corresponds to the zero-dimensional case.  

        * `FullGrid(level, basis, hasBoundary=true,
            levelOccupancy=FullGrid::LevelOccupancy::TwoToThePowerOfL)`  

            Constructor.  

            Parameters:  
            * `level` :  
                level of the full grid  
            * `basis` :  
                type of basis functions for evaluating on the full grid  
            * `hasBoundary` :  
                whether the full grid has points on the boundary  
            * `levelOccupancy` :  
                how many points are added to the grid per level  

        """
        _pysgpp_swig.FullGrid_swiginit(self, _pysgpp_swig.new_FullGrid(*args))

    def __eq__(self, other: "FullGrid") -> "bool":
        return _pysgpp_swig.FullGrid___eq__(self, other)

    def __ne__(self, other: "FullGrid") -> "bool":
        return _pysgpp_swig.FullGrid___ne__(self, other)

    def getLevel(self, *args) -> "size_t":
        r"""


        Overloaded function
        -------------------
        * `getLevel() -> LevelVector &`  

            Returns:
            level of the full grid  

        * `getLevel() -> const LevelVector &`  

            Returns:
            level of the full grid  

        * `getLevel(d) -> size_t`  

            Parameters:  
            * `d` :  
                dimension  

            Returns:
            level of the $d$-th dimension  

        """
        return _pysgpp_swig.FullGrid_getLevel(self, *args)

    def setLevel(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `setLevel(level)`  

            Parameters:  
            * `level` :  
                level of the full grid  

        * `setLevel(d, level)`  

            Parameters:  
            * `d` :  
                dimension  
            * `level` :  
                $d$-th level of the full grid  

        """
        return _pysgpp_swig.FullGrid_setLevel(self, *args)

    def getMinIndex(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `getMinIndex(index)`  

            Minimum index of grid points.  

            Parameters:  
            * `index` :  
                minimum index as multi-index  

        * `getMinIndex(d) -> index_t`  

            Minimum 1D index of grid points.  

            Parameters:  
            * `d` :  
                dimension  

            Returns:
            minimum index in the $d$-th dimension  

        """
        return _pysgpp_swig.FullGrid_getMinIndex(self, *args)

    def getMaxIndex(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `getMaxIndex(index)`  

            Maximum index of grid points.  

            Parameters:  
            * `index` :  
                maximum index as multi-index  

        * `getMaxIndex(d) -> index_t`  

            Maximum 1D index of grid points.  

            Parameters:  
            * `d` :  
                dimension  

            Returns:
            maximum index in the $d$-th dimension  

        """
        return _pysgpp_swig.FullGrid_getMaxIndex(self, *args)

    def getNumberOfIndexVectors(self, *args) -> "sgpp::combigrid::index_t":
        r"""


        Overloaded function
        -------------------
        * `getNumberOfIndexVectors() -> index_t`  

            Total number of index vectors (grid points).  

            Returns:
            number of index vectors  

        * `getNumberOfIndexVectors(number)`  

            Number of index vectors (grid points) in 1D for all dimensions.  

            Parameters:  
            * `number` :  
                vector, $d$-th entry is number of index vectors in the $d$-th dimension  

        * `getNumberOfIndexVectors(d) -> index_t`  

            Number of index vectors (grid points) in 1D.  

            Parameters:  
            * `d` :  
                dimension  

            Returns:
            number of index vectors in the $d$-th dimension  

        """
        return _pysgpp_swig.FullGrid_getNumberOfIndexVectors(self, *args)

    def getDimension(self) -> "size_t":
        r"""


        Returns
        -------
        dimensionality  

        """
        return _pysgpp_swig.FullGrid_getDimension(self)

    def hasBoundary(self) -> "bool":
        r"""


        Returns
        -------
        whether the full grid has points on the boundary  

        """
        return _pysgpp_swig.FullGrid_hasBoundary(self)

    def setHasBoundary(self, hasBoundary: "bool") -> "void":
        r"""


        Parameters
        ----------
        * `hasBoundary` :  
            whether the full grid has points on the boundary  

        """
        return _pysgpp_swig.FullGrid_setHasBoundary(self, hasBoundary)

    def getBasis(self) -> "sgpp::combigrid::HeterogeneousBasis const &":
        r"""


        Returns
        -------
        type of basis functions for evaluating on the full grid  

        """
        return _pysgpp_swig.FullGrid_getBasis(self)

    def setBasis(self, basis: "HeterogeneousBasis") -> "void":
        r"""


        Parameters
        ----------
        * `basis` :  
            type of basis functions for evaluating on the full grid  

        """
        return _pysgpp_swig.FullGrid_setBasis(self, basis)

    def getLevelOccupancy(self) -> "sgpp::combigrid::FullGrid::LevelOccupancy const &":
        r"""


        Returns
        -------
        level occupancy in the full grid  

        """
        return _pysgpp_swig.FullGrid_getLevelOccupancy(self)

    def findGridPointInFullGrid(self, gridPoint: "HashGridPoint", index: "LevelVector") -> "bool":
        r"""


        Helper function to find a grid point in the full grid.  

        Parameters
        ----------
        * `gridPoint` :  
            grid point to find  
        * `index` :  
            index of the grid point after calling (if the grid point is contained in the
            full grid)  

        Returns
        -------
        whether the grid point is in the full grid  

        """
        return _pysgpp_swig.FullGrid_findGridPointInFullGrid(self, gridPoint, index)
    __swig_destroy__ = _pysgpp_swig.delete_FullGrid

# Register FullGrid in _pysgpp_swig:
_pysgpp_swig.FullGrid_swigregister(FullGrid)

def FullGrid_getNumberOfPointsFromLevel(*args) -> "sgpp::combigrid::index_t":
    r"""


    Overloaded function
    -------------------
    * `getNumberOfPointsFromLevel(level,
        levelOccupancy=FullGrid::LevelOccupancy::TwoToThePowerOfL, hasBoundary=true)
        -> index_t`  

    * `getNumberOfPointsFromLevel(level,
        levelOccupancy=FullGrid::LevelOccupancy::TwoToThePowerOfL, hasBoundary=true)
        -> index_t`  

    """
    return _pysgpp_swig.FullGrid_getNumberOfPointsFromLevel(*args)

class CombinationGrid(object):
    r"""

    `CombinationGrid()`  
    `CombinationGrid(fullGrids, coefficients)`  

    Class for representing a collection of full grids together with one scalar
    coefficient per full grid.  

    Constructors
    ------------
    * `CombinationGrid()`  

        Default constructor, leaves the list of full grids empty.  

    * `CombinationGrid(fullGrids, coefficients)`  

        Constructor.  

        Parameters:  
        * `fullGrids` :  
            vector of full grids  
        * `coefficients` :  
            vector of coefficients, same size as `fullGrids`  

    C++ includes: CombinationGrid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `CombinationGrid()`  

            Default constructor, leaves the list of full grids empty.  

        * `CombinationGrid(fullGrids, coefficients)`  

            Constructor.  

            Parameters:  
            * `fullGrids` :  
                vector of full grids  
            * `coefficients` :  
                vector of coefficients, same size as `fullGrids`  

        """
        _pysgpp_swig.CombinationGrid_swiginit(self, _pysgpp_swig.new_CombinationGrid(*args))

    @staticmethod
    def fromRegularSparse(dim: "size_t", n: "sgpp::combigrid::level_t", basis: "HeterogeneousBasis", hasBoundary: "bool"=True) -> "sgpp::combigrid::CombinationGrid":
        r"""


        Factory method to create a CombinationGrid corresponding to the combination
        technique for a regular sparse grid.  

        Parameters
        ----------
        * `dim` :  
            dimensionality  
        * `n` :  
            sparse grid level  
        * `basis` :  
            basis of the sparse grid (will be the same for all full grids; this can be
            changed)  
        * `hasBoundary` :  
            whether the sparse grid has points on the boundary  

        Returns
        -------
        CombinationGrid corresponding to the combination technique for the regular
        sparse grid  

        """
        return _pysgpp_swig.CombinationGrid_fromRegularSparse(dim, n, basis, hasBoundary)

    @staticmethod
    def fromSubspaces(subspaceLevels: "std::vector< sgpp::combigrid::LevelVector,std::allocator< sgpp::combigrid::LevelVector > > const &", basis: "HeterogeneousBasis", hasBoundary: "bool"=True) -> "sgpp::combigrid::CombinationGrid":
        r"""


        Factory method to create a CombinationGrid corresponding to the combination
        technique for a (potentially dimensionally adaptive) sparse grid specified via
        its nodal subspaces/full grids.  

        Note: You have to specify the levels of *all* nodal subspaces, i.e., the
        specified list of subspaces has to be downward closed.  

        Parameters
        ----------
        * `subspaceLevels` :  
            vector of subspace levels  
        * `basis` :  
            basis of the sparse grid (will be the same for all full grids; this can be
            changed)  
        * `hasBoundary` :  
            whether the sparse grid has points on the boundary  

        Returns
        -------
        CombinationGrid corresponding to the combination technique for the sparse grid  

        """
        return _pysgpp_swig.CombinationGrid_fromSubspaces(subspaceLevels, basis, hasBoundary)

    def combinePoints(self, gridStorage: "HashGridStorage") -> "void":
        r"""


        Combine the grid points of all full grids of this combination grid and store the
        grid points in an existing GridStorage.  

        Parameters
        ----------
        * `gridStorage` :  
            GridStorage in which to save the grid points (will be cleared)  

        """
        return _pysgpp_swig.CombinationGrid_combinePoints(self, gridStorage)

    def combineValues(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `combineValues(values, result)`  

            Combine equally-sized vectors (one per full grid) using a weighted sum
            (weighted by the coefficients of the combination grid).  

            Parameters:  
            * `values` :  
                data matrix, same number of columns as the number of full grids (every
                column corresponds to one full grid, the order of rows is given by
                IndexVectorRange)  
            * `result` :  
                vector resulting from the combination  

        * `combineValues(values) -> double`  

            Combine scalars (one scalar per full grid) using a weighted sum (weighted by
            the coefficients of the combination grid).  

            Parameters:  
            * `values` :  
                data vector, same size as the number of full grids  

            Returns:
            value resulting from the combination  

        """
        return _pysgpp_swig.CombinationGrid_combineValues(self, *args)

    def combineSparseGridValues(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `combineSparseGridValues(gridStorage, values, result)`  

            Combine vectors associated to every full grid point using a weighted sum
            (weighted by the coefficients of the combination grid), i.e., vector version
            of the other `combineSparseGridValues` method.  

            Parameters:  
            * `gridStorage` :  
                GridStorage containing the combined grid  
            * `values` :  
                vector of DataMatrix, each DataMatrix corresponds to a full grid and has
                the same number of columns as the number of grid points of the full grid
                (every column corresponds to one full grid point, the order of columns
                is given by IndexVectorRange)  
            * `result` :  
                matrix resulting from the combination, columns have the same order as
                `gridStorage` (every column corresponds to one grid point of the
                combined grid)  

        * `combineSparseGridValues(gridStorage, values, result)`  

            Combine scalars associated to every full grid point using a weighted sum
            (weighted by the coefficients of the combination grid).  

            Hierarchization is one example: In every full grid, there is a scalar
            (hierarchical surplus) associated with every grid point. This method
            combines these grid values to have one value for each point in the combined
            grid (usually a sparse grid).  

            Parameters:  
            * `gridStorage` :  
                GridStorage containing the combined grid  
            * `values` :  
                vector of DataVector, each DataVector corresponds to a full grid and has
                the same size as the number of grid points of the full grid (the order
                of DataVector entries is given by IndexVectorRange)  
            * `result` :  
                vector resulting from the combination, same order as `gridStorage`  

        """
        return _pysgpp_swig.CombinationGrid_combineSparseGridValues(self, *args)

    def distributeValuesToFullGrid(self, gridStorage: "HashGridStorage", values: "DataVector", fullGrid: "FullGrid", result: "DataVector") -> "void":
        r"""


        Distribute values given on the combined grid to a specific full grid (which
        should be contained in this combination grid).  

        Parameters
        ----------
        * `gridStorage` :  
            GridStorage containing the combined grid  
        * `values` :  
            vector of values on the combined grid, same size as `gridStorage`  
        * `fullGrid` :  
            full grid, should be contained in this combination grid  
        * `result` :  
            vector of values on the full grid, same size as the number of grid points of
            the full grid (the order is given by IndexVectorRange)  

        """
        return _pysgpp_swig.CombinationGrid_distributeValuesToFullGrid(self, gridStorage, values, fullGrid, result)

    def distributeValuesToFullGrids(self, gridStorage: "HashGridStorage", values: "DataVector", result: "DataVectorVector") -> "void":
        r"""


        Distribute values given on the combined grid to the full grids contained in this
        combination grid.  

        Parameters
        ----------
        * `gridStorage` :  
            GridStorage containing the combined grid  
        * `values` :  
            vector of values on the combined grid, same size as `gridStorage`  
        * `result` :  
            vector of vectors with values on the full grids, every vector corresponds to
            one full grid of the combination grid, every vector has the same size as the
            number of grid points of the respective full grid (the order of DataVector
            entries is given by IndexVectorRange)  

        """
        return _pysgpp_swig.CombinationGrid_distributeValuesToFullGrids(self, gridStorage, values, result)

    def getDimension(self) -> "size_t":
        r"""


        Returns
        -------
        dimensionality  

        """
        return _pysgpp_swig.CombinationGrid_getDimension(self)

    def getFullGrids(self) -> "std::vector< sgpp::combigrid::FullGrid,std::allocator< sgpp::combigrid::FullGrid > > const &":
        r"""


        Returns
        -------
        vector of full grids  

        """
        return _pysgpp_swig.CombinationGrid_getFullGrids(self)

    def getCoefficients(self) -> "sgpp::base::DataVector const &":
        r"""


        Returns
        -------
        vector of coefficients, same size as `fullGrids`  

        """
        return _pysgpp_swig.CombinationGrid_getCoefficients(self)

    def setFullGridsAndCoefficients(self, fullGrids: "FullGridVector", coefficients: "DataVector") -> "void":
        r"""


        Parameters
        ----------
        * `fullGrids` :  
            vector of full grids  
        * `coefficients` :  
            vector of coefficients, same size as `fullGrids`  

        """
        return _pysgpp_swig.CombinationGrid_setFullGridsAndCoefficients(self, fullGrids, coefficients)
    __swig_destroy__ = _pysgpp_swig.delete_CombinationGrid

# Register CombinationGrid in _pysgpp_swig:
_pysgpp_swig.CombinationGrid_swigregister(CombinationGrid)

def CombinationGrid_fromRegularSparse(dim: "size_t", n: "sgpp::combigrid::level_t", basis: "HeterogeneousBasis", hasBoundary: "bool"=True) -> "sgpp::combigrid::CombinationGrid":
    r"""


    Factory method to create a CombinationGrid corresponding to the combination
    technique for a regular sparse grid.  

    Parameters
    ----------
    * `dim` :  
        dimensionality  
    * `n` :  
        sparse grid level  
    * `basis` :  
        basis of the sparse grid (will be the same for all full grids; this can be
        changed)  
    * `hasBoundary` :  
        whether the sparse grid has points on the boundary  

    Returns
    -------
    CombinationGrid corresponding to the combination technique for the regular
    sparse grid  

    """
    return _pysgpp_swig.CombinationGrid_fromRegularSparse(dim, n, basis, hasBoundary)

def CombinationGrid_fromSubspaces(subspaceLevels: "std::vector< sgpp::combigrid::LevelVector,std::allocator< sgpp::combigrid::LevelVector > > const &", basis: "HeterogeneousBasis", hasBoundary: "bool"=True) -> "sgpp::combigrid::CombinationGrid":
    r"""


    Factory method to create a CombinationGrid corresponding to the combination
    technique for a (potentially dimensionally adaptive) sparse grid specified via
    its nodal subspaces/full grids.  

    Note: You have to specify the levels of *all* nodal subspaces, i.e., the
    specified list of subspaces has to be downward closed.  

    Parameters
    ----------
    * `subspaceLevels` :  
        vector of subspace levels  
    * `basis` :  
        basis of the sparse grid (will be the same for all full grids; this can be
        changed)  
    * `hasBoundary` :  
        whether the sparse grid has points on the boundary  

    Returns
    -------
    CombinationGrid corresponding to the combination technique for the sparse grid  

    """
    return _pysgpp_swig.CombinationGrid_fromSubspaces(subspaceLevels, basis, hasBoundary)

class OperationEvalCombinationGrid(object):
    r"""

    `OperationEvalCombinationGrid(grid)`  

    Operation for evaluating a combination grid function (linear combination of
    linear combinations of full grid basis functions, where the coefficients of the
    outer linear combination are given by the combination grid).  

    Constructors
    ------------
    * `OperationEvalCombinationGrid(grid)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            combination grid  

    C++ includes: OperationEvalCombinationGrid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, grid: "CombinationGrid"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `grid` :  
            combination grid  

        """
        _pysgpp_swig.OperationEvalCombinationGrid_swiginit(self, _pysgpp_swig.new_OperationEvalCombinationGrid(grid))

    def eval(self, surpluses: "DataVectorVector", point: "DataVector") -> "double":
        r"""


        Evaluate a combination grid function at one point.  

        Parameters
        ----------
        * `surpluses` :  
            coefficients for the basis functions (may be nodal/hierarchical), every
            vector corresponds to one full grid (the order of DataVector entries is
            given by IndexVectorRange)  
        * `point` :  
            point at which to evaluate the combination grid function  

        Returns
        -------
        value of the combination grid function at the given point  

        """
        return _pysgpp_swig.OperationEvalCombinationGrid_eval(self, surpluses, point)

    def multiEval(self, surpluses: "DataVectorVector", points: "DataMatrix", result: "DataVector") -> "void":
        r"""


        Evaluate a combination grid function at multiple points.  

        Parameters
        ----------
        * `surpluses` :  
            coefficients for the basis functions (may be nodal/hierarchical), every
            vector corresponds to one full grid (the order of DataVector entries is
            given by IndexVectorRange)  
        * `points` :  
            points at which to evaluate the combination grid function (every row
            corresponds to one point)  
        * `result` :  
            values of the combination grid function at the given points  

        """
        return _pysgpp_swig.OperationEvalCombinationGrid_multiEval(self, surpluses, points, result)

    def getGrid(self) -> "sgpp::combigrid::CombinationGrid const &":
        r"""


        Returns
        -------
        combination grid  

        """
        return _pysgpp_swig.OperationEvalCombinationGrid_getGrid(self)

    def setGrid(self, grid: "CombinationGrid") -> "void":
        r"""


        Parameters
        ----------
        * `grid` :  
            combination grid  

        """
        return _pysgpp_swig.OperationEvalCombinationGrid_setGrid(self, grid)
    __swig_destroy__ = _pysgpp_swig.delete_OperationEvalCombinationGrid

# Register OperationEvalCombinationGrid in _pysgpp_swig:
_pysgpp_swig.OperationEvalCombinationGrid_swigregister(OperationEvalCombinationGrid)

class OperationEvalFullGrid(OperationEval):
    r"""

    `OperationEvalFullGrid()`  
    `OperationEvalFullGrid(grid)`  

    Operation for evaluating a full grid function (linear combination of full grid
    basis functions).  

    Constructors
    ------------
    * `OperationEvalFullGrid()`  

        Default constructor.  

    * `OperationEvalFullGrid(grid)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            full grid  

    C++ includes: OperationEvalFullGrid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `OperationEvalFullGrid()`  

            Default constructor.  

        * `OperationEvalFullGrid(grid)`  

            Constructor.  

            Parameters:  
            * `grid` :  
                full grid  

        """
        _pysgpp_swig.OperationEvalFullGrid_swiginit(self, _pysgpp_swig.new_OperationEvalFullGrid(*args))
    __swig_destroy__ = _pysgpp_swig.delete_OperationEvalFullGrid

    def multiEval(self, surpluses: "DataVector", points: "DataMatrix", result: "DataVector") -> "void":
        r"""


        Evaluate a full grid function at multiple points.  

        Parameters
        ----------
        * `surpluses` :  
            coefficients for the full grid basis functions (may be nodal/hierarchical)  
        * `points` :  
            points at which to evaluate the full grid function (every row corresponds to
            one point)  
        * `result` :  
            values of the full grid function at the given points  

        """
        return _pysgpp_swig.OperationEvalFullGrid_multiEval(self, surpluses, points, result)

    def getGrid(self) -> "sgpp::combigrid::FullGrid const &":
        r"""


        Returns
        -------
        full grid  

        """
        return _pysgpp_swig.OperationEvalFullGrid_getGrid(self)

    def setGrid(self, grid: "FullGrid") -> "void":
        r"""


        Parameters
        ----------
        * `grid` :  
            full grid  

        """
        return _pysgpp_swig.OperationEvalFullGrid_setGrid(self, grid)

# Register OperationEvalFullGrid in _pysgpp_swig:
_pysgpp_swig.OperationEvalFullGrid_swigregister(OperationEvalFullGrid)

class OperationPole(object):
    r"""

    `OperationPole()`  

    Operation on a pole of a full grid.  

    A pole is a one-dimensional sub-grid (1D entries of the index vector/coordinates
    are fixed in all dimensions but one).  

    Constructors
    ------------
    * `OperationPole()`  

        Default constructor.  

    C++ includes: OperationPole.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pysgpp_swig.delete_OperationPole

    def apply(self, *args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `apply(values, level, hasBoundary=true)`  

            Apply the operator on data.  

            This operates in-place on the whole data vector (which is assumed to hold
            data for all full grid points), so this should only be called for 1D grids.  

            Parameters:  
            * `values` :  
                data vector for all full grid points (the order is given by
                IndexVectorRange)  
            * `level` :  
                level of the full grid  
            * `hasBoundary` :  
                whether the full grid has points on the boundary  

        * `apply(values, start, step, count, level, hasBoundary=true)`  

            Apply the operator on data.  

            This operates in-place on a subset of the given data vector (which is
            assumed to hold data for all full grid points), where the specified subset
            exactly corresponds to the points of the pole.  

            Parameters:  
            * `values` :  
                data vector for all full grid points (the order is given by
                IndexVectorRange)  
            * `start` :  
                sequence number of the first grid point of the pole  
            * `step` :  
                difference of sequence numbers of two subsequent grid points of the pole  
            * `count` :  
                number of grid points of the pole  
            * `level` :  
                level of the full grid  
            * `hasBoundary` :  
                whether the full grid has points on the boundary  

        """
        return _pysgpp_swig.OperationPole_apply(self, *args)

# Register OperationPole in _pysgpp_swig:
_pysgpp_swig.OperationPole_swigregister(OperationPole)

class OperationPoleHierarchisationGeneral(OperationPole):
    r"""

    `OperationPoleHierarchisationGeneral(basis, isBasisHierarchical=true)`  

    Operation of hierarchising values on a 1D pole of a full grid with general basis
    functions by solving a linear system.  

    Constructors
    ------------
    * `OperationPoleHierarchisationGeneral(basis, isBasisHierarchical=true)`  

        Constructor.  

        Parameters:  
        * `basis` :  
            1D basis  
        * `isBasisHierarchical` :  
            whether the basis is hierarchical or nodal  

    C++ includes: OperationPoleHierarchisationGeneral.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, basis: "SBasis", isBasisHierarchical: "bool"=True):
        r"""


        Constructor.  

        Parameters
        ----------
        * `basis` :  
            1D basis  
        * `isBasisHierarchical` :  
            whether the basis is hierarchical or nodal  

        """
        _pysgpp_swig.OperationPoleHierarchisationGeneral_swiginit(self, _pysgpp_swig.new_OperationPoleHierarchisationGeneral(basis, isBasisHierarchical))
    __swig_destroy__ = _pysgpp_swig.delete_OperationPoleHierarchisationGeneral

    @staticmethod
    def fromHeterogenerousBasis(*args) -> "void":
        r"""


        Overloaded function
        -------------------
        * `fromHeterogenerousBasis(basis, operation)`  

            Factory method to create a vector of pointers to
            OperationPoleHierarchisationGeneral objects from a HeterogeneousBasis.  

            Parameters:  
            * `basis` :  
                multivariate basis  
            * `operation` :  
                vector of pointers to OperationPoleHierarchisationGeneral objects
                corresponding to the given basis  

        * `fromHeterogenerousBasis(basis, operation)`  

            Factory method to create a vector of unique_ptr to
            OperationPoleHierarchisationGeneral objects from a HeterogeneousBasis.  

            Parameters:  
            * `basis` :  
                multivariate basis  
            * `operation` :  
                vector of unique_ptr to OperationPoleHierarchisationGeneral objects
                corresponding to the given basis  

        """
        return _pysgpp_swig.OperationPoleHierarchisationGeneral_fromHeterogenerousBasis(*args)

    def apply(self, values: "DataVector", start: "size_t", step: "size_t", count: "size_t", level: "sgpp::combigrid::level_t", hasBoundary: "bool"=True) -> "void":
        r"""


        Apply the operator on data.  

        Parameters
        ----------
        * `values` :  
            data vector for all full grid points (the order is given by
            IndexVectorRange)  
        * `start` :  
            sequence number of the first grid point of the pole  
        * `step` :  
            difference of sequence numbers of two subsequent grid points of the pole  
        * `count` :  
            number of grid points of the pole  
        * `level` :  
            level of the full grid  
        * `hasBoundary` :  
            whether the full grid has points on the boundary  

        """
        return _pysgpp_swig.OperationPoleHierarchisationGeneral_apply(self, values, start, step, count, level, hasBoundary)

# Register OperationPoleHierarchisationGeneral in _pysgpp_swig:
_pysgpp_swig.OperationPoleHierarchisationGeneral_swigregister(OperationPoleHierarchisationGeneral)

def OperationPoleHierarchisationGeneral_fromHeterogenerousBasis(*args) -> "void":
    r"""


    Overloaded function
    -------------------
    * `fromHeterogenerousBasis(basis, operation)`  

        Factory method to create a vector of pointers to
        OperationPoleHierarchisationGeneral objects from a HeterogeneousBasis.  

        Parameters:  
        * `basis` :  
            multivariate basis  
        * `operation` :  
            vector of pointers to OperationPoleHierarchisationGeneral objects
            corresponding to the given basis  

    * `fromHeterogenerousBasis(basis, operation)`  

        Factory method to create a vector of unique_ptr to
        OperationPoleHierarchisationGeneral objects from a HeterogeneousBasis.  

        Parameters:  
        * `basis` :  
            multivariate basis  
        * `operation` :  
            vector of unique_ptr to OperationPoleHierarchisationGeneral objects
            corresponding to the given basis  

    """
    return _pysgpp_swig.OperationPoleHierarchisationGeneral_fromHeterogenerousBasis(*args)

class OperationPoleHierarchisationLinear(OperationPole):
    r"""

    `OperationPoleHierarchisationLinear()`  

    Operation of hierarchising values on a 1D pole of a full grid with linear basis
    functions.  

    Constructors
    ------------
    * `OperationPoleHierarchisationLinear()`  

        Default constructor.  

    C++ includes: OperationPoleHierarchisationLinear.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.OperationPoleHierarchisationLinear_swiginit(self, _pysgpp_swig.new_OperationPoleHierarchisationLinear())
    __swig_destroy__ = _pysgpp_swig.delete_OperationPoleHierarchisationLinear

    def apply(self, values: "DataVector", start: "size_t", step: "size_t", count: "size_t", level: "sgpp::combigrid::level_t", hasBoundary: "bool"=True) -> "void":
        r"""


        Apply the operator on data.  

        Parameters
        ----------
        * `values` :  
            data vector for all full grid points (the order is given by
            IndexVectorRange)  
        * `start` :  
            sequence number of the first grid point of the pole  
        * `step` :  
            difference of sequence numbers of two subsequent grid points of the pole  
        * `count` :  
            number of grid points of the pole  
        * `level` :  
            level of the full grid  
        * `hasBoundary` :  
            whether the full grid has points on the boundary  

        """
        return _pysgpp_swig.OperationPoleHierarchisationLinear_apply(self, values, start, step, count, level, hasBoundary)

# Register OperationPoleHierarchisationLinear in _pysgpp_swig:
_pysgpp_swig.OperationPoleHierarchisationLinear_swigregister(OperationPoleHierarchisationLinear)

class OperationPoleNodalisationBspline(OperationPole):
    r"""

    `OperationPoleNodalisationBspline(degree)`  

    Operation of nodalising values on a 1D pole of a full grid with B-spline basis
    functions.  

    "Nodalisation" refers to calculating the interpolation coefficients for the
    nodal basis (analogously to hierarchisation for the hierarchical basis).  

    Constructors
    ------------
    * `OperationPoleNodalisationBspline(degree)`  

        Constructor.  

        Parameters:  
        * `degree` :  
            B-spline degree  

    C++ includes: OperationPoleNodalisationBspline.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, degree: "size_t"):
        r"""


        Constructor.  

        Parameters
        ----------
        * `degree` :  
            B-spline degree  

        """
        _pysgpp_swig.OperationPoleNodalisationBspline_swiginit(self, _pysgpp_swig.new_OperationPoleNodalisationBspline(degree))
    __swig_destroy__ = _pysgpp_swig.delete_OperationPoleNodalisationBspline

    def apply(self, values: "DataVector", start: "size_t", step: "size_t", count: "size_t", level: "sgpp::combigrid::level_t", hasBoundary: "bool"=True) -> "void":
        r"""


        Apply the operator on data.  

        Parameters
        ----------
        * `values` :  
            data vector for all full grid points (the order is given by
            IndexVectorRange)  
        * `start` :  
            sequence number of the first grid point of the pole  
        * `step` :  
            difference of sequence numbers of two subsequent grid points of the pole  
        * `count` :  
            number of grid points of the pole  
        * `level` :  
            level of the full grid  
        * `hasBoundary` :  
            whether the full grid has points on the boundary  

        """
        return _pysgpp_swig.OperationPoleNodalisationBspline_apply(self, values, start, step, count, level, hasBoundary)

# Register OperationPoleNodalisationBspline in _pysgpp_swig:
_pysgpp_swig.OperationPoleNodalisationBspline_swigregister(OperationPoleNodalisationBspline)

class OperationPoleNodalisationLinear(OperationPole):
    r"""

    `OperationPoleNodalisationLinear()`  

    Operation of nodalising values on a 1D pole of a full grid with linear basis
    functions.  

    "Nodalisation" refers to calculating the interpolation coefficients for the
    nodal basis (analogously to hierarchisation for the hierarchical basis).  

    This class only exists for the sake of completeness; as the interpolation
    coefficients equal the values at the grid points, this operation is the identity
    operation.  

    Constructors
    ------------
    * `OperationPoleNodalisationLinear()`  

        Default constructor.  

    C++ includes: OperationPoleNodalisationLinear.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Default constructor.  

        """
        _pysgpp_swig.OperationPoleNodalisationLinear_swiginit(self, _pysgpp_swig.new_OperationPoleNodalisationLinear())
    __swig_destroy__ = _pysgpp_swig.delete_OperationPoleNodalisationLinear

    def apply(self, values: "DataVector", start: "size_t", step: "size_t", count: "size_t", level: "sgpp::combigrid::level_t", hasBoundary: "bool"=True) -> "void":
        r"""


        Apply the operator on data.  

        Parameters
        ----------
        * `values` :  
            data vector for all full grid points (the order is given by
            IndexVectorRange)  
        * `start` :  
            sequence number of the first grid point of the pole  
        * `step` :  
            difference of sequence numbers of two subsequent grid points of the pole  
        * `count` :  
            number of grid points of the pole  
        * `level` :  
            level of the full grid  
        * `hasBoundary` :  
            whether the full grid has points on the boundary  

        """
        return _pysgpp_swig.OperationPoleNodalisationLinear_apply(self, values, start, step, count, level, hasBoundary)

# Register OperationPoleNodalisationLinear in _pysgpp_swig:
_pysgpp_swig.OperationPoleNodalisationLinear_swigregister(OperationPoleNodalisationLinear)

class OperationUPFullGrid(object):
    r"""

    `OperationUPFullGrid(grid, operationPole)`  
    `OperationUPFullGrid(grid, operationPole)`  
    `OperationUPFullGrid(grid, operationPole)`  

    Operation for applying 1D OperationPole operators on all poles of a full grid in
    all dimensions via the unidirectional principle (UP).  

    Constructors
    ------------
    * `OperationUPFullGrid(grid, operationPole)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            full grid  
        * `operationPole` :  
            vector of pointers to 1D pole operators (do not delete before this
            object)  

    * `OperationUPFullGrid(grid, operationPole)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            full grid  
        * `operationPole` :  
            vector of unique_ptr to 1D pole operators (do not destruct before this
            object)  

    * `OperationUPFullGrid(grid, operationPole)`  

        Constructor for the special case where the same OperationPole should be used
        for all dimensions.  

        Parameters:  
        * `grid` :  
            full grid  
        * `operationPole` :  
            1D pole operator (do not destruct before this object)  

    C++ includes: OperationUPFullGrid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `OperationUPFullGrid(grid, operationPole)`  

            Constructor.  

            Parameters:  
            * `grid` :  
                full grid  
            * `operationPole` :  
                vector of pointers to 1D pole operators (do not delete before this
                object)  

        * `OperationUPFullGrid(grid, operationPole)`  

            Constructor.  

            Parameters:  
            * `grid` :  
                full grid  
            * `operationPole` :  
                vector of unique_ptr to 1D pole operators (do not destruct before this
                object)  

        * `OperationUPFullGrid(grid, operationPole)`  

            Constructor for the special case where the same OperationPole should be used
            for all dimensions.  

            Parameters:  
            * `grid` :  
                full grid  
            * `operationPole` :  
                1D pole operator (do not destruct before this object)  

        """
        _pysgpp_swig.OperationUPFullGrid_swiginit(self, _pysgpp_swig.new_OperationUPFullGrid(*args))

    def apply(self, values: "DataVector") -> "void":
        r"""


        Apply the unidirectional principle in-place.  

        Parameters
        ----------
        * `values` :  
            data vector, same size as the number of grid points of the full grid (the
            order is given by IndexVectorRange)  

        """
        return _pysgpp_swig.OperationUPFullGrid_apply(self, values)

    def getGrid(self) -> "sgpp::combigrid::FullGrid const &":
        r"""


        Returns
        -------
        full grid  

        """
        return _pysgpp_swig.OperationUPFullGrid_getGrid(self)

    def setGrid(self, grid: "FullGrid") -> "void":
        r"""


        Parameters
        ----------
        * `grid` :  
            full grid  

        """
        return _pysgpp_swig.OperationUPFullGrid_setGrid(self, grid)

    def getOperationPole(self) -> "std::vector< sgpp::combigrid::OperationPole *,std::allocator< sgpp::combigrid::OperationPole * > > const &":
        r"""


        Returns
        -------
        vector of pointers to 1D pole operators (do not delete before this object)  

        """
        return _pysgpp_swig.OperationUPFullGrid_getOperationPole(self)

    def setOperationPole(self, operationPole: "OperationPoleVector") -> "void":
        r"""


        Parameters
        ----------
        * `operationPole` :  
            vector of pointers to 1D pole operators (do not delete before this object)  

        """
        return _pysgpp_swig.OperationUPFullGrid_setOperationPole(self, operationPole)
    __swig_destroy__ = _pysgpp_swig.delete_OperationUPFullGrid

# Register OperationUPFullGrid in _pysgpp_swig:
_pysgpp_swig.OperationUPFullGrid_swigregister(OperationUPFullGrid)

class OperationUPCombinationGrid(object):
    r"""

    `OperationUPCombinationGrid(grid, operationPole)`  
    `OperationUPCombinationGrid(grid, operationPole)`  
    `OperationUPCombinationGrid(grid, operationPole)`  

    Operation for applying 1D OperationPole operators on all poles of all full grids
    of some combination grid, in all dimensions via the unidirectional principle
    (UP).  

    Constructors
    ------------
    * `OperationUPCombinationGrid(grid, operationPole)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            combination grid  
        * `operationPole` :  
            vector of pointers to 1D pole operators (do not delete before this
            object)  

    * `OperationUPCombinationGrid(grid, operationPole)`  

        Constructor.  

        Parameters:  
        * `grid` :  
            combination grid  
        * `operationPole` :  
            vector of unique_ptr to 1D pole operators (do not destruct before this
            object)  

    * `OperationUPCombinationGrid(grid, operationPole)`  

        Constructor for the special case where the same OperationPole should be used
        for all dimensions.  

        Parameters:  
        * `grid` :  
            combination grid  
        * `operationPole` :  
            1D pole operator (do not destruct before this object)  

    C++ includes: OperationUPCombinationGrid.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `OperationUPCombinationGrid(grid, operationPole)`  

            Constructor.  

            Parameters:  
            * `grid` :  
                combination grid  
            * `operationPole` :  
                vector of pointers to 1D pole operators (do not delete before this
                object)  

        * `OperationUPCombinationGrid(grid, operationPole)`  

            Constructor.  

            Parameters:  
            * `grid` :  
                combination grid  
            * `operationPole` :  
                vector of unique_ptr to 1D pole operators (do not destruct before this
                object)  

        * `OperationUPCombinationGrid(grid, operationPole)`  

            Constructor for the special case where the same OperationPole should be used
            for all dimensions.  

            Parameters:  
            * `grid` :  
                combination grid  
            * `operationPole` :  
                1D pole operator (do not destruct before this object)  

        """
        _pysgpp_swig.OperationUPCombinationGrid_swiginit(self, _pysgpp_swig.new_OperationUPCombinationGrid(*args))

    def apply(self, values: "DataVectorVector") -> "void":
        r"""


        Apply the unidirectional principle in-place.  

        Parameters
        ----------
        * `values` :  
            vector of vectors with values on the full grids, every vector corresponds to
            one full grid of the combination grid, every vector has the same size as the
            number of grid points of the respective full grid (the order of DataVector
            entries is given by IndexVectorRange)  

        """
        return _pysgpp_swig.OperationUPCombinationGrid_apply(self, values)

    def getGrid(self) -> "sgpp::combigrid::CombinationGrid const &":
        r"""


        Returns
        -------
        combination grid  

        """
        return _pysgpp_swig.OperationUPCombinationGrid_getGrid(self)

    def setGrid(self, grid: "CombinationGrid") -> "void":
        r"""


        Parameters
        ----------
        * `grid` :  
            combination grid  

        """
        return _pysgpp_swig.OperationUPCombinationGrid_setGrid(self, grid)

    def getOperationPole(self) -> "std::vector< sgpp::combigrid::OperationPole *,std::allocator< sgpp::combigrid::OperationPole * > > const &":
        r"""


        Returns
        -------
        vector of pointers to 1D pole operators (do not delete before this object)  

        """
        return _pysgpp_swig.OperationUPCombinationGrid_getOperationPole(self)

    def setOperationPole(self, operationPole: "OperationPoleVector") -> "void":
        r"""


        Parameters
        ----------
        * `operationPole` :  
            vector of pointers to 1D pole operators (do not delete before this object)  

        """
        return _pysgpp_swig.OperationUPCombinationGrid_setOperationPole(self, operationPole)
    __swig_destroy__ = _pysgpp_swig.delete_OperationUPCombinationGrid

# Register OperationUPCombinationGrid in _pysgpp_swig:
_pysgpp_swig.OperationUPCombinationGrid_swigregister(OperationUPCombinationGrid)

class IndexVectorRange(object):
    r"""

    `IndexVectorRange()`  
    `IndexVectorRange(grid)`  
    `IndexVectorRange(minIndex, maxIndex)`  

    Class for iterating over the indices contained in a FullGrid via ranged-based
    `for` loops.  

    This is basically equivalent to NumPy's and MATLAB's `meshgrid` function, as it
    loops over the Cartesian product of the sets of 1D indices.  

    The order is as follows: $(0, 0, 0, \dotsc, 0)$, $(1, 0, 0, \dotsc, 0)$, ...,
    $(n_1, 0, 0, \dotsc, 0)$, $(0, 1, 0, \dotsc, 0)$, ..., $(1, 1, 0, \dotsc,
    0)$, ..., $(n_1, 1, 0, \dotsc, 0)$, ..., $(n_1, n_2, 0, \dotsc, 0)$, etc.
    (i.e., like enumerating indices of a matrix in column-major order).  

    Constructors
    ------------
    * `IndexVectorRange()`  

        Default constructor, corresponds to the zero-dimensional case.  

    * `IndexVectorRange(grid)`  

        Constructor for FullGrid instances.  

        Parameters:  
        * `grid` :  
            full grid  

    * `IndexVectorRange(minIndex, maxIndex)`  

        Constructor for custom-defined minimum and maximum indices.  

        Parameters:  
        * `minIndex` :  
            vector of minimum 1D indices  
        * `maxIndex` :  
            vector of maximum 1D indices  

    C++ includes: IndexVectorRange.hpp

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Overloaded function
        -------------------
        * `IndexVectorRange()`  

            Default constructor, corresponds to the zero-dimensional case.  

        * `IndexVectorRange(grid)`  

            Constructor for FullGrid instances.  

            Parameters:  
            * `grid` :  
                full grid  

        * `IndexVectorRange(minIndex, maxIndex)`  

            Constructor for custom-defined minimum and maximum indices.  

            Parameters:  
            * `minIndex` :  
                vector of minimum 1D indices  
            * `maxIndex` :  
                vector of maximum 1D indices  

        """
        _pysgpp_swig.IndexVectorRange_swiginit(self, _pysgpp_swig.new_IndexVectorRange(*args))

    def find(self, index: "LevelVector") -> "size_t":
        r"""


        Finds the given index in the range and returns it position.  

        Only returns reasonable values if the index is actually in the range.  

        Parameters
        ----------
        * `index` :  
            index to find  

        Returns
        -------
        sequence number in the range  

        """
        return _pysgpp_swig.IndexVectorRange_find(self, index)

    def setGrid(self, grid: "FullGrid") -> "void":
        r"""


        Sets minimum and maximum index of the range to that of the given FullGrid.  

        Parameters
        ----------
        * `grid` :  
            FullGrid to use  

        """
        return _pysgpp_swig.IndexVectorRange_setGrid(self, grid)

    def getIndices(self, indices: "std::vector< sgpp::combigrid::IndexVector,std::allocator< sgpp::combigrid::IndexVector > > &") -> "void":
        r"""


        Converts this range to a vector of indices, which will contain all indices that
        are within this range.  

        Parameters
        ----------
        * `indices` :  
            vector of indices (contents will be overwritten)  

        """
        return _pysgpp_swig.IndexVectorRange_getIndices(self, indices)

    @staticmethod
    def getPoints(grid: "FullGrid", points: "DataMatrix") -> "void":
        r"""


        Save all grid points of a FullGrid in a DataMatrix.  

        Parameters
        ----------
        * `grid` :  
            full grid  
        * `points` :  
            matrix containing the grid points row-by-row after calling  

        """
        return _pysgpp_swig.IndexVectorRange_getPoints(grid, points)
    __swig_destroy__ = _pysgpp_swig.delete_IndexVectorRange

# Register IndexVectorRange in _pysgpp_swig:
_pysgpp_swig.IndexVectorRange_swigregister(IndexVectorRange)

def IndexVectorRange_getPoints(grid: "FullGrid", points: "DataMatrix") -> "void":
    r"""


    Save all grid points of a FullGrid in a DataMatrix.  

    Parameters
    ----------
    * `grid` :  
        full grid  
    * `points` :  
        matrix containing the grid points row-by-row after calling  

    """
    return _pysgpp_swig.IndexVectorRange_getPoints(grid, points)

class BasisVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.BasisVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.BasisVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.BasisVector___bool__(self)

    def __len__(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::size_type":
        return _pysgpp_swig.BasisVector___len__(self)

    def __getslice__(self, i: "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::difference_type", j: "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::difference_type") -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > *,std::allocator< sgpp::base::Basis< unsigned int,unsigned int > * > > *":
        return _pysgpp_swig.BasisVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.BasisVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::difference_type", j: "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::difference_type") -> "void":
        return _pysgpp_swig.BasisVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.BasisVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::value_type":
        return _pysgpp_swig.BasisVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.BasisVector___setitem__(self, *args)

    def pop(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::value_type":
        return _pysgpp_swig.BasisVector_pop(self)

    def append(self, x: "SBasis") -> "void":
        return _pysgpp_swig.BasisVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.BasisVector_empty(self)

    def size(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::size_type":
        return _pysgpp_swig.BasisVector_size(self)

    def swap(self, v: "BasisVector") -> "void":
        return _pysgpp_swig.BasisVector_swap(self, v)

    def begin(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::iterator":
        return _pysgpp_swig.BasisVector_begin(self)

    def end(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::iterator":
        return _pysgpp_swig.BasisVector_end(self)

    def rbegin(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::reverse_iterator":
        return _pysgpp_swig.BasisVector_rbegin(self)

    def rend(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::reverse_iterator":
        return _pysgpp_swig.BasisVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.BasisVector_clear(self)

    def get_allocator(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::allocator_type":
        return _pysgpp_swig.BasisVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.BasisVector_pop_back(self)

    def erase(self, *args) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::iterator":
        return _pysgpp_swig.BasisVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.BasisVector_swiginit(self, _pysgpp_swig.new_BasisVector(*args))

    def push_back(self, x: "SBasis") -> "void":
        return _pysgpp_swig.BasisVector_push_back(self, x)

    def front(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::value_type":
        return _pysgpp_swig.BasisVector_front(self)

    def back(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::value_type":
        return _pysgpp_swig.BasisVector_back(self)

    def assign(self, n: "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::size_type", x: "SBasis") -> "void":
        return _pysgpp_swig.BasisVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.BasisVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.BasisVector_insert(self, *args)

    def reserve(self, n: "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::size_type") -> "void":
        return _pysgpp_swig.BasisVector_reserve(self, n)

    def capacity(self) -> "std::vector< sgpp::base::Basis< unsigned int,unsigned int > * >::size_type":
        return _pysgpp_swig.BasisVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_BasisVector

# Register BasisVector in _pysgpp_swig:
_pysgpp_swig.BasisVector_swigregister(BasisVector)

class FullGridVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.FullGridVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.FullGridVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.FullGridVector___bool__(self)

    def __len__(self) -> "std::vector< sgpp::combigrid::FullGrid >::size_type":
        return _pysgpp_swig.FullGridVector___len__(self)

    def __getslice__(self, i: "std::vector< sgpp::combigrid::FullGrid >::difference_type", j: "std::vector< sgpp::combigrid::FullGrid >::difference_type") -> "std::vector< sgpp::combigrid::FullGrid,std::allocator< sgpp::combigrid::FullGrid > > *":
        return _pysgpp_swig.FullGridVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.FullGridVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< sgpp::combigrid::FullGrid >::difference_type", j: "std::vector< sgpp::combigrid::FullGrid >::difference_type") -> "void":
        return _pysgpp_swig.FullGridVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.FullGridVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< sgpp::combigrid::FullGrid >::value_type const &":
        return _pysgpp_swig.FullGridVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.FullGridVector___setitem__(self, *args)

    def pop(self) -> "std::vector< sgpp::combigrid::FullGrid >::value_type":
        return _pysgpp_swig.FullGridVector_pop(self)

    def append(self, x: "FullGrid") -> "void":
        return _pysgpp_swig.FullGridVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.FullGridVector_empty(self)

    def size(self) -> "std::vector< sgpp::combigrid::FullGrid >::size_type":
        return _pysgpp_swig.FullGridVector_size(self)

    def swap(self, v: "FullGridVector") -> "void":
        return _pysgpp_swig.FullGridVector_swap(self, v)

    def begin(self) -> "std::vector< sgpp::combigrid::FullGrid >::iterator":
        return _pysgpp_swig.FullGridVector_begin(self)

    def end(self) -> "std::vector< sgpp::combigrid::FullGrid >::iterator":
        return _pysgpp_swig.FullGridVector_end(self)

    def rbegin(self) -> "std::vector< sgpp::combigrid::FullGrid >::reverse_iterator":
        return _pysgpp_swig.FullGridVector_rbegin(self)

    def rend(self) -> "std::vector< sgpp::combigrid::FullGrid >::reverse_iterator":
        return _pysgpp_swig.FullGridVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.FullGridVector_clear(self)

    def get_allocator(self) -> "std::vector< sgpp::combigrid::FullGrid >::allocator_type":
        return _pysgpp_swig.FullGridVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.FullGridVector_pop_back(self)

    def erase(self, *args) -> "std::vector< sgpp::combigrid::FullGrid >::iterator":
        return _pysgpp_swig.FullGridVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.FullGridVector_swiginit(self, _pysgpp_swig.new_FullGridVector(*args))

    def push_back(self, x: "FullGrid") -> "void":
        return _pysgpp_swig.FullGridVector_push_back(self, x)

    def front(self) -> "std::vector< sgpp::combigrid::FullGrid >::value_type const &":
        return _pysgpp_swig.FullGridVector_front(self)

    def back(self) -> "std::vector< sgpp::combigrid::FullGrid >::value_type const &":
        return _pysgpp_swig.FullGridVector_back(self)

    def assign(self, n: "std::vector< sgpp::combigrid::FullGrid >::size_type", x: "FullGrid") -> "void":
        return _pysgpp_swig.FullGridVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.FullGridVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.FullGridVector_insert(self, *args)

    def reserve(self, n: "std::vector< sgpp::combigrid::FullGrid >::size_type") -> "void":
        return _pysgpp_swig.FullGridVector_reserve(self, n)

    def capacity(self) -> "std::vector< sgpp::combigrid::FullGrid >::size_type":
        return _pysgpp_swig.FullGridVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_FullGridVector

# Register FullGridVector in _pysgpp_swig:
_pysgpp_swig.FullGridVector_swigregister(FullGridVector)

class LevelVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.LevelVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.LevelVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.LevelVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _pysgpp_swig.LevelVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _pysgpp_swig.LevelVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.LevelVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "void":
        return _pysgpp_swig.LevelVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.LevelVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _pysgpp_swig.LevelVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.LevelVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _pysgpp_swig.LevelVector_pop(self)

    def append(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _pysgpp_swig.LevelVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.LevelVector_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _pysgpp_swig.LevelVector_size(self)

    def swap(self, v: "LevelVector") -> "void":
        return _pysgpp_swig.LevelVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _pysgpp_swig.LevelVector_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _pysgpp_swig.LevelVector_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _pysgpp_swig.LevelVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _pysgpp_swig.LevelVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.LevelVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _pysgpp_swig.LevelVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.LevelVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _pysgpp_swig.LevelVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.LevelVector_swiginit(self, _pysgpp_swig.new_LevelVector(*args))

    def push_back(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _pysgpp_swig.LevelVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _pysgpp_swig.LevelVector_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _pysgpp_swig.LevelVector_back(self)

    def assign(self, n: "std::vector< unsigned int >::size_type", x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _pysgpp_swig.LevelVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.LevelVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.LevelVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned int >::size_type") -> "void":
        return _pysgpp_swig.LevelVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _pysgpp_swig.LevelVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_LevelVector

# Register LevelVector in _pysgpp_swig:
_pysgpp_swig.LevelVector_swigregister(LevelVector)

class LevelVectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.LevelVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.LevelVectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.LevelVectorVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::size_type":
        return _pysgpp_swig.LevelVectorVector___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::difference_type", j: "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::difference_type") -> "std::vector< std::vector< sgpp::base::level_t,std::allocator< sgpp::base::level_t > >,std::allocator< std::vector< sgpp::base::level_t,std::allocator< sgpp::base::level_t > > > > *":
        return _pysgpp_swig.LevelVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.LevelVectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::difference_type", j: "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::difference_type") -> "void":
        return _pysgpp_swig.LevelVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.LevelVectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::value_type const &":
        return _pysgpp_swig.LevelVectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.LevelVectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::value_type":
        return _pysgpp_swig.LevelVectorVector_pop(self)

    def append(self, x: "LevelVector") -> "void":
        return _pysgpp_swig.LevelVectorVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.LevelVectorVector_empty(self)

    def size(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::size_type":
        return _pysgpp_swig.LevelVectorVector_size(self)

    def swap(self, v: "LevelVectorVector") -> "void":
        return _pysgpp_swig.LevelVectorVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::iterator":
        return _pysgpp_swig.LevelVectorVector_begin(self)

    def end(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::iterator":
        return _pysgpp_swig.LevelVectorVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::reverse_iterator":
        return _pysgpp_swig.LevelVectorVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::reverse_iterator":
        return _pysgpp_swig.LevelVectorVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.LevelVectorVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::allocator_type":
        return _pysgpp_swig.LevelVectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.LevelVectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::iterator":
        return _pysgpp_swig.LevelVectorVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.LevelVectorVector_swiginit(self, _pysgpp_swig.new_LevelVectorVector(*args))

    def push_back(self, x: "LevelVector") -> "void":
        return _pysgpp_swig.LevelVectorVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::value_type const &":
        return _pysgpp_swig.LevelVectorVector_front(self)

    def back(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::value_type const &":
        return _pysgpp_swig.LevelVectorVector_back(self)

    def assign(self, n: "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::size_type", x: "LevelVector") -> "void":
        return _pysgpp_swig.LevelVectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.LevelVectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.LevelVectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::size_type") -> "void":
        return _pysgpp_swig.LevelVectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > > >::size_type":
        return _pysgpp_swig.LevelVectorVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_LevelVectorVector

# Register LevelVectorVector in _pysgpp_swig:
_pysgpp_swig.LevelVectorVector_swigregister(LevelVectorVector)

class OperationPoleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pysgpp_swig.OperationPoleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pysgpp_swig.OperationPoleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pysgpp_swig.OperationPoleVector___bool__(self)

    def __len__(self) -> "std::vector< sgpp::combigrid::OperationPole * >::size_type":
        return _pysgpp_swig.OperationPoleVector___len__(self)

    def __getslice__(self, i: "std::vector< sgpp::combigrid::OperationPole * >::difference_type", j: "std::vector< sgpp::combigrid::OperationPole * >::difference_type") -> "std::vector< sgpp::combigrid::OperationPole *,std::allocator< sgpp::combigrid::OperationPole * > > *":
        return _pysgpp_swig.OperationPoleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pysgpp_swig.OperationPoleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< sgpp::combigrid::OperationPole * >::difference_type", j: "std::vector< sgpp::combigrid::OperationPole * >::difference_type") -> "void":
        return _pysgpp_swig.OperationPoleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pysgpp_swig.OperationPoleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< sgpp::combigrid::OperationPole * >::value_type":
        return _pysgpp_swig.OperationPoleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pysgpp_swig.OperationPoleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< sgpp::combigrid::OperationPole * >::value_type":
        return _pysgpp_swig.OperationPoleVector_pop(self)

    def append(self, x: "OperationPole") -> "void":
        return _pysgpp_swig.OperationPoleVector_append(self, x)

    def empty(self) -> "bool":
        return _pysgpp_swig.OperationPoleVector_empty(self)

    def size(self) -> "std::vector< sgpp::combigrid::OperationPole * >::size_type":
        return _pysgpp_swig.OperationPoleVector_size(self)

    def swap(self, v: "OperationPoleVector") -> "void":
        return _pysgpp_swig.OperationPoleVector_swap(self, v)

    def begin(self) -> "std::vector< sgpp::combigrid::OperationPole * >::iterator":
        return _pysgpp_swig.OperationPoleVector_begin(self)

    def end(self) -> "std::vector< sgpp::combigrid::OperationPole * >::iterator":
        return _pysgpp_swig.OperationPoleVector_end(self)

    def rbegin(self) -> "std::vector< sgpp::combigrid::OperationPole * >::reverse_iterator":
        return _pysgpp_swig.OperationPoleVector_rbegin(self)

    def rend(self) -> "std::vector< sgpp::combigrid::OperationPole * >::reverse_iterator":
        return _pysgpp_swig.OperationPoleVector_rend(self)

    def clear(self) -> "void":
        return _pysgpp_swig.OperationPoleVector_clear(self)

    def get_allocator(self) -> "std::vector< sgpp::combigrid::OperationPole * >::allocator_type":
        return _pysgpp_swig.OperationPoleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _pysgpp_swig.OperationPoleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< sgpp::combigrid::OperationPole * >::iterator":
        return _pysgpp_swig.OperationPoleVector_erase(self, *args)

    def __init__(self, *args):
        _pysgpp_swig.OperationPoleVector_swiginit(self, _pysgpp_swig.new_OperationPoleVector(*args))

    def push_back(self, x: "OperationPole") -> "void":
        return _pysgpp_swig.OperationPoleVector_push_back(self, x)

    def front(self) -> "std::vector< sgpp::combigrid::OperationPole * >::value_type":
        return _pysgpp_swig.OperationPoleVector_front(self)

    def back(self) -> "std::vector< sgpp::combigrid::OperationPole * >::value_type":
        return _pysgpp_swig.OperationPoleVector_back(self)

    def assign(self, n: "std::vector< sgpp::combigrid::OperationPole * >::size_type", x: "OperationPole") -> "void":
        return _pysgpp_swig.OperationPoleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pysgpp_swig.OperationPoleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pysgpp_swig.OperationPoleVector_insert(self, *args)

    def reserve(self, n: "std::vector< sgpp::combigrid::OperationPole * >::size_type") -> "void":
        return _pysgpp_swig.OperationPoleVector_reserve(self, n)

    def capacity(self) -> "std::vector< sgpp::combigrid::OperationPole * >::size_type":
        return _pysgpp_swig.OperationPoleVector_capacity(self)
    __swig_destroy__ = _pysgpp_swig.delete_OperationPoleVector

# Register OperationPoleVector in _pysgpp_swig:
_pysgpp_swig.OperationPoleVector_swigregister(OperationPoleVector)



