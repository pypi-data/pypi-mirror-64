import requests
import json
import os
import re
try: # Python 2/3 compatibility
    import urllib.request as urlrequest
except ImportError:
    import urllib as urlrequest

def help():
    print('- getResults(taskId, baseUrl, apiKey, incIncompleteInstances=False, incIterations=True)')
    print('Make an API call to get a list of results from completed instances or iterations. Task ID is available from Studio after clicking on the relevant task. The baseUrl string is usually: \nr\'https://studio.lambda.hvmd.io/\'\n (\'https://\' is required). The authHeader is a dictionary specifying an HTTP Authorisation header; it can be created with makeAuthHeader. Setting the expandSummary option to False will collapse the summary block in each result to null. Each entry in the list is a dictionary containing the results of one instance, in the structure shown below.')
    print('- getInstances(taskId, baseUrl, apiKey, expandSummary=True)')
    print('Make an API call to get a list of instances submitted to the task. Note that this may return less data than an individual call to getInstance(). Task ID is available from Studio after clicking on the relevant task. The baseUrl string is usually: \nr\'https://studio.lambda.hvmd.io/\'\n The authHeader is a dictionary specifying an HTTP Authorisation header; it can be created with makeAuthHeader. Each entry in the list is a dictionary containing the input data for one instance, in the structure shown below.')
    print('- def getInstance(taskId, baseUrl, apiKey, instanceId, expandSummary=True)')
    print('Get a single instance. Note that this may return more data than the corresponding element of the array returned by getInstances().')
    print('- getInstanceIds(taskId, baseUrl, apiKey)')
    print('Returns a list of all instance IDs on a specific task')
    print('- transferEntry(source, target, entryField="data", sourceIdField="id", targetIdField="instanceId")')
    print('Transfer an entry from one list of dictionaries to another list of dictionaries. Used for copying input data from instance dictionaries to results dictionaries, matching on instanceId.')
    print('- getInstancesAndResults(taskId, baseUrl, apiKey, expandSummary=True, incIncompleteInstances=False, incIterations=True)')
    print('Call both getResults and getInstances, and stitch them together with transferEntry')
    print('- listFilesUploaded(taskId, baseUrl, apiKey)')
    print('Make an API call to get a list of all uploaded files')
    print('- uploadFiles(taskId, baseUrl, apiKey, lstFilenames, localRepo, overwrite=False)')
    print('Make an API call to upload local files from localRepo with filenames in lstFilenames to the specified task')
    print('- downloadFile(filepath, localRepo, prefix=\'\', overwrite=False)')
    print('Download a file generated by a task from the long s3 link provided as output. Provide a prefix (iteration ID etc). Returns local file name.')
    print('- getIterations(taskId, baseUrl, apiKey, instanceId)')
    print('Get a list of dictionaries, one per iteration result.')
    print('- getIterationIds(taskId, baseUrl, apiKey, instanceId)')
    print('Get a list of iteration IDs for the given instance.')
    print('- deleteIteration(taskId, baseUrl, apiKey, instanceId, iterationId)')
    print('Delete one specific iteration of a given instance')
    print('- deleteInstance(taskId, baseUrl, apiKey, instanceId)')
    print('Delete one specific instance and all its iterations')
    print('- createInstance(taskId, baseUrl, apiKey, name, instructions=\'\', data={}, overrideSchema=None, tags=[], priority = 0)')
    print('Make an API call to create an instance. \'Name\' is a compulsory string. \'Instructions\' is the markdown shown to the contributor for the instance. \'Data\' is a dictionary. \'Priority\' is an integer; a higher integer is higher priority, default 0.')
    print('- reiterateInstance(taskId, baseUrl, apiKey,instanceId')
    print('Generate one more iteration on the selected instance')
    print('- addAnnotation(taskId, baseUrl, apiKey, instanceId, key, value)')
    print('Add a key-value pair to the annotations of an instance. Will overwrite the existing annotation if the key already exists.')
    print('- deleteAnnotation(taskId, baseUrl, apiKey, instanceId, key)')
    print('Remove the specified key and its associated value from the annotations of an instance.')
    print('-----')
    print('- Instance Structure')
    print('Each entry in the list returned by getInstances() is a dictionary with the following entries:')
    print('id [instance id]\nname\ndata [a dictionary]\nstatus\ntags [a list of strings]\nsummary\ncreated\npriority\nannotations')
    print('- Results Structure')
    print('Each entry in the list returned by getResults() is a dictionary with the following entries:')
    print('instanceId\nstatus\nlastUpdated\nagreement\ntags [a list of strings]\nresult [a dictionary with entries \'data\' and \'isError\']\niterationResults [a list of entries in the structure below]')
    print('Note that \'result\' is the output of error checking and will be empty if that is off, even with only one iteration.')
    print('- Iteration Structure')
    print('Each entry in the list of iterationResults above is a dictionary with the following entries:')
    print('worker\nstart\nend\niterationId\ndata [a dictionary of the collected data keyed by input box names]\nisError')
    print('-----')
    print('- makeAuthHeader(apiKey)')
    print('Returns an HTTP Authorization header entry (in dictionary format) created from the provided API key. The API key can be accessed from the settings page in Studio.')
    print('- removeMetadata(data)')
    print('Removes the \'_metadata\' entry from a dictionary - necessary for transferring data dictionaries form one task to another.')
    print('- cleanBaseUrl(url)')
    print('Adds https:// if it doesn\'t exist, and removes trailing slashes.')
    print('- checkHttpResponse(r)')
    print('Prints any HTTP error responses')

def info():
    help() 

def makeAuthHeader(apiKey):
    return {'Authorization': 'ApiKey {0}'.format(apiKey)}

def removeMetadata(x):
    x.pop('_metadata', None)
    return x

def cleanBaseUrl(url):
    url = url.rstrip('/')
    if(url[:4].lower()!='http'):
        url = 'https://' + url
    return url

def checkHttpResponse(r):
    if(r.status_code>=300):
        print('API request error')
        print('Url: ' + r.url)
        print('Status: ' + str(r.status_code))
        print('Reason: ' + r.reason) 
        print('Text: ' + r.text)
        print('Request body:')
        print(r.request.body)
    return r

def getResults(taskId, baseUrl, apiKey, incIncompleteInstances=False, incIterations=True): 
    if(incIncompleteInstances==True):
        incIncompleteInstances='true'
    if(incIncompleteInstances==False):
        incIncompleteInstances='false'
    if(incIterations==True):
        incIterations='true'
    if(incIterations==False):
        incIterations='false'
        
    authHeader = makeAuthHeader(apiKey)
    baseUrl = cleanBaseUrl(baseUrl)
    with requests.Session() as s:
        s.headers.update(authHeader)
        
        paginatedUrl = '{0}/api/tasks/{1}/results?perPage=1000&incIncompleteInstances={2}&incIterations={3}'.format(baseUrl, taskId, incIncompleteInstances, incIterations)
        results = []

        while paginatedUrl is not None:            
            response = checkHttpResponse(s.get(paginatedUrl))         
            results += response.json()
            n = response.links["next"] if "next" in response.links else None
            if n is not None:
                paginatedUrl = baseUrl + n["url"]
            else:
                paginatedUrl = None
    return results    

def getInstances(taskId, baseUrl, apiKey, expandSummary=True): 
    authHeader = makeAuthHeader(apiKey)
    baseUrl = cleanBaseUrl(baseUrl)
    with requests.Session() as s:
        s.headers.update(authHeader)
        expandSummaryOption = '&expand=summary' if expandSummary else ''
        paginatedUrl = '{0}/api/tasks/{1}/instances?perPage=1000{2}'.format(baseUrl, taskId, expandSummaryOption)
        instances = []

        while paginatedUrl is not None:
            response = checkHttpResponse(s.get(paginatedUrl))
            instances += response.json()
            n = response.links["next"] if "next" in response.links else None
            if n is not None:
                paginatedUrl = baseUrl + n["url"]
            else:
                paginatedUrl = None
    return instances

def getInstance(taskId, baseUrl, apiKey, instanceId, expandSummary=True): 
    authHeader = makeAuthHeader(apiKey)
    baseUrl = cleanBaseUrl(baseUrl)
    with requests.Session() as s:
        s.headers.update(authHeader)
        expandSummaryOption = '?expand=summary' if expandSummary else ''
        paginatedUrl = '{0}/api/tasks/{1}/instances/{2}{3}'.format(baseUrl, taskId, instanceId, expandSummaryOption)
        response = checkHttpResponse(s.get(paginatedUrl))
            
    return response.json()     

def getInstanceIds(taskId, baseUrl, apiKey):
    instances = getInstances(taskId, baseUrl, apiKey)
    instanceIds = []
    for i in instances:
        instanceIds.append(i.get('id'))
    return instanceIds

def transferEntry(source, target, entryField="data", sourceIdField="id", targetIdField="instanceId"):
    # source and target are each an array of dictionaries.
    # For each entry in source, extract "entry" and insert it into  
    # the dictionary in target in which sourceId matches targetId.
    # By default transfers "data" from list of instance dictionaries to list of results dictionaries.
    # If entry doesn't exist in source, insert null into target
    
    # Create set of sourceId : entry pairs
    sourceIdEntryPairs = {}
    for s in source:
        entry = s.get(entryField)
        sourceId = s.get(sourceIdField)
        sourceIdEntryPairs[sourceId] = entry
    for t in target:
        targetId = t.get(targetIdField)
        t[entryField] = sourceIdEntryPairs.get(targetId)

def getInstancesAndResults(taskId, baseUrl, apiKey, expandSummary=True, incIncompleteInstances=False, incIterations=True):
    #Make API calls for both instances and results, and transfer data from the former to the latter.
    instances = getInstances(taskId, baseUrl, apiKey, expandSummary)
    results = getResults(taskId, baseUrl, apiKey, incIncompleteInstances, incIterations)
    transferEntry(instances, results)
    return results

def listFilesUploaded(taskId, baseUrl, apiKey):
    # Make API call to get list of filenames uploaded to the task.
    authHeader = makeAuthHeader(apiKey)
    baseUrl = cleanBaseUrl(baseUrl)
    with requests.Session() as s:
        s.headers.update(authHeader)
        paginatedUrl = '{0}/api/tasks/{1}/files?perPage=1000'.format(baseUrl, taskId)
        result = []

        while paginatedUrl is not None:
            response = checkHttpResponse(s.get(paginatedUrl))
            result += response.json()
            n = response.links["next"] if "next" in response.links else None
            if n is not None:
                paginatedUrl = baseUrl + n["url"]
            else:
                paginatedUrl = None
        lstFilesAlreadyUploaded = map(lambda x: x.get('filename'), result)
    return list(lstFilesAlreadyUploaded)

def uploadFiles(taskId, baseUrl, apiKey, lstFilenames, localRepo, overwrite=False):    
    if(overwrite==False):
        filesUploaded = listFilesUploaded(taskId, baseUrl,apiKey)
        lstFilenames = list(set(lstFilenames) - set(filesUploaded))
        
    authHeader = makeAuthHeader(apiKey)
    baseUrl = cleanBaseUrl(baseUrl)
    with requests.Session() as s:
        s.headers.update(authHeader)
        fileUrl = '{0}/api/tasks/{1}/files'.format(baseUrl, taskId)
        files = map(lambda x: os.path.join(localRepo, x), lstFilenames)

        for filename in files:
            with open(filename, 'rb') as f:
                try:
                    response = checkHttpResponse(s.post(fileUrl, files = {'file' : f}))
                except:
                    continue

def downloadFile(filepath, localRepo, prefix='', overwrite=False):

    pattern = r'/hivemind\.lambda\.task\.\d+/output/\d+/\d+/(.*)\?X-Amz-Expires='
    filename = re.search(pattern, filepath).group(1)

    newFilename = '{0}_{1}'.format(prefix, filename) if prefix!='' else filename

    lstFilesDownloaded = os.listdir(localRepo)
    if overwrite or (newFilename not in lstFilesDownloaded):
        urlrequest.urlretrieve(filepath, os.path.join(localRepo, newFilename))

    return newFilename

def getIterations(taskId, baseUrl, apiKey, instanceId): 
    authHeader = makeAuthHeader(apiKey)
    baseUrl = cleanBaseUrl(baseUrl)
    with requests.Session() as s:
        s.headers.update(authHeader)        
        iterationResults = checkHttpResponse(s.get('{0}/api/tasks/{1}/instances/{2}/results'.format(baseUrl, taskId, instanceId))).json()
    return iterationResults       

def getIterationIds(taskId, baseUrl, apiKey, instanceId):
    iterationResults = getIterations(taskId, baseUrl, apiKey, instanceId)
    iterationIds = []
    for i in iterationResults:
        iterationIds.append(i.get('iterationId'))
    return iterationIds
	
	
def deleteIteration(taskId, baseUrl, apiKey, instanceId, iterationId):    
    authHeader = makeAuthHeader(apiKey)
    baseUrl = cleanBaseUrl(baseUrl)
    with requests.Session() as s:
        s.headers.update(authHeader)
        response = checkHttpResponse(s.delete('{0}/api/tasks/{1}/instances/{2}/iterations/{3}'.format(baseUrl, taskId, instanceId, iterationId))) 
    return response

def deleteInstance(taskId, baseUrl, apiKey, instanceId):
    authHeader = makeAuthHeader(apiKey)
    baseUrl = cleanBaseUrl(baseUrl)
    iterationIds = getIterationIds(taskId, baseUrl, apiKey, instanceId)
    
    for iterationId in iterationIds:
        deleteIteration(taskId, baseUrl, apiKey, instanceId, iterationId)
    
    with requests.Session() as s:
        s.headers.update(authHeader)
        response = checkHttpResponse(s.delete('{0}/api/tasks/{1}/instances/{2}'.format(baseUrl, taskId, instanceId)))
    return response

def createInstance(taskId, baseUrl, apiKey, name, instructions='', data={}, overrideSchema=None, tags=[], priority=0):
    # overrideSchema must either have a value or be null; cannot be {}
    if overrideSchema=={}:
        overrideSchema = None
    authHeader = makeAuthHeader(apiKey)
    with requests.Session() as s:
        s.headers.update(authHeader)
        baseUrl = cleanBaseUrl(baseUrl)               
        instance = {
            'name' : name,
            'instruction' : instructions,
            'data' : data,
            'overrideSchema' : overrideSchema,
            'tags' : tags,
            'priority' : priority
        }        
        response = checkHttpResponse(s.post('{0}/api/tasks/{1}/instances'.format(baseUrl, taskId), json = instance))
    return response
        
def reiterateInstance(taskId, baseUrl, apiKey, instanceId):
    authHeader = makeAuthHeader(apiKey)
    with requests.Session() as s:
        s.headers.update(authHeader)
        baseUrl = cleanBaseUrl(baseUrl)               
        response = checkHttpResponse(s.post('{0}/api/tasks/{1}/instances/{2}/reiterate'.format(baseUrl, taskId,instanceId)))
    return response
        
        
def addAnnotation(taskId, baseUrl, apiKey, instanceId, key, value):
    authHeader = makeAuthHeader(apiKey)
    with requests.Session() as s:
        s.headers.update(authHeader)
        baseUrl = cleanBaseUrl(baseUrl)               
        data = {
            'key': key,
            'value':value
        }        
        response = checkHttpResponse(s.post('{0}/api/tasks/{1}/instances/{2}/annotations'.format(baseUrl, taskId, instanceId), json = data))
    return response
        
def deleteAnnotation(taskId, baseUrl, apiKey, instanceId, key):
    authHeader = makeAuthHeader(apiKey)
    with requests.Session() as s:
        s.headers.update(authHeader)
        baseUrl = cleanBaseUrl(baseUrl)           
        response = checkHttpResponse(s.delete('{0}/api/tasks/{1}/instances/{2}/annotations/{3}'.format(baseUrl, taskId, instanceId, key)))
    return response


