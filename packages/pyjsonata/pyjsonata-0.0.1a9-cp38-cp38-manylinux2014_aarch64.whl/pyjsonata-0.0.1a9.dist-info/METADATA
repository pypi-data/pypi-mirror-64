Metadata-Version: 2.1
Name: pyjsonata
Version: 0.0.1a9
Summary: Python bindings for JSONata
Home-page: https://github.com/qlyoung/pyjsonata
Author: Quentin Young
Author-email: qlyoung@qlyoung.net
License: UNKNOWN
Platform: UNKNOWN
Classifier: Development Status :: 2 - Pre-Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Description-Content-Type: text/markdown

# pyjsonata

Python bindings for [JSONata](https://jsonata.org).


## Building

Required build tools:
* docker

If you want to run tests:
* pytest


*To build:*

Ready?

- From the repository root:

  ```
  ./build.sh
  ```

- If the stars have aligned, and it is Tuesday, you will now have a built
  `pyjsonata` wheel

- If you are me:

  ```
  python3 -m twine upload --repository-url https://upload.pypi.org/legacy/ dist/*manylinux2014_x86_64.whl
  ```

The best part about all this is that it builds a `.so` using the build
procedure for CPython extensions provided by setuptools. This isn't even a
CPython extension. It just uses ctypes. But there isn't any packaging support
at all for people who use the runtime-agnostic FFI library built into Python.

Building this package is harder than writing it. Thank you, Python.


## Testing

### Pytest

From the repository root:

```
python3 -m pip install pytest
python3 -m pytest
```

## Usage

```python
from pyjsonata import jsonata

my_expression = "$"
my_json = "{'foo': 'bar'}"

# "{'foo': 'bar'}"
result = jsonata(my_expression, my_json)
```

With exception handling:

```python
from pyjsonata import jsonata, PyjsonataError

my_expression = "$"
my_json = "{'foo': 'bar'}"

# "{'foo': 'bar'}"

try:
    result = jsonata(my_expression, my_json)
except PyjsonataError as e:
    print("Error: ", e)
```


That's it! Return values are always strings.


