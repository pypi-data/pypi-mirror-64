# coding: utf-8

"""
    Edge Impulse API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from edge_impulse_sdk.api_client import ApiClient
from edge_impulse_sdk.exceptions import (
    ApiTypeError,
    ApiValueError
)


class DSPApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def download_dsp_data(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Download DSP data  # noqa: E501

        Download raw output from a DSP block over all data in the training set, already sliced in windows. In Numpy binary format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dsp_data(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.download_dsp_data_with_http_info(project_id, dsp_id, **kwargs)  # noqa: E501

    def download_dsp_data_with_http_info(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Download DSP data  # noqa: E501

        Download raw output from a DSP block over all data in the training set, already sliced in windows. In Numpy binary format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dsp_data_with_http_info(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_dsp_data" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `download_dsp_data`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `download_dsp_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp-data/{dspId}/x', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_dsp_labels(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Download DSP labels  # noqa: E501

        Download labels for a DSP block over all data in the training set, already sliced in windows.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dsp_labels(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.download_dsp_labels_with_http_info(project_id, dsp_id, **kwargs)  # noqa: E501

    def download_dsp_labels_with_http_info(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Download DSP labels  # noqa: E501

        Download labels for a DSP block over all data in the training set, already sliced in windows.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dsp_labels_with_http_info(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_dsp_labels" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `download_dsp_labels`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `download_dsp_labels`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp-data/{dspId}/y', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dsp_get_features_for_sample(self, project_id, dsp_id, sample_id, **kwargs):  # noqa: E501
        """Features for sample  # noqa: E501

        Runs the DSP block against a sample. This will move the sliding window (dependent on the sliding window length and the sliding window increase parameters in the impulse) over the complete file, and run the DSP function for every window that is extracted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dsp_get_features_for_sample(project_id, dsp_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DspSampleFeaturesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.dsp_get_features_for_sample_with_http_info(project_id, dsp_id, sample_id, **kwargs)  # noqa: E501

    def dsp_get_features_for_sample_with_http_info(self, project_id, dsp_id, sample_id, **kwargs):  # noqa: E501
        """Features for sample  # noqa: E501

        Runs the DSP block against a sample. This will move the sliding window (dependent on the sliding window length and the sliding window increase parameters in the impulse) over the complete file, and run the DSP function for every window that is extracted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dsp_get_features_for_sample_with_http_info(project_id, dsp_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DspSampleFeaturesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'sample_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dsp_get_features_for_sample" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `dsp_get_features_for_sample`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `dsp_get_features_for_sample`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `dsp_get_features_for_sample`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/features/get-graph/classification/{sampleId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DspSampleFeaturesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dsp_sample_trained_features(self, project_id, dsp_id, sample_features_request, **kwargs):  # noqa: E501
        """Sample of trained features  # noqa: E501

        Get a sample of trained features, this extracts a number of samples and their labels. Used to visualize the current training set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dsp_sample_trained_features(project_id, dsp_id, sample_features_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param SampleFeaturesRequest sample_features_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DspTrainedFeaturesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.dsp_sample_trained_features_with_http_info(project_id, dsp_id, sample_features_request, **kwargs)  # noqa: E501

    def dsp_sample_trained_features_with_http_info(self, project_id, dsp_id, sample_features_request, **kwargs):  # noqa: E501
        """Sample of trained features  # noqa: E501

        Get a sample of trained features, this extracts a number of samples and their labels. Used to visualize the current training set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dsp_sample_trained_features_with_http_info(project_id, dsp_id, sample_features_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param SampleFeaturesRequest sample_features_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DspTrainedFeaturesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'sample_features_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dsp_sample_trained_features" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `dsp_sample_trained_features`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `dsp_sample_trained_features`")  # noqa: E501
        # verify the required parameter 'sample_features_request' is set
        if self.api_client.client_side_validation and ('sample_features_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_features_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_features_request` when calling `dsp_sample_trained_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sample_features_request' in local_var_params:
            body_params = local_var_params['sample_features_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/features/get-graph', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DspTrainedFeaturesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dsp_config(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Get config  # noqa: E501

        Retrieve the configuration parameters for the DSP block. Use the impulse functions to retrieve all DSP blocks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_config(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DSPConfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dsp_config_with_http_info(project_id, dsp_id, **kwargs)  # noqa: E501

    def get_dsp_config_with_http_info(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Get config  # noqa: E501

        Retrieve the configuration parameters for the DSP block. Use the impulse functions to retrieve all DSP blocks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_config_with_http_info(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DSPConfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dsp_config" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_dsp_config`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `get_dsp_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DSPConfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dsp_feature_labels(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Feature labels  # noqa: E501

        Retrieve the names of the features the DSP block generates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_feature_labels(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DspFeatureLabelsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dsp_feature_labels_with_http_info(project_id, dsp_id, **kwargs)  # noqa: E501

    def get_dsp_feature_labels_with_http_info(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Feature labels  # noqa: E501

        Retrieve the names of the features the DSP block generates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_feature_labels_with_http_info(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DspFeatureLabelsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dsp_feature_labels" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_dsp_feature_labels`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `get_dsp_feature_labels`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/features/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DspFeatureLabelsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dsp_metadata(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Get metadata  # noqa: E501

        Retrieve the metadata from a generated DSP block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_metadata(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DSPMetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dsp_metadata_with_http_info(project_id, dsp_id, **kwargs)  # noqa: E501

    def get_dsp_metadata_with_http_info(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Get metadata  # noqa: E501

        Retrieve the metadata from a generated DSP block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_metadata_with_http_info(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DSPMetadataResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dsp_metadata" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_dsp_metadata`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `get_dsp_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DSPMetadataResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dsp_raw_sample(self, project_id, dsp_id, sample_id, **kwargs):  # noqa: E501
        """Get raw sample  # noqa: E501

        Get raw sample data, but with only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out. If you pass dspId = 0 this will return a raw graph without any processing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_raw_sample(project_id, dsp_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int limit_payload_values: Limit the number of payload values in the response
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetSampleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dsp_raw_sample_with_http_info(project_id, dsp_id, sample_id, **kwargs)  # noqa: E501

    def get_dsp_raw_sample_with_http_info(self, project_id, dsp_id, sample_id, **kwargs):  # noqa: E501
        """Get raw sample  # noqa: E501

        Get raw sample data, but with only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out. If you pass dspId = 0 this will return a raw graph without any processing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_raw_sample_with_http_info(project_id, dsp_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int limit_payload_values: Limit the number of payload values in the response
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetSampleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'sample_id', 'limit_payload_values']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dsp_raw_sample" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_dsp_raw_sample`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `get_dsp_raw_sample`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `get_dsp_raw_sample`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []
        if 'limit_payload_values' in local_var_params and local_var_params['limit_payload_values'] is not None:  # noqa: E501
            query_params.append(('limitPayloadValues', local_var_params['limit_payload_values']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/raw-data/{sampleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSampleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dsp_sample_slice(self, project_id, dsp_id, sample_id, slice_start, slice_end, **kwargs):  # noqa: E501
        """Get raw sample (slice)  # noqa: E501

        Get slice of raw sample data, but with only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_sample_slice(project_id, dsp_id, sample_id, slice_start, slice_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int slice_start: Begin index of the slice (required)
        :param int slice_end: End index of the slice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetSampleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dsp_sample_slice_with_http_info(project_id, dsp_id, sample_id, slice_start, slice_end, **kwargs)  # noqa: E501

    def get_dsp_sample_slice_with_http_info(self, project_id, dsp_id, sample_id, slice_start, slice_end, **kwargs):  # noqa: E501
        """Get raw sample (slice)  # noqa: E501

        Get slice of raw sample data, but with only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_sample_slice_with_http_info(project_id, dsp_id, sample_id, slice_start, slice_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int slice_start: Begin index of the slice (required)
        :param int slice_end: End index of the slice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetSampleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'sample_id', 'slice_start', 'slice_end']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dsp_sample_slice" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `get_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `get_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'slice_start' is set
        if self.api_client.client_side_validation and ('slice_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['slice_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `slice_start` when calling `get_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'slice_end' is set
        if self.api_client.client_side_validation and ('slice_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['slice_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `slice_end` when calling `get_dsp_sample_slice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []
        if 'slice_start' in local_var_params and local_var_params['slice_start'] is not None:  # noqa: E501
            query_params.append(('sliceStart', local_var_params['slice_start']))  # noqa: E501
        if 'slice_end' in local_var_params and local_var_params['slice_end'] is not None:  # noqa: E501
            query_params.append(('sliceEnd', local_var_params['slice_end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/raw-data/{sampleId}/slice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSampleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def run_dsp_sample_slice(self, project_id, dsp_id, sample_id, slice_start, slice_end, dsp_run_request_without_features, **kwargs):  # noqa: E501
        """Get processed sample (slice)  # noqa: E501

        Get slice of sample data, and run it through the DSP block. This only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_dsp_sample_slice(project_id, dsp_id, sample_id, slice_start, slice_end, dsp_run_request_without_features, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int slice_start: Begin index of the slice (required)
        :param int slice_end: End index of the slice (required)
        :param DspRunRequestWithoutFeatures dsp_run_request_without_features: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DspRunResponseWithSample
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.run_dsp_sample_slice_with_http_info(project_id, dsp_id, sample_id, slice_start, slice_end, dsp_run_request_without_features, **kwargs)  # noqa: E501

    def run_dsp_sample_slice_with_http_info(self, project_id, dsp_id, sample_id, slice_start, slice_end, dsp_run_request_without_features, **kwargs):  # noqa: E501
        """Get processed sample (slice)  # noqa: E501

        Get slice of sample data, and run it through the DSP block. This only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_dsp_sample_slice_with_http_info(project_id, dsp_id, sample_id, slice_start, slice_end, dsp_run_request_without_features, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int slice_start: Begin index of the slice (required)
        :param int slice_end: End index of the slice (required)
        :param DspRunRequestWithoutFeatures dsp_run_request_without_features: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DspRunResponseWithSample, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'sample_id', 'slice_start', 'slice_end', 'dsp_run_request_without_features']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_dsp_sample_slice" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `run_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `run_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `run_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'slice_start' is set
        if self.api_client.client_side_validation and ('slice_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['slice_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `slice_start` when calling `run_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'slice_end' is set
        if self.api_client.client_side_validation and ('slice_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['slice_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `slice_end` when calling `run_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'dsp_run_request_without_features' is set
        if self.api_client.client_side_validation and ('dsp_run_request_without_features' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_run_request_without_features'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_run_request_without_features` when calling `run_dsp_sample_slice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []
        if 'slice_start' in local_var_params and local_var_params['slice_start'] is not None:  # noqa: E501
            query_params.append(('sliceStart', local_var_params['slice_start']))  # noqa: E501
        if 'slice_end' in local_var_params and local_var_params['slice_end'] is not None:  # noqa: E501
            query_params.append(('sliceEnd', local_var_params['slice_end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dsp_run_request_without_features' in local_var_params:
            body_params = local_var_params['dsp_run_request_without_features']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/raw-data/{sampleId}/slice/run', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DspRunResponseWithSample',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def run_dsp_single_frame(self, project_id, dsp_id, dsp_run_request, **kwargs):  # noqa: E501
        """Run DSP  # noqa: E501

        Run the DSP block for a single frame.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_dsp_single_frame(project_id, dsp_id, dsp_run_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param DspRunRequest dsp_run_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DspRunResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.run_dsp_single_frame_with_http_info(project_id, dsp_id, dsp_run_request, **kwargs)  # noqa: E501

    def run_dsp_single_frame_with_http_info(self, project_id, dsp_id, dsp_run_request, **kwargs):  # noqa: E501
        """Run DSP  # noqa: E501

        Run the DSP block for a single frame.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_dsp_single_frame_with_http_info(project_id, dsp_id, dsp_run_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param DspRunRequest dsp_run_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DspRunResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'dsp_run_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_dsp_single_frame" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `run_dsp_single_frame`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `run_dsp_single_frame`")  # noqa: E501
        # verify the required parameter 'dsp_run_request' is set
        if self.api_client.client_side_validation and ('dsp_run_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_run_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_run_request` when calling `run_dsp_single_frame`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dsp_run_request' in local_var_params:
            body_params = local_var_params['dsp_run_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/run', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DspRunResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_dsp_config(self, project_id, dsp_id, dsp_config_request, **kwargs):  # noqa: E501
        """Set config  # noqa: E501

        Set configuration parameters for the DSP block. Only values set in the body will be overwritten.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_dsp_config(project_id, dsp_id, dsp_config_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param DSPConfigRequest dsp_config_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GenericApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.set_dsp_config_with_http_info(project_id, dsp_id, dsp_config_request, **kwargs)  # noqa: E501

    def set_dsp_config_with_http_info(self, project_id, dsp_id, dsp_config_request, **kwargs):  # noqa: E501
        """Set config  # noqa: E501

        Set configuration parameters for the DSP block. Only values set in the body will be overwritten.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_dsp_config_with_http_info(project_id, dsp_id, dsp_config_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param DSPConfigRequest dsp_config_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GenericApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'dsp_config_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_dsp_config" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `set_dsp_config`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `set_dsp_config`")  # noqa: E501
        # verify the required parameter 'dsp_config_request' is set
        if self.api_client.client_side_validation and ('dsp_config_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_config_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_config_request` when calling `set_dsp_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dsp_config_request' in local_var_params:
            body_params = local_var_params['dsp_config_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GenericApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
