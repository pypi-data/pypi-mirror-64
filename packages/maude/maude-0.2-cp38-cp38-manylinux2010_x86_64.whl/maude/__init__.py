# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _maude
else:
    import _maude

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _maude.delete_SwigPyIterator

    def value(self):
        return _maude.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _maude.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _maude.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _maude.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _maude.SwigPyIterator_equal(self, x)

    def copy(self):
        return _maude.SwigPyIterator_copy(self)

    def next(self):
        return _maude.SwigPyIterator_next(self)

    def __next__(self):
        return _maude.SwigPyIterator___next__(self)

    def previous(self):
        return _maude.SwigPyIterator_previous(self)

    def advance(self, n):
        return _maude.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _maude.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _maude.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _maude.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _maude.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _maude.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _maude.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _maude:
_maude.SwigPyIterator_swigregister(SwigPyIterator)


class VectorIterator:
	def __init__(self, vect, length):
		self.vect = vect
		self.i = 0
		self.length = length

	def __iter__(self):
		return self

	def __next__(self):
		if self.i >= self.length:
			raise StopIteration
		self.i = self.i + 1
		return self.vect[self.i - 1]

class TokenVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.TokenVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.TokenVector___nonzero__(self)

    def __bool__(self):
        return _maude.TokenVector___bool__(self)

    def __len__(self):
        return _maude.TokenVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.TokenVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.TokenVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.TokenVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.TokenVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.TokenVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.TokenVector___setitem__(self, *args)

    def pop(self):
        return _maude.TokenVector_pop(self)

    def append(self, x):
        return _maude.TokenVector_append(self, x)

    def empty(self):
        return _maude.TokenVector_empty(self)

    def size(self):
        return _maude.TokenVector_size(self)

    def swap(self, v):
        return _maude.TokenVector_swap(self, v)

    def begin(self):
        return _maude.TokenVector_begin(self)

    def end(self):
        return _maude.TokenVector_end(self)

    def rbegin(self):
        return _maude.TokenVector_rbegin(self)

    def rend(self):
        return _maude.TokenVector_rend(self)

    def clear(self):
        return _maude.TokenVector_clear(self)

    def get_allocator(self):
        return _maude.TokenVector_get_allocator(self)

    def pop_back(self):
        return _maude.TokenVector_pop_back(self)

    def erase(self, *args):
        return _maude.TokenVector_erase(self, *args)

    def __init__(self, *args):
        _maude.TokenVector_swiginit(self, _maude.new_TokenVector(*args))

    def push_back(self, x):
        return _maude.TokenVector_push_back(self, x)

    def front(self):
        return _maude.TokenVector_front(self)

    def back(self):
        return _maude.TokenVector_back(self)

    def assign(self, n, x):
        return _maude.TokenVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.TokenVector_resize(self, *args)

    def insert(self, *args):
        return _maude.TokenVector_insert(self, *args)

    def reserve(self, n):
        return _maude.TokenVector_reserve(self, n)

    def capacity(self):
        return _maude.TokenVector_capacity(self)
    __swig_destroy__ = _maude.delete_TokenVector

# Register TokenVector in _maude:
_maude.TokenVector_swigregister(TokenVector)

class ModuleHeaderVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.ModuleHeaderVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.ModuleHeaderVector___nonzero__(self)

    def __bool__(self):
        return _maude.ModuleHeaderVector___bool__(self)

    def __len__(self):
        return _maude.ModuleHeaderVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.ModuleHeaderVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.ModuleHeaderVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.ModuleHeaderVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.ModuleHeaderVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.ModuleHeaderVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.ModuleHeaderVector___setitem__(self, *args)

    def pop(self):
        return _maude.ModuleHeaderVector_pop(self)

    def append(self, x):
        return _maude.ModuleHeaderVector_append(self, x)

    def empty(self):
        return _maude.ModuleHeaderVector_empty(self)

    def size(self):
        return _maude.ModuleHeaderVector_size(self)

    def swap(self, v):
        return _maude.ModuleHeaderVector_swap(self, v)

    def begin(self):
        return _maude.ModuleHeaderVector_begin(self)

    def end(self):
        return _maude.ModuleHeaderVector_end(self)

    def rbegin(self):
        return _maude.ModuleHeaderVector_rbegin(self)

    def rend(self):
        return _maude.ModuleHeaderVector_rend(self)

    def clear(self):
        return _maude.ModuleHeaderVector_clear(self)

    def get_allocator(self):
        return _maude.ModuleHeaderVector_get_allocator(self)

    def pop_back(self):
        return _maude.ModuleHeaderVector_pop_back(self)

    def erase(self, *args):
        return _maude.ModuleHeaderVector_erase(self, *args)

    def __init__(self, *args):
        _maude.ModuleHeaderVector_swiginit(self, _maude.new_ModuleHeaderVector(*args))

    def push_back(self, x):
        return _maude.ModuleHeaderVector_push_back(self, x)

    def front(self):
        return _maude.ModuleHeaderVector_front(self)

    def back(self):
        return _maude.ModuleHeaderVector_back(self)

    def assign(self, n, x):
        return _maude.ModuleHeaderVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.ModuleHeaderVector_resize(self, *args)

    def insert(self, *args):
        return _maude.ModuleHeaderVector_insert(self, *args)

    def reserve(self, n):
        return _maude.ModuleHeaderVector_reserve(self, n)

    def capacity(self):
        return _maude.ModuleHeaderVector_capacity(self)
    __swig_destroy__ = _maude.delete_ModuleHeaderVector

# Register ModuleHeaderVector in _maude:
_maude.ModuleHeaderVector_swigregister(ModuleHeaderVector)

class ViewVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.ViewVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.ViewVector___nonzero__(self)

    def __bool__(self):
        return _maude.ViewVector___bool__(self)

    def __len__(self):
        return _maude.ViewVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.ViewVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.ViewVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.ViewVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.ViewVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.ViewVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.ViewVector___setitem__(self, *args)

    def pop(self):
        return _maude.ViewVector_pop(self)

    def append(self, x):
        return _maude.ViewVector_append(self, x)

    def empty(self):
        return _maude.ViewVector_empty(self)

    def size(self):
        return _maude.ViewVector_size(self)

    def swap(self, v):
        return _maude.ViewVector_swap(self, v)

    def begin(self):
        return _maude.ViewVector_begin(self)

    def end(self):
        return _maude.ViewVector_end(self)

    def rbegin(self):
        return _maude.ViewVector_rbegin(self)

    def rend(self):
        return _maude.ViewVector_rend(self)

    def clear(self):
        return _maude.ViewVector_clear(self)

    def get_allocator(self):
        return _maude.ViewVector_get_allocator(self)

    def pop_back(self):
        return _maude.ViewVector_pop_back(self)

    def erase(self, *args):
        return _maude.ViewVector_erase(self, *args)

    def __init__(self, *args):
        _maude.ViewVector_swiginit(self, _maude.new_ViewVector(*args))

    def push_back(self, x):
        return _maude.ViewVector_push_back(self, x)

    def front(self):
        return _maude.ViewVector_front(self)

    def back(self):
        return _maude.ViewVector_back(self)

    def assign(self, n, x):
        return _maude.ViewVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.ViewVector_resize(self, *args)

    def insert(self, *args):
        return _maude.ViewVector_insert(self, *args)

    def reserve(self, n):
        return _maude.ViewVector_reserve(self, n)

    def capacity(self):
        return _maude.ViewVector_capacity(self)
    __swig_destroy__ = _maude.delete_ViewVector

# Register ViewVector in _maude:
_maude.ViewVector_swigregister(ViewVector)


def init(loadPrelude=True):
    return _maude.init(loadPrelude)

def load(name):
    return _maude.load(name)

def input(text):
    return _maude.input(text)

def getCurrentModule():
    return _maude.getCurrentModule()

def getModule(name):
    return _maude.getModule(name)

def tokenize(str):
    return _maude.tokenize(str)

def getModules():
    return _maude.getModules()

def getViews():
    return _maude.getViews()
class ModuleHeader(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    type = property(_maude.ModuleHeader_type_get, _maude.ModuleHeader_type_set)
    name = property(_maude.ModuleHeader_name_get, _maude.ModuleHeader_name_set)

    def __repr__(self):
        return _maude.ModuleHeader___repr__(self)

    def __init__(self):
        _maude.ModuleHeader_swiginit(self, _maude.new_ModuleHeader())
    __swig_destroy__ = _maude.delete_ModuleHeader

# Register ModuleHeader in _maude:
_maude.ModuleHeader_swigregister(ModuleHeader)

class ModuleItem(object):
    r"""An item that belongs to a module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getModule(self):
        r"""Get the module where this item is defined."""
        return _maude.ModuleItem_getModule(self)
    __swig_destroy__ = _maude.delete_ModuleItem

# Register ModuleItem in _maude:
_maude.ModuleItem_swigregister(ModuleItem)

class Equation(ModuleItem):
    r"""A Maude equation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.Equation_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.Equation_getRhs(self)

    def getLabel(self):
        return _maude.Equation_getLabel(self)

    def isNonexec(self):
        r"""Whether the equation has the ``nonexec`` attribute."""
        return _maude.Equation_isNonexec(self)

    def hasCondition(self):
        r"""Whether the equation has a condition."""
        return _maude.Equation_hasCondition(self)

    def getCondition(self):
        r"""Get the condition of the equation."""
        return _maude.Equation_getCondition(self)

    def __repr__(self):
        return _maude.Equation___repr__(self)
    __swig_destroy__ = _maude.delete_Equation

# Register Equation in _maude:
_maude.Equation_swigregister(Equation)

class Sort(ModuleItem):
    r"""A Maude sort."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def kind(self):
        return _maude.Sort_kind(self)

    def getSubsorts(self):
        r"""Get the subsorts of this sort."""
        return _maude.Sort_getSubsorts(self)

    def getSupersorts(self):
        r"""Get the supersorts of this sort."""
        return _maude.Sort_getSupersorts(self)

    def leq(self, rhs):
        r"""
        Check if this sort is a subsort of the given sort.

        :type rhs: :py:class:`Sort`
        :param rhs: The right-hand side of the comparison.
        """
        return _maude.Sort_leq(self, rhs)

    def __repr__(self):
        return _maude.Sort___repr__(self)
    __swig_destroy__ = _maude.delete_Sort

# Register Sort in _maude:
_maude.Sort_swigregister(Sort)

class Kind(object):
    r"""A Maude kind (connected component of sorts)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def __repr__(self):
        return _maude.Kind___repr__(self)
    __swig_destroy__ = _maude.delete_Kind

# Register Kind in _maude:
_maude.Kind_swigregister(Kind)

class MembershipAxiom(object):
    r"""A sort membership axiom."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the term of the membership axiom."""
        return _maude.MembershipAxiom_getLhs(self)

    def getSort(self):
        r"""Get the sort of the membership axiom."""
        return _maude.MembershipAxiom_getSort(self)

    def getLabel(self):
        return _maude.MembershipAxiom_getLabel(self)

    def __repr__(self):
        return _maude.MembershipAxiom___repr__(self)
    __swig_destroy__ = _maude.delete_MembershipAxiom

# Register MembershipAxiom in _maude:
_maude.MembershipAxiom_swigregister(MembershipAxiom)

class Symbol(ModuleItem):
    r"""A Maude system (operator at the kind level)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def arity(self):
        r"""Get the number of arguments."""
        return _maude.Symbol_arity(self)

    def domainComponent(self, argNr):
        r"""
        Get the kind for the given argument.

        :type argNr: int
        :param argNr: The argument number.
        """
        return _maude.Symbol_domainComponent(self, argNr)

    def getRangeSort(self):
        r"""Get the range sort of the symbol."""
        return _maude.Symbol_getRangeSort(self)

    def __repr__(self):
        return _maude.Symbol___repr__(self)
    __swig_destroy__ = _maude.delete_Symbol

# Register Symbol in _maude:
_maude.Symbol_swigregister(Symbol)

class Rule(ModuleItem):
    r"""A Maude rewrite rule."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.Rule_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.Rule_getRhs(self)

    def getLabel(self):
        return _maude.Rule_getLabel(self)

    def isNarrowing(self):
        r"""Whether the rule has the ``narrowing`` attribute."""
        return _maude.Rule_isNarrowing(self)

    def hasCondition(self):
        r"""Whether the rule has a condition."""
        return _maude.Rule_hasCondition(self)

    def getCondition(self):
        r"""Get the condition of the rule."""
        return _maude.Rule_getCondition(self)

    def __repr__(self):
        return _maude.Rule___repr__(self)
    __swig_destroy__ = _maude.delete_Rule

# Register Rule in _maude:
_maude.Rule_swigregister(Rule)

class StrategyExpression(object):
    r"""An expression of the Maude strategy language."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _maude.delete_StrategyExpression

    def equal(self, other):
        r"""
        Check whether two strategy expression are the same.

        Notes: Not accurate (false negatives).
        """
        return _maude.StrategyExpression_equal(self, other)

    def __repr__(self):
        return _maude.StrategyExpression___repr__(self)

# Register StrategyExpression in _maude:
_maude.StrategyExpression_swigregister(StrategyExpression)

class RewriteStrategy(ModuleItem):
    r"""A named rewriting strategy."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getDomain(self):
        r"""Get the argument domain."""
        return _maude.RewriteStrategy_getDomain(self)

    def getSubjectSort(self):
        r"""Get the sort to which the strategy is intended to be applied."""
        return _maude.RewriteStrategy_getSubjectSort(self)

    def getDefinitions(self):
        r"""Get the definitions for this strategy."""
        return _maude.RewriteStrategy_getDefinitions(self)

    def arity(self):
        r"""Get the number of arguments of the strategy."""
        return _maude.RewriteStrategy_arity(self)

    def getName(self):
        return _maude.RewriteStrategy_getName(self)

    def __repr__(self):
        return _maude.RewriteStrategy___repr__(self)
    __swig_destroy__ = _maude.delete_RewriteStrategy

# Register RewriteStrategy in _maude:
_maude.RewriteStrategy_swigregister(RewriteStrategy)

class StrategyDefinition(ModuleItem):
    r"""A Maude strategy definition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getLhs(self):
        r"""Get the left-hand side of the strategy definition as a Maude term."""
        return _maude.StrategyDefinition_getLhs(self)

    def getRhs(self):
        r"""Get the strategy definition."""
        return _maude.StrategyDefinition_getRhs(self)

    def getStrategy(self):
        r"""Get the named strategy being defined."""
        return _maude.StrategyDefinition_getStrategy(self)

    def getLabel(self):
        return _maude.StrategyDefinition_getLabel(self)

    def __repr__(self):
        return _maude.StrategyDefinition___repr__(self)
    __swig_destroy__ = _maude.delete_StrategyDefinition

# Register StrategyDefinition in _maude:
_maude.StrategyDefinition_swigregister(StrategyDefinition)

class Token(object):
    r"""A syntactical unit."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def name(self):
        r"""Get the name of the token."""
        return _maude.Token_name(self)

    def __init__(self, name):
        _maude.Token_swiginit(self, _maude.new_Token(name))

    def __repr__(self):
        return _maude.Token___repr__(self)
    __swig_destroy__ = _maude.delete_Token

# Register Token in _maude:
_maude.Token_swigregister(Token)

class Condition(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length=0):
        r"""
        Construct a vector.

        :type length: int
        :param length: The initial length.
        """
        _maude.Condition_swiginit(self, _maude.new_Condition(length))

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.Condition_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.Condition_size(self)

    def capacity(self):
        r"""Reserved capacity of the vector."""
        return _maude.Condition_capacity(self)

    def swap(self, other):
        r"""
        Swap this vector's contents with another.

        :type other: Vector< ConditionFragment * >
        :param other: The other vector.
        """
        return _maude.Condition_swap(self, other)

    def __getitem__(self, n):
        return _maude.Condition___getitem__(self, n)

    def __setitem(self, n, value):
        return _maude.Condition___setitem(self, n, value)

    def __len__(self):
        return _maude.Condition___len__(self)

    def __append(self, item):
        return _maude.Condition___append(self, item)

    def __setitem__(self, n, v):
    	v.thisown = 0
    	self.__setitem(n, v)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	vector_str = str(self[0])
    	for i in range(1, len(self)):
    		vector_str = vector_str + ', ' + str(self[i])

    	return vector_str

    def append(self, v):
    	v.thisown = 0
    	self.__append(v)


    def clear(self):
        r"""Set the vector length to zero."""
        return _maude.Condition_clear(self)

    def resize(self, new_size):
        r"""
        Resize the vector.

        :type new_size: int
        :param new_size: New size.
        """
        return _maude.Condition_resize(self, new_size)
    __swig_destroy__ = _maude.delete_Condition

# Register Condition in _maude:
_maude.Condition_swigregister(Condition)

class ConditionFragment(object):
    r"""A generic condition fragment."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def __repr__(self):
        return _maude.ConditionFragment___repr__(self)
    __swig_destroy__ = _maude.delete_ConditionFragment

# Register ConditionFragment in _maude:
_maude.ConditionFragment_swigregister(ConditionFragment)

class EqualityCondition(ConditionFragment):
    r"""An equality ``t = t'`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.EqualityCondition_swiginit(self, _maude.new_EqualityCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.EqualityCondition_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.EqualityCondition_getRhs(self)

    def __repr__(self):
        return _maude.EqualityCondition___repr__(self)
    __swig_destroy__ = _maude.delete_EqualityCondition

# Register EqualityCondition in _maude:
_maude.EqualityCondition_swigregister(EqualityCondition)

class AssignmentCondition(ConditionFragment):
    r"""An assignment ``t := t'`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.AssignmentCondition_swiginit(self, _maude.new_AssignmentCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.AssignmentCondition_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.AssignmentCondition_getRhs(self)

    def __repr__(self):
        return _maude.AssignmentCondition___repr__(self)
    __swig_destroy__ = _maude.delete_AssignmentCondition

# Register AssignmentCondition in _maude:
_maude.AssignmentCondition_swigregister(AssignmentCondition)

class RewriteCondition(ConditionFragment):
    r"""A rewrite ``t => t'`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.RewriteCondition_swiginit(self, _maude.new_RewriteCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the left-hand-side term."""
        return _maude.RewriteCondition_getLhs(self)

    def getRhs(self):
        r"""Get the right-hand-side term."""
        return _maude.RewriteCondition_getRhs(self)

    def __repr__(self):
        return _maude.RewriteCondition___repr__(self)
    __swig_destroy__ = _maude.delete_RewriteCondition

# Register RewriteCondition in _maude:
_maude.RewriteCondition_swigregister(RewriteCondition)

class SortTestCondition(ConditionFragment):
    r"""A sort test ``t : s`` condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, lhs, rhs):
        _maude.SortTestCondition_swiginit(self, _maude.new_SortTestCondition(lhs, rhs))

    def getLhs(self):
        r"""Get the term of the sort test."""
        return _maude.SortTestCondition_getLhs(self)

    def getSort(self):
        r"""Get the sort of the sort test."""
        return _maude.SortTestCondition_getSort(self)

    def __repr__(self):
        return _maude.SortTestCondition___repr__(self)
    __swig_destroy__ = _maude.delete_SortTestCondition

# Register SortTestCondition in _maude:
_maude.SortTestCondition_swigregister(SortTestCondition)

class StateTransitionGraph(object):
    r"""Complete rewriting graph from an initial state."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, term):
        r"""
        Construct a state transition graph.

        :type term: :py:class:`EasyTerm`
        :param term: Initial state.
        """
        _maude.StateTransitionGraph_swiginit(self, _maude.new_StateTransitionGraph(term))

    def getStateTerm(self, stateNr):
        r"""
        Get the term of the given state.

        :type stateNr: int
        :param stateNr: A state number.
        """
        return _maude.StateTransitionGraph_getStateTerm(self, stateNr)

    def getRule(self, origin, dest):
        r"""
        Get a rule that connectes two states.

        :type origin: int
        :param origin: Origin state number.
        :type dest: int
        :param dest: Destination state number.

        :rtype: :py:class:`Rule`
        :return: A rule that connects the two states.
        """
        return _maude.StateTransitionGraph_getRule(self, origin, dest)

    def getNrStates(self):
        r"""Get the number of states in the graph."""
        return _maude.StateTransitionGraph_getNrStates(self)

    def getNextState(self, stateNr, index):
        r"""
        List the successors of a state in the graph.

        :type stateNr: int
        :param stateNr: A state number.
        :type index: int
        :param index: A child index (from zero).

        :rtype: int
        :return: The state number of a successor or -1.
        """
        return _maude.StateTransitionGraph_getNextState(self, stateNr, index)

    def getStateParent(self, stateNr):
        r"""
        Get the (one) parent of a given state.

        :type stateNr: int
        :param stateNr: A state number.

        :rtype: int
        :return: The state number of the parent or -1.
        """
        return _maude.StateTransitionGraph_getStateParent(self, stateNr)
    __swig_destroy__ = _maude.delete_StateTransitionGraph

# Register StateTransitionGraph in _maude:
_maude.StateTransitionGraph_swigregister(StateTransitionGraph)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _maude.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _maude.StringVector___nonzero__(self)

    def __bool__(self):
        return _maude.StringVector___bool__(self)

    def __len__(self):
        return _maude.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _maude.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _maude.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _maude.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _maude.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _maude.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _maude.StringVector___setitem__(self, *args)

    def pop(self):
        return _maude.StringVector_pop(self)

    def append(self, x):
        return _maude.StringVector_append(self, x)

    def empty(self):
        return _maude.StringVector_empty(self)

    def size(self):
        return _maude.StringVector_size(self)

    def swap(self, v):
        return _maude.StringVector_swap(self, v)

    def begin(self):
        return _maude.StringVector_begin(self)

    def end(self):
        return _maude.StringVector_end(self)

    def rbegin(self):
        return _maude.StringVector_rbegin(self)

    def rend(self):
        return _maude.StringVector_rend(self)

    def clear(self):
        return _maude.StringVector_clear(self)

    def get_allocator(self):
        return _maude.StringVector_get_allocator(self)

    def pop_back(self):
        return _maude.StringVector_pop_back(self)

    def erase(self, *args):
        return _maude.StringVector_erase(self, *args)

    def __init__(self, *args):
        _maude.StringVector_swiginit(self, _maude.new_StringVector(*args))

    def push_back(self, x):
        return _maude.StringVector_push_back(self, x)

    def front(self):
        return _maude.StringVector_front(self)

    def back(self):
        return _maude.StringVector_back(self)

    def assign(self, n, x):
        return _maude.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _maude.StringVector_resize(self, *args)

    def insert(self, *args):
        return _maude.StringVector_insert(self, *args)

    def reserve(self, n):
        return _maude.StringVector_reserve(self, n)

    def capacity(self):
        return _maude.StringVector_capacity(self)
    __swig_destroy__ = _maude.delete_StringVector

# Register StringVector in _maude:
_maude.StringVector_swigregister(StringVector)

class StrategyTransitionGraph(object):
    r"""Complete rewriting graph under the control of a strategy from an initial state."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Construct a strategy transition graph.

        :type initial: :py:class:`EasyTerm`
        :param initial: Initial state.
        :type strat: :py:class:`StrategyExpression`
        :param strat: A strategy expression.
        :type opaques: std::vector< char const *,std::allocator< char const * > >
        :param opaques: A list of strategy names to be considered opaque.
        :type biased: boolean
        :param biased: Whether the matchrews should be biased.
        """
        _maude.StrategyTransitionGraph_swiginit(self, _maude.new_StrategyTransitionGraph(*args))

    def getStateTerm(self, stateNr):
        r"""
        Get the term of the given state.

        :type stateNr: int
        :param stateNr: A state number.
        """
        return _maude.StrategyTransitionGraph_getStateTerm(self, stateNr)

    def getNrStates(self):
        r"""Get the number of states in the graph."""
        return _maude.StrategyTransitionGraph_getNrStates(self)

    def getNextState(self, stateNr, index):
        r"""
        List the successors of a state in the graph.

        :type stateNr: int
        :param stateNr: A state number.
        :type index: int
        :param index: A child index (from zero).

        :rtype: int
        :return: The state number of a successor or -1.
        """
        return _maude.StrategyTransitionGraph_getNextState(self, stateNr, index)

    def isSolutionState(self, stateNr):
        r"""
        Whether the state is a solution for the strategy.

        :type stateNr: int
        :param stateNr: A state number.
        """
        return _maude.StrategyTransitionGraph_isSolutionState(self, stateNr)
    __swig_destroy__ = _maude.delete_StrategyTransitionGraph

# Register StrategyTransitionGraph in _maude:
_maude.StrategyTransitionGraph_swigregister(StrategyTransitionGraph)

class TermIntPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _maude.TermIntPair_swiginit(self, _maude.new_TermIntPair(*args))
    first = property(_maude.TermIntPair_first_get, _maude.TermIntPair_first_set)
    second = property(_maude.TermIntPair_second_get, _maude.TermIntPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _maude.delete_TermIntPair

# Register TermIntPair in _maude:
_maude.TermIntPair_swigregister(TermIntPair)

ONE_STEP = _maude.ONE_STEP
AT_LEAST_ONE_STEP = _maude.AT_LEAST_ONE_STEP
ANY_STEPS = _maude.ANY_STEPS
NORMAL_FORM = _maude.NORMAL_FORM
class Term(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _maude.delete_Term

    def symbol(self):
        return _maude.Term_symbol(self)

    def ground(self):
        return _maude.Term_ground(self)

    def equal(self, other):
        return _maude.Term_equal(self, other)

    def leq(self, sort):
        return _maude.Term_leq(self, sort)

    def getSort(self):
        return _maude.Term_getSort(self)

    def reduce(self):
        return _maude.Term_reduce(self)

    def rewrite(self, limit=-1):
        return _maude.Term_rewrite(self, limit)

    def frewrite(self, limit=-1, gas=-1):
        return _maude.Term_frewrite(self, limit, gas)

    def erewrite(self, limit=-1, gas=-1):
        return _maude.Term_erewrite(self, limit, gas)

    def match(self, *args):
        return _maude.Term_match(self, *args)

    def srewrite(self, expr, depth=False):
        return _maude.Term_srewrite(self, expr, depth)

    def search(self, *args):
        return _maude.Term_search(self, *args)

    def arguments(self):
        return _maude.Term_arguments(self)

    def copy(self):
        return _maude.Term_copy(self)

    def __repr__(self):
        return _maude.Term___repr__(self)

# Register Term in _maude:
_maude.Term_swigregister(Term)
cvar = _maude.cvar
Term.NO_CONDITION = _maude.cvar.Term_NO_CONDITION

class StrategicSearch(object):
    r"""An iterator through the solutions of a strategy search"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getRewriteCount(self):
        r"""Get the number of rewrites until the solution has been found."""
        return _maude.StrategicSearch_getRewriteCount(self)

    def __next(self):
        return _maude.StrategicSearch___next(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	v = self.__next()
    	if v is None:
    		raise StopIteration

    	return v, self.getRewriteCount()


    __swig_destroy__ = _maude.delete_StrategicSearch

# Register StrategicSearch in _maude:
_maude.StrategicSearch_swigregister(StrategicSearch)

class Substitution(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def size(self):
        return _maude.Substitution_size(self)

    def variable(self, index):
        return _maude.Substitution_variable(self, index)

    def value(self, index):
        return _maude.Substitution_value(self, index)

    def matchedPortion(self):
        return _maude.Substitution_matchedPortion(self)

    def __getitem__(self, index):
    	return self.variable(index), self.value(index)

    def __len__(self):
    	return self.size()

    def __iter__(self):
    	return VectorIterator(self, self.size())

    def __repr__(self):
    	return 'Subtitution with {} variables'.format(self.size())

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	vector_str = str(self.variable(0)) + '=' + str(self.value(0))
    	for i in range(1, len(self)):
    		vector_str = vector_str + ', ' + str(self.variable(i)) + '=' + str(self.value(i))

    	return vector_str

    __swig_destroy__ = _maude.delete_Substitution

# Register Substitution in _maude:
_maude.Substitution_swigregister(Substitution)

class MatchSearchState(object):
    r"""An iterator through the matching a term into a pattern"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __next(self):
        return _maude.MatchSearchState___next(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	nxt = self.__next()
    	if nxt is None:
    		raise StopIteration
    	return nxt

    __swig_destroy__ = _maude.delete_MatchSearchState

# Register MatchSearchState in _maude:
_maude.MatchSearchState_swigregister(MatchSearchState)

class RewriteSequenceSearch(object):
    r"""An iterator through the solutions of a search"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getRewriteCount(self):
        r"""Get the number of rewrites until this term has been found."""
        return _maude.RewriteSequenceSearch_getRewriteCount(self)

    def getSubstitution(self):
        r"""
        Get the substitution that make the found term match
        into the pattern.
        """
        return _maude.RewriteSequenceSearch_getSubstitution(self)

    def getRule(self, *args):
        r"""
        *Overload 1:*

        Get the rule leading to this term.

        |

        *Overload 2:*

        Get the rule leading to the given state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.
        """
        return _maude.RewriteSequenceSearch_getRule(self, *args)

    def getStateTerm(self, stateNr):
        r"""
        Get the term of a given state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.
        """
        return _maude.RewriteSequenceSearch_getStateTerm(self, stateNr)

    def __next(self):
        return _maude.RewriteSequenceSearch___next(self)

    def getStateNr(self):
        r"""
        Get an internal state number that allows reconstructing
        the path to this term.
        """
        return _maude.RewriteSequenceSearch_getStateNr(self)

    def getStateParent(self, stateNr):
        r"""
        Get the parent state.

        :type stateNr: int
        :param stateNr: The number of a state in the search graph.

        :rtype: int
        :return: The number of the parent or -1 for the root.
        """
        return _maude.RewriteSequenceSearch_getStateParent(self, stateNr)

    def __iter__(self):
    	return self

    def pathTo(self, stateNr):
    	parent = self.getStateParent(stateNr)

    	if parent < 0:
    		path = [self.getStateTerm(stateNr)]
    	else:
    		path = self.pathTo(parent)

    		path.append(self.getRule(stateNr))
    		path.append(self.getStateTerm(stateNr))

    	return path

    def __next__(self):
    	"""Get term found, the substitution, a function to retrieve"""
    	"""the rewriting path to the term, and the rewrite count"""
    	term = self.__next()
    	if term is None:
    		raise StopIteration
    	return term, self.getSubstitution(), lambda: self.pathTo(self.getStateNr()), self.getRewriteCount()

    __swig_destroy__ = _maude.delete_RewriteSequenceSearch

# Register RewriteSequenceSearch in _maude:
_maude.RewriteSequenceSearch_swigregister(RewriteSequenceSearch)

class ArgumentIterator(object):
    r"""An iterator through the arguments of a term"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def valid(self):
        r"""Is this iterator pointing to a valid argument?"""
        return _maude.ArgumentIterator_valid(self)

    def next(self):
        r"""Advance the iterator to the next argument."""
        return _maude.ArgumentIterator_next(self)

    def argument(self):
        r"""Get the argument pointed by this iterator"""
        return _maude.ArgumentIterator_argument(self)

    def __iter__(self):
    	return self

    def __next__(self):
    	if not self.valid():
    		raise StopIteration
    	term = self.argument()
    	self.next()
    	return term

    __swig_destroy__ = _maude.delete_ArgumentIterator

# Register ArgumentIterator in _maude:
_maude.ArgumentIterator_swigregister(ArgumentIterator)

class SortVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length=0):
        r"""
        Construct a vector.

        :type length: int
        :param length: The initial length.
        """
        _maude.SortVector_swiginit(self, _maude.new_SortVector(length))

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.SortVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.SortVector_size(self)

    def capacity(self):
        r"""Reserved capacity of the vector."""
        return _maude.SortVector_capacity(self)

    def swap(self, other):
        r"""
        Swap this vector's contents with another.

        :type other: Vector< Sort * >
        :param other: The other vector.
        """
        return _maude.SortVector_swap(self, other)

    def __getitem__(self, n):
        return _maude.SortVector___getitem__(self, n)

    def __setitem(self, n, value):
        return _maude.SortVector___setitem(self, n, value)

    def __len__(self):
        return _maude.SortVector___len__(self)

    def __append(self, item):
        return _maude.SortVector___append(self, item)

    def __setitem__(self, n, v):
    	v.thisown = 0
    	self.__setitem(n, v)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	vector_str = str(self[0])
    	for i in range(1, len(self)):
    		vector_str = vector_str + ', ' + str(self[i])

    	return vector_str

    def append(self, v):
    	v.thisown = 0
    	self.__append(v)


    def clear(self):
        r"""Set the vector length to zero."""
        return _maude.SortVector_clear(self)

    def resize(self, new_size):
        r"""
        Resize the vector.

        :type new_size: int
        :param new_size: New size.
        """
        return _maude.SortVector_resize(self, new_size)
    __swig_destroy__ = _maude.delete_SortVector

# Register SortVector in _maude:
_maude.SortVector_swigregister(SortVector)

class SymbolVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length=0):
        r"""
        Construct a vector.

        :type length: int
        :param length: The initial length.
        """
        _maude.SymbolVector_swiginit(self, _maude.new_SymbolVector(length))

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.SymbolVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.SymbolVector_size(self)

    def capacity(self):
        r"""Reserved capacity of the vector."""
        return _maude.SymbolVector_capacity(self)

    def swap(self, other):
        r"""
        Swap this vector's contents with another.

        :type other: Vector< Symbol * >
        :param other: The other vector.
        """
        return _maude.SymbolVector_swap(self, other)

    def __getitem__(self, n):
        return _maude.SymbolVector___getitem__(self, n)

    def __setitem(self, n, value):
        return _maude.SymbolVector___setitem(self, n, value)

    def __len__(self):
        return _maude.SymbolVector___len__(self)

    def __append(self, item):
        return _maude.SymbolVector___append(self, item)

    def __setitem__(self, n, v):
    	v.thisown = 0
    	self.__setitem(n, v)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	vector_str = str(self[0])
    	for i in range(1, len(self)):
    		vector_str = vector_str + ', ' + str(self[i])

    	return vector_str

    def append(self, v):
    	v.thisown = 0
    	self.__append(v)


    def clear(self):
        r"""Set the vector length to zero."""
        return _maude.SymbolVector_clear(self)

    def resize(self, new_size):
        r"""
        Resize the vector.

        :type new_size: int
        :param new_size: New size.
        """
        return _maude.SymbolVector_resize(self, new_size)
    __swig_destroy__ = _maude.delete_SymbolVector

# Register SymbolVector in _maude:
_maude.SymbolVector_swigregister(SymbolVector)

class KindVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length=0):
        r"""
        Construct a vector.

        :type length: int
        :param length: The initial length.
        """
        _maude.KindVector_swiginit(self, _maude.new_KindVector(length))

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.KindVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.KindVector_size(self)

    def capacity(self):
        r"""Reserved capacity of the vector."""
        return _maude.KindVector_capacity(self)

    def swap(self, other):
        r"""
        Swap this vector's contents with another.

        :type other: Vector< ConnectedComponent * >
        :param other: The other vector.
        """
        return _maude.KindVector_swap(self, other)

    def __getitem__(self, n):
        return _maude.KindVector___getitem__(self, n)

    def __setitem(self, n, value):
        return _maude.KindVector___setitem(self, n, value)

    def __len__(self):
        return _maude.KindVector___len__(self)

    def __append(self, item):
        return _maude.KindVector___append(self, item)

    def __setitem__(self, n, v):
    	v.thisown = 0
    	self.__setitem(n, v)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	vector_str = str(self[0])
    	for i in range(1, len(self)):
    		vector_str = vector_str + ', ' + str(self[i])

    	return vector_str

    def append(self, v):
    	v.thisown = 0
    	self.__append(v)


    def clear(self):
        r"""Set the vector length to zero."""
        return _maude.KindVector_clear(self)

    def resize(self, new_size):
        r"""
        Resize the vector.

        :type new_size: int
        :param new_size: New size.
        """
        return _maude.KindVector_resize(self, new_size)
    __swig_destroy__ = _maude.delete_KindVector

# Register KindVector in _maude:
_maude.KindVector_swigregister(KindVector)

class SubsortVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length=0):
        r"""
        Construct a vector.

        :type length: int
        :param length: The initial length.
        """
        _maude.SubsortVector_swiginit(self, _maude.new_SubsortVector(length))

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.SubsortVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.SubsortVector_size(self)

    def capacity(self):
        r"""Reserved capacity of the vector."""
        return _maude.SubsortVector_capacity(self)

    def swap(self, other):
        r"""
        Swap this vector's contents with another.

        :type other: Vector< SortConstraint * >
        :param other: The other vector.
        """
        return _maude.SubsortVector_swap(self, other)

    def __getitem__(self, n):
        return _maude.SubsortVector___getitem__(self, n)

    def __setitem(self, n, value):
        return _maude.SubsortVector___setitem(self, n, value)

    def __len__(self):
        return _maude.SubsortVector___len__(self)

    def __append(self, item):
        return _maude.SubsortVector___append(self, item)

    def __setitem__(self, n, v):
    	v.thisown = 0
    	self.__setitem(n, v)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	vector_str = str(self[0])
    	for i in range(1, len(self)):
    		vector_str = vector_str + ', ' + str(self[i])

    	return vector_str

    def append(self, v):
    	v.thisown = 0
    	self.__append(v)


    def clear(self):
        r"""Set the vector length to zero."""
        return _maude.SubsortVector_clear(self)

    def resize(self, new_size):
        r"""
        Resize the vector.

        :type new_size: int
        :param new_size: New size.
        """
        return _maude.SubsortVector_resize(self, new_size)
    __swig_destroy__ = _maude.delete_SubsortVector

# Register SubsortVector in _maude:
_maude.SubsortVector_swigregister(SubsortVector)

class EquationVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length=0):
        r"""
        Construct a vector.

        :type length: int
        :param length: The initial length.
        """
        _maude.EquationVector_swiginit(self, _maude.new_EquationVector(length))

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.EquationVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.EquationVector_size(self)

    def capacity(self):
        r"""Reserved capacity of the vector."""
        return _maude.EquationVector_capacity(self)

    def swap(self, other):
        r"""
        Swap this vector's contents with another.

        :type other: Vector< Equation * >
        :param other: The other vector.
        """
        return _maude.EquationVector_swap(self, other)

    def __getitem__(self, n):
        return _maude.EquationVector___getitem__(self, n)

    def __setitem(self, n, value):
        return _maude.EquationVector___setitem(self, n, value)

    def __len__(self):
        return _maude.EquationVector___len__(self)

    def __append(self, item):
        return _maude.EquationVector___append(self, item)

    def __setitem__(self, n, v):
    	v.thisown = 0
    	self.__setitem(n, v)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	vector_str = str(self[0])
    	for i in range(1, len(self)):
    		vector_str = vector_str + ', ' + str(self[i])

    	return vector_str

    def append(self, v):
    	v.thisown = 0
    	self.__append(v)


    def clear(self):
        r"""Set the vector length to zero."""
        return _maude.EquationVector_clear(self)

    def resize(self, new_size):
        r"""
        Resize the vector.

        :type new_size: int
        :param new_size: New size.
        """
        return _maude.EquationVector_resize(self, new_size)
    __swig_destroy__ = _maude.delete_EquationVector

# Register EquationVector in _maude:
_maude.EquationVector_swigregister(EquationVector)

class RuleVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length=0):
        r"""
        Construct a vector.

        :type length: int
        :param length: The initial length.
        """
        _maude.RuleVector_swiginit(self, _maude.new_RuleVector(length))

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.RuleVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.RuleVector_size(self)

    def capacity(self):
        r"""Reserved capacity of the vector."""
        return _maude.RuleVector_capacity(self)

    def swap(self, other):
        r"""
        Swap this vector's contents with another.

        :type other: Vector< Rule * >
        :param other: The other vector.
        """
        return _maude.RuleVector_swap(self, other)

    def __getitem__(self, n):
        return _maude.RuleVector___getitem__(self, n)

    def __setitem(self, n, value):
        return _maude.RuleVector___setitem(self, n, value)

    def __len__(self):
        return _maude.RuleVector___len__(self)

    def __append(self, item):
        return _maude.RuleVector___append(self, item)

    def __setitem__(self, n, v):
    	v.thisown = 0
    	self.__setitem(n, v)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	vector_str = str(self[0])
    	for i in range(1, len(self)):
    		vector_str = vector_str + ', ' + str(self[i])

    	return vector_str

    def append(self, v):
    	v.thisown = 0
    	self.__append(v)


    def clear(self):
        r"""Set the vector length to zero."""
        return _maude.RuleVector_clear(self)

    def resize(self, new_size):
        r"""
        Resize the vector.

        :type new_size: int
        :param new_size: New size.
        """
        return _maude.RuleVector_resize(self, new_size)
    __swig_destroy__ = _maude.delete_RuleVector

# Register RuleVector in _maude:
_maude.RuleVector_swigregister(RuleVector)

class StratVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length=0):
        r"""
        Construct a vector.

        :type length: int
        :param length: The initial length.
        """
        _maude.StratVector_swiginit(self, _maude.new_StratVector(length))

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.StratVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.StratVector_size(self)

    def capacity(self):
        r"""Reserved capacity of the vector."""
        return _maude.StratVector_capacity(self)

    def swap(self, other):
        r"""
        Swap this vector's contents with another.

        :type other: Vector< RewriteStrategy * >
        :param other: The other vector.
        """
        return _maude.StratVector_swap(self, other)

    def __getitem__(self, n):
        return _maude.StratVector___getitem__(self, n)

    def __setitem(self, n, value):
        return _maude.StratVector___setitem(self, n, value)

    def __len__(self):
        return _maude.StratVector___len__(self)

    def __append(self, item):
        return _maude.StratVector___append(self, item)

    def __setitem__(self, n, v):
    	v.thisown = 0
    	self.__setitem(n, v)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	vector_str = str(self[0])
    	for i in range(1, len(self)):
    		vector_str = vector_str + ', ' + str(self[i])

    	return vector_str

    def append(self, v):
    	v.thisown = 0
    	self.__append(v)


    def clear(self):
        r"""Set the vector length to zero."""
        return _maude.StratVector_clear(self)

    def resize(self, new_size):
        r"""
        Resize the vector.

        :type new_size: int
        :param new_size: New size.
        """
        return _maude.StratVector_resize(self, new_size)
    __swig_destroy__ = _maude.delete_StratVector

# Register StratVector in _maude:
_maude.StratVector_swigregister(StratVector)

class StratDefVector(object):
    r"""Internal Maude vector."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, length=0):
        r"""
        Construct a vector.

        :type length: int
        :param length: The initial length.
        """
        _maude.StratDefVector_swiginit(self, _maude.new_StratDefVector(length))

    def empty(self):
        r"""Is the vector empty?"""
        return _maude.StratDefVector_empty(self)

    def size(self):
        r"""Size of the vector."""
        return _maude.StratDefVector_size(self)

    def capacity(self):
        r"""Reserved capacity of the vector."""
        return _maude.StratDefVector_capacity(self)

    def swap(self, other):
        r"""
        Swap this vector's contents with another.

        :type other: Vector< StrategyDefinition * >
        :param other: The other vector.
        """
        return _maude.StratDefVector_swap(self, other)

    def __getitem__(self, n):
        return _maude.StratDefVector___getitem__(self, n)

    def __setitem(self, n, value):
        return _maude.StratDefVector___setitem(self, n, value)

    def __len__(self):
        return _maude.StratDefVector___len__(self)

    def __append(self, item):
        return _maude.StratDefVector___append(self, item)

    def __setitem__(self, n, v):
    	v.thisown = 0
    	self.__setitem(n, v)

    def __iter__(self):
    	return VectorIterator(self, len(self))

    def __repr__(self):
    	return '{} with {} elements'.format(type(self).__name__, len(self))

    def __str__(self):
    	if len(self) == 0:
    		return 'empty'

    	vector_str = str(self[0])
    	for i in range(1, len(self)):
    		vector_str = vector_str + ', ' + str(self[i])

    	return vector_str

    def append(self, v):
    	v.thisown = 0
    	self.__append(v)


    def clear(self):
        r"""Set the vector length to zero."""
        return _maude.StratDefVector_clear(self)

    def resize(self, new_size):
        r"""
        Resize the vector.

        :type new_size: int
        :param new_size: New size.
        """
        return _maude.StratDefVector_resize(self, new_size)
    __swig_destroy__ = _maude.delete_StratDefVector

# Register StratDefVector in _maude:
_maude.StratDefVector_swigregister(StratDefVector)

class Module(object):
    r"""A Maude module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    FUNCTIONAL_MODULE = _maude.Module_FUNCTIONAL_MODULE
    r""" Functional module (fmod)"""
    SYSTEM_MODULE = _maude.Module_SYSTEM_MODULE
    r""" System module (mod)"""
    STRATEGY_MODULE = _maude.Module_STRATEGY_MODULE
    r""" Strategy module (smod)"""
    FUNCTIONAL_THEORY = _maude.Module_FUNCTIONAL_THEORY
    r""" Functional theory (fth)"""
    SYSTEM_THEORY = _maude.Module_SYSTEM_THEORY
    r""" System module (th)"""
    STRATEGY_THEORY = _maude.Module_STRATEGY_THEORY
    r""" Strategy module (sth)"""

    def getModuleType(self):
        r"""Get the module type."""
        return _maude.Module_getModuleType(self)

    def getSorts(self):
        r"""Get the sorts declared in the module."""
        return _maude.Module_getSorts(self)

    def getSymbols(self):
        r"""Get the symbols declared in the module."""
        return _maude.Module_getSymbols(self)

    def getKinds(self):
        return _maude.Module_getKinds(self)

    def getMembershipAxioms(self):
        return _maude.Module_getMembershipAxioms(self)

    def getEquations(self):
        r"""Get the equations defined in the module."""
        return _maude.Module_getEquations(self)

    def getRules(self):
        r"""Get the rules defined in the module."""
        return _maude.Module_getRules(self)

    def getStrategies(self):
        r"""Get the strategies declared in the module."""
        return _maude.Module_getStrategies(self)

    def getStrategyDefinitions(self):
        r"""Get the strategy definitions defined in the module."""
        return _maude.Module_getStrategyDefinitions(self)

    def getNrParameters(self):
        r"""Number of parameters of the parameterized module."""
        return _maude.Module_getNrParameters(self)

    def hasFreeParameters(self):
        r"""Does the module have free parameters?"""
        return _maude.Module_hasFreeParameters(self)

    def getNrImportedSorts(self):
        r"""Number of sorts imported from other modules or parameters."""
        return _maude.Module_getNrImportedSorts(self)

    def getNrImportedSymbols(self):
        r"""Number of symbols imported from other modules or parameters."""
        return _maude.Module_getNrImportedSymbols(self)

    def getNrImportedStrategies(self):
        r"""Number of strategies imported from other modules or parameters."""
        return _maude.Module_getNrImportedStrategies(self)

    def getNrOriginalEquations(self):
        r"""Number of equations from this module."""
        return _maude.Module_getNrOriginalEquations(self)

    def getNrOriginalRules(self):
        r"""Number of rules from this module."""
        return _maude.Module_getNrOriginalRules(self)

    def getNrOriginalStrategyDefinitions(self):
        r"""Number of strategy definitions from this module."""
        return _maude.Module_getNrOriginalStrategyDefinitions(self)

    def getParameterTheory(self, index):
        r"""Get the theory of the given parameter."""
        return _maude.Module_getParameterTheory(self, index)

    def getParameterName(self, index):
        r"""
        Get the name of a module parameter.

        :type index: int
        :param index: Index of the parameter.
        """
        return _maude.Module_getParameterName(self, index)

    def findSort(self, name):
        r"""
        Finds a sort by its name in the module.

        :type name: string
        :param name: The name of the sort.

        :rtype: :py:class:`Sort`
        :return: The sort or null if it does not exists.
        """
        return _maude.Module_findSort(self, name)

    def parseTerm(self, *args):
        r"""
        *Overload 1:*

        Parse a term.

        :type bubble: std::vector< Token,std::allocator< Token > >
        :param bubble: Tokenized term.
        :type component: :py:class:`ConnectedComponent`
        :param component: Kind.

        |

        *Overload 2:*

        Parse a term.

        :type term_str: string
        :param term_str: A term represented as a string.
        :type component: :py:class:`ConnectedComponent`
        :param component: Kind.

        |

        *Overload 3:*

        Parse a term.

        :type term_str: string
        :param term_str: A term represented as a string.
        :param component: Kind.
        """
        return _maude.Module_parseTerm(self, *args)

    def parseStrategy(self, strat_str):
        r"""
        Parse a strategy expression.

        :param term_str: A strategy represented as a string.
        """
        return _maude.Module_parseStrategy(self, strat_str)

    def __repr__(self):
        return _maude.Module___repr__(self)
    __swig_destroy__ = _maude.delete_Module

# Register Module in _maude:
_maude.Module_swigregister(Module)

class View(object):
    r"""A Maude view."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def getFromTheory(self):
        r"""Get the *from* theory of the view."""
        return _maude.View_getFromTheory(self)

    def getToModule(self):
        r"""Get the *to* module of the view."""
        return _maude.View_getToModule(self)

    def __repr__(self):
        return _maude.View___repr__(self)
    __swig_destroy__ = _maude.delete_View

# Register View in _maude:
_maude.View_swigregister(View)



